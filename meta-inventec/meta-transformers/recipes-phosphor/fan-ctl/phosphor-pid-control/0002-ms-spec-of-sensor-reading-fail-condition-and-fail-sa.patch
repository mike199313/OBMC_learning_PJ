From cc22b886a8a167adcd0e6fa725d0fc06467abc4f Mon Sep 17 00:00:00 2001
From: link <link@inventec.com>
Date: Tue, 10 May 2022 09:51:05 +0800
Subject: [PATCH] ms spec of sensor reading fail condition and fail safe mode

20221222 - Bug 1444 - [Transformers][OpenBMC] Verify the SEL event failed after chassis power off then power on
20220527 - Bug 1012 - [SW][transformers][transformers-nuv][phosphor-pid-control] - Implement ms spec and remove conclict of acpi power control

======================================================================================================
Bug 1444 - [Transformers][OpenBMC] Verify the SEL event failed after chassis power off then power on

Symptom/Reason :
    - Sensor Die_CPU is judged to be a failed sensor, because it reach the lower critical threshold.
Root Cause     :
    - After the host is powered on, we will restart cpu sensor.
      Sometimes pid will receive "true" lower critical alarm before we restart cpu sensor.
      Pid will not received "false" lower critical alarm after this, because cpu sensor is restarted and initialized.
      Cpu sensor do not know Die_CPU has a "true" lower critical alarm at previous status.

Solution/Change:
    [meta-transformers][recpies-phosphor][phosphor-pid-control]
        - Add a additional alarm check after entering fail safe mode
    [meta-transformers-nuv][recpies-phosphor][phosphor-pid-control]
        - Add a additional alarm check after entering fail safe mode
Entry Test     :
    <check zone is startup>
        sysadmin@transformers:~# journalctl -u phosphor-pid-control -n 20
        Dec 21 08:42:38 transformers swampd[503]: pushing zone 0
    <Host off and check enter fail safe mode>
        sysadmin@transformers:~# ipmitool power off
        Chassis Power Control: Down/Off
        sysadmin@transformers:~# journalctl -u phosphor-pid-control -n 10
        Dec 21 08:44:31 transformers swampd[503]: Entering fail safe mode
        sysadmin@transformers:~# ipmitool sel elist | grep Sensors
         5d4 | 12/21/22 | 08:44:31 UTC | Unknown Sensors_reading_ |  | Asserted
        sysadmin@transformers:~# cat /var/lib/sel_log/ipmi_sel | grep Sensors_reading_status
        2022-12-21T08:44:31.933593+00:00 1492,2,1000FF,20,/xyz/openbmc_project/sensors/oem_event_71h/oem_e1h/Sensors_reading_status,1
    <Host on and check exit fail safe mode>
        sysadmin@transformers:~# ipmitool power on
        Chassis Power Control: Up/On
        sysadmin@transformers:~# journalctl -u phosphor-pid-control -n 20
        Dec 21 08:47:23 transformers swampd[503]: Exiting fail safe mode
        sysadmin@transformers:~# ipmitool sdr list
        DTS_CPU1         | 50 degrees C      | ok
        Die_CPU1         | 51 degrees C      | ok
        PCH_Temp         | 31 degrees C      | ok
        DIMM_A1_CPU1     | 32 degrees C      | ok
        sysadmin@transformers:~# ipmitool sel elist | grep Sensors
         5d4 | 12/21/22 | 08:44:31 UTC | Unknown Sensors_reading_ |  | Asserted
         623 | 12/21/22 | 08:47:23 UTC | Unknown Sensors_reading_ |  | Asserted
        sysadmin@transformers:~# cat /var/lib/sel_log/ipmi_sel | grep Sensors_reading_status
        2022-12-21T08:44:31.933593+00:00 1492,2,1000FF,20,/xyz/openbmc_project/sensors/oem_event_71h/oem_e1h/Sensors_reading_status,1
        2022-12-21T08:47:23.092225+00:00 1571,2,1001FF,20,/xyz/openbmc_project/sensors/oem_event_71h/oem_e1h/Sensors_reading_status,1

======================================================================================================
Bug 1012 - [SW][transformers][transformers-nuv][phosphor-pid-control] - Implement ms spec and remove conclict of acpi power control
    Symptom/Reason :
        - Implement ms spec of sensor reading fail and fail safe mode condition
        - Remove the stop and restart of related service
        - Remove the conclict part of acpi power state
    Root Cause     : N/A

    Solution/Change:
        [common][phosphor-pid-control]
            - Add step wise fail reading tolerance
            - Add update period to common patch of phosphor pid control
        [transformers][transformers-nuv][x86-power-control]
            - Remove the stop and restart of related service
        [transformers][transformers-nuv][acpi-power-state]
            - Remove the conclict part of acpi power state
        [transformers][transformers-nuv][phosphor-pid-control]
            - Implement ms reading sensor fail condition
            - Add SEL when reading sensor fail
            - Change fail safe mode trigger condition and fan duty
    Entry Test     :
        <check fan speed will be set to 60% at startup>
            sysadmin@transformers:~# systemctl restart phosphor-pid-control
            sysadmin@transformers:~# ipmitool sdr list
            FAN_PWM_1        | 59.98 unspecifi   | ok
            FAN_PWM_2        | 59.98 unspecifi   | ok
            FAN_PWM_3        | 59.98 unspecifi   | ok
            FAN_PWM_4        | 59.98 unspecifi   | ok
            FAN_PWM_5        | 59.98 unspecifi   | ok
            FAN_PWM_6        | 59.98 unspecifi   | ok
            FAN_PWM_7        | 59.98 unspecifi   | ok
            FAN_PWM_8        | 59.98 unspecifi   | ok
        <check zone fail safe percent>
            sysadmin@transformers:~# cat /usr/share/swampd/config.json
            "zones" : [{
                    "id": 0,
                    "failsafePercent": 100.0,
                    "UpdateTime": 10
            }]
        <check zone is startup>
            sysadmin@transformers:~# journalctl -u phosphor-pid-control
            May 17 05:02:57 transformers swampd[801]: Zone Id: 0
            May 17 05:02:57 transformers swampd[801]: PID name: CPU_DIMM
            May 17 05:02:57 transformers swampd[801]: inputs: DIMM_A1_CPU1,
            May 17 05:02:57 transformers swampd[801]: PID name: CPU_Temp
            May 17 05:02:57 transformers swampd[801]: inputs: DTS_CPU1, Die_CPU1,
            May 17 05:02:57 transformers swampd[801]: PID name: PCH_Temp
            May 17 05:02:57 transformers swampd[801]: inputs: PCH_Temp,
            May 17 05:02:57 transformers swampd[801]: PID name: fan-group
            May 17 05:02:57 transformers swampd[801]: inputs: FAN1_TACH1, FAN2_TACH1, FAN3_TACH1, FAN4_TACH1, FAN5_TACH1, FAN6_TACH1, FAN7_TACH1, FAN8_TACH1,
            May 17 05:02:57 transformers swampd[801]: pushing zone 0
            sysadmin@transformers:~# busctl tree xyz.openbmc_project.State.FanCtrl
            └─/xyz/openbmc_project/settings/fanctrl/zone0
        <check fan is being control>
            sysadmin@transformers:~# cat /sys/class/hwmon/*/pwm*
            81 81 81 81 81 81 81 81
            sysadmin@transformers:~# echo 255 > /sys/class/hwmon/*/pwm1
            sysadmin@transformers:~# cat /sys/class/hwmon/*/pwm*
            97 97 97 97 97 97 97 97
        <simulate fan is losing speed and check sel>
            sysadmin@transformers:~# cat fan-disturbing.sh
            #!/bin/sh
            while :do
                echo 1 > /sys/class/hwmon/*/pwm0
                echo 3 > /sys/class/hwmon/*/pwm2
                echo 5 > /sys/class/hwmon/*/pwm4
            done
            sysadmin@transformers:~# bash fan-disturbing.sh
            sysadmin@transformers:~# cat /sys/class/hwmon/*/pwm*
            1 114 3 114 5 114 114 114
            sysadmin@transformers:~# ipmitool sel elist
            2e5d | 05/25/22 | 07:02:43 UTC | Unknown Sensors_reading_ |  | Asserted
            sysadmin@transformers:~# cat  /var/lib/sel_log/ipmi_sel
            2022-05-25T07:02:43.891101+00:00 11869,2,0500FF,20,/xyz/openbmc_project/sensors/oem_event_71h/oem_e1h/Sensors_reading_status,1
        <check thermal read fail>
            sysadmin@transformers:~# ipmitool sdr list
            DTS_CPU1         | 55 degrees C      | ok
            Die_CPU1         | 55 degrees C      | ok
            sysadmin@transformers:~# ipmitool power cycle
            Chassis Power Control: Cycle
            sysadmin@transformers:~# ipmitool sdr list
            DTS_CPU1         | no reading        | ns
            Die_CPU1         | no reading        | ns
        <check fail safe mode 100% pwm and sel>
            (wait for 60 seconds)
            sysadmin@transformers:~# journalctl -u phosphor-pid-control -n 10
            May 25 07:13:25 transformers swampd[393]: Entering fail safe mode
            sysadmin@transformers:~# ipmitool sdr list
            FAN_PWM_1        | 99.96 unspecifi   | ok
            FAN_PWM_2        | 99.96 unspecifi   | ok
            FAN_PWM_3        | 99.96 unspecifi   | ok
            FAN_PWM_4        | 99.96 unspecifi   | ok
            FAN_PWM_5        | 99.96 unspecifi   | ok
            FAN_PWM_6        | 99.96 unspecifi   | ok
            FAN_PWM_7        | 99.96 unspecifi   | ok
            FAN_PWM_8        | 99.96 unspecifi   | ok
            sysadmin@transformers:~# ipmitool sel elist
            2eb8 | 05/25/22 | 07:13:25 UTC | Unknown Sensors_reading_ |  | Asserted
            sysadmin@transformers:~# cat /var/lib/sel_log/ipmi_sel
            2022-05-25T07:13:25.935376+00:00 11960,2,1000FF,20,/xyz/openbmc_project/sensors/oem_event_71h/oem_e1h/Sensors_reading_status,1
        <check sensors are back and sel>
            sysadmin@transformers:~# ipmitool sdr list
            DTS_CPU1         | 51 degrees C      | ok
            Die_CPU1         | 51 degrees C      | ok
            sysadmin@transformers:~# journalctl -u phosphor-pid-control -n 20
            May 25 07:14:47 transformers swampd[393]: Exiting fail safe mode
            sysadmin@transformers:~# ipmitool sel elist
            2f2b | 05/25/22 | 07:14:47 UTC | Unknown Sensors_reading_ |  | Asserted
            sysadmin@transformers:~# cat /var/lib/sel_log/ipmi_sel
            2022-05-25T07:14:47.269385+00:00 12075,2,1001FF,20,/xyz/openbmc_project/sensors/oem_event_71h/oem_e1h/Sensors_reading_status,1
            sysadmin@transformers:~#
        <check acpi control conflict is remove>
            sysadmin@transformers:~#  cat /sys/class/hwmon/*/pwm*
            107 107 107 107 107 107 107 107
            sysadmin@transformers:~# ipmitool power off
            Chassis Power Control: Down/Off
            sysadmin@transformers:~#  cat /sys/class/hwmon/*/pwm*
            110 110 110 110 110 110 110 110
---
 dbus/dbuspassive.cpp |  11 +++++
 pid/zone.cpp         | 107 ++++++++++++++++++++++++++++++++++++++-----
 pid/zone.hpp         |  18 ++++++++
 3 files changed, 124 insertions(+), 12 deletions(-)

diff --git a/dbus/dbuspassive.cpp b/dbus/dbuspassive.cpp
index 56b85ed..de8b1fa 100644
--- a/dbus/dbuspassive.cpp
+++ b/dbus/dbuspassive.cpp
@@ -244,6 +244,17 @@ void DbusPassive::updateValue(double value, bool force)
             _marginHot = true;
         }
     }
+    /*
+     * After the host is powered on, we will restart cpu sensor.
+     * Sometimes pid will receive "true" lower critical alarm before we restart cpu sensor.
+     * Pid will not received "false" lower critical alarm after this, because cpu sensor is restarted and initialized.
+     * Cpu sensor do not know Die_CPU has a "true" lower critical alarm at previous status.
+     * Add a additional threholds alarm check after entering fail safe mode.
+     */
+    if(_failed){
+        std::string service = _helper->getService(sensorintf, path);
+        _failed = _helper->thresholdsAsserted(service, path);
+    }
 
     setValue(value);
 }
diff --git a/pid/zone.cpp b/pid/zone.cpp
index 6acce79..5e76458 100644
--- a/pid/zone.cpp
+++ b/pid/zone.cpp
@@ -93,7 +93,7 @@ void DbusPidZone::setManualMode(bool mode)
 bool DbusPidZone::getFailSafeMode(void) const
 {
     // If any keys are present at least one sensor is in fail safe mode.
-    return !_failSafeSensors.empty();
+    return _tempFailSafeMode;
 }
 
 int64_t DbusPidZone::getZoneID(void) const
@@ -302,6 +302,7 @@ void DbusPidZone::updateFanTelemetry(void)
      * data is just being dropped though.
      */
     tstamp now = std::chrono::high_resolution_clock::now();
+    _fanFailCounting++;
     if (loggingEnabled)
     {
         _log << std::chrono::duration_cast<std::chrono::milliseconds>(
@@ -315,13 +316,13 @@ void DbusPidZone::updateFanTelemetry(void)
         auto sensor = _mgr.getSensor(f);
         ReadReturn r = sensor->read();
         _cachedValuesByName[f] = r.value;
-        int64_t timeout = sensor->getTimeout();
-        tstamp then = r.updated;
+        //int64_t timeout = sensor->getTimeout();
+        //tstamp then = r.updated;
 
-        auto duration =
+        /*auto duration =
             std::chrono::duration_cast<std::chrono::seconds>(now - then)
                 .count();
-        auto period = std::chrono::seconds(timeout).count();
+        auto period = std::chrono::seconds(timeout).count();*/
         /*
          * TODO(venture): We should check when these were last read.
          * However, these are the fans, so if I'm not getting updated values
@@ -331,7 +332,7 @@ void DbusPidZone::updateFanTelemetry(void)
         {
             _log << "," << r.value;
         }
-
+        /*
         // check if fan fail.
         if (sensor->getFailed())
         {
@@ -350,6 +351,44 @@ void DbusPidZone::updateFanTelemetry(void)
                 _failSafeSensors.erase(kt);
             }
         }
+        */
+    }
+
+    //check each 3 seconds
+    if((_fanFailCounting % _checkPeriod) == 0){
+        //sort
+        std::multimap<double, std::string> fanCompare;
+        for (const auto& t : _fanInputs){
+            fanCompare.insert({_cachedValuesByName[t], t});
+        }
+        //compute average
+        double averageFan = 0.0;
+        for (auto itr = std::next(fanCompare.begin(), _failFanNum);itr !=fanCompare.end();itr++){
+            averageFan += _cachedValuesByName[itr->second];
+        }
+        averageFan /= (fanCompare.size() - _failFanNum);
+        //checking problem fan
+        for (auto itr = std::next(fanCompare.begin(), _failFanNum);itr !=fanCompare.end();itr++){
+            if(_cachedValuesByName[itr->second] < averageFan * thresholdCoe){
+                //add sel
+                auto bus = sdbusplus::bus::new_default();
+                std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
+                /* asseted or deasserted according state */
+                eventData[0] = std::stoul(((itr->second).substr(0, (itr->second).find("_"))).substr((itr->second).find("FAN") + 3));
+                eventData[1] = 0x00; 
+
+                sdbusplus::message::message writeMcerrSEL = bus.new_method_call(
+                    ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
+                writeMcerrSEL.append(ipmiSELAddMessage, errorSensorPath, eventData, true, genId);
+                try{
+                    bus.call_noreply(writeMcerrSEL);
+                }catch (sdbusplus::exception_t& e){
+                    std::cerr << "Failed to log SEL\n";
+                }
+            }else{
+                break;
+            }
+        }
     }
 
     if (loggingEnabled)
@@ -369,6 +408,7 @@ void DbusPidZone::updateSensors(void)
     using namespace std::chrono;
     /* margin and temp are stored as temp */
     tstamp now = high_resolution_clock::now();
+    _tempFailCounting++;
     for (const auto& t : _thermalInputs)
     {
         auto sensor = _mgr.getSensor(t);
@@ -376,7 +416,7 @@ void DbusPidZone::updateSensors(void)
         int64_t timeout = sensor->getTimeout();
 
         _cachedValuesByName[t] = (r.value + _previousValuesByName[t]) / 2;
-	_previousValuesByName[t] = r.value;
+        _previousValuesByName[t] = r.value;
         tstamp then = r.updated;
 
         auto duration = duration_cast<std::chrono::seconds>(now - then).count();
@@ -388,7 +428,6 @@ void DbusPidZone::updateSensors(void)
         }
         else if (timeout != 0 && duration >= period)
         {
-            // std::cerr << "Entering fail safe mode.\n";
             _failSafeSensors.insert(t);
         }
         else
@@ -401,6 +440,50 @@ void DbusPidZone::updateSensors(void)
             }
         }
     }
+    //If find unread temp sensor and not in failSafeMode
+    if(!_failSafeSensors.empty() && !_tempFailSafeMode){
+        //If over 60 seconds, get in failSafeMode
+        if(_tempFailCounting >= _failTolerant){
+            std::cerr << "Entering fail safe mode\n";
+            _tempFailSafeMode = true;
+            _tempFailCounting = 0;
+            //add sel
+            auto bus = sdbusplus::bus::new_default();
+            std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
+            eventData[0] = 0x10;
+            eventData[1] = 0x00;
+            sdbusplus::message::message writeMcerrSEL = bus.new_method_call(
+                ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
+            writeMcerrSEL.append(ipmiSELAddMessage, errorSensorPath, eventData, true, genId);
+            try{
+                bus.call_noreply(writeMcerrSEL);
+            }catch (sdbusplus::exception_t& e){
+                std::cerr << "Failed to log SEL\n";
+            }
+        }//else keep counting
+    }else if(_failSafeSensors.empty()){
+        //If no unread, reset Mode and counting
+        if(_tempFailSafeMode){
+            std::cerr << "Exiting fail safe mode\n";
+            //add sel
+            auto bus = sdbusplus::bus::new_default();
+            std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
+            eventData[0] = 0x10;
+            eventData[1] = 0x01;
+            sdbusplus::message::message writeMcerrSEL = bus.new_method_call(
+            ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
+            writeMcerrSEL.append(ipmiSELAddMessage, errorSensorPath, eventData, true, genId);
+            try{
+                bus.call_noreply(writeMcerrSEL);
+            }catch (sdbusplus::exception_t& e){
+                std::cerr << "Failed to log SEL\n";
+            }
+        }
+        _tempFailSafeMode = false;
+        _tempFailCounting = 0;
+    }else{//Prevent counting keep adding, like failSafeMode=True
+        _tempFailCounting = 0;
+    }
 
     return;
 }
@@ -410,19 +493,19 @@ void DbusPidZone::initializeCache(void)
     for (const auto& f : _fanInputs)
     {
         _cachedValuesByName[f] = 0;
-	_previousValuesByName[f] = 0;
+        _previousValuesByName[f] = 0;
 
         // Start all fans in fail-safe mode.
-        _failSafeSensors.insert(f);
+        //_failSafeSensors.insert(f);
     }
 
     for (const auto& t : _thermalInputs)
     {
         _cachedValuesByName[t] = 0;
-	_previousValuesByName[t] = 0;
+        _previousValuesByName[t] = 0;
 
         // Start all sensors in fail-safe mode.
-        _failSafeSensors.insert(t);
+        //_failSafeSensors.insert(t);
     }
 }
 
diff --git a/pid/zone.hpp b/pid/zone.hpp
index d1bed57..a569393 100644
--- a/pid/zone.hpp
+++ b/pid/zone.hpp
@@ -10,6 +10,7 @@
 
 #include <sdbusplus/bus.hpp>
 #include <sdbusplus/server.hpp>
+#include <sdbusplus/message.hpp>
 #include <xyz/openbmc_project/Control/Mode/server.hpp>
 
 #include <fstream>
@@ -24,6 +25,14 @@ using ServerObject = typename sdbusplus::server::object::object<T...>;
 using ModeInterface = sdbusplus::xyz::openbmc_project::Control::server::Mode;
 using ModeObject = ServerObject<ModeInterface>;
 
+static constexpr char const* ipmiSELService = "xyz.openbmc_project.Logging.IPMI";
+static constexpr char const* ipmiSELPath = "/xyz/openbmc_project/Logging/IPMI";
+static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.IPMI";
+static const std::string ipmiSELAddMessage = "SEL Entry";
+static constexpr size_t selEvtDataMaxSize = 3;
+const uint16_t genId = 0x20;
+const std::string errorSensorPath = "/xyz/openbmc_project/sensors/oem_event_71h/oem_e1h/Sensors_reading_status";
+
 namespace pid_control
 {
 
@@ -109,6 +118,15 @@ class DbusPidZone : public ZoneInterface, public ModeObject
 
     std::set<std::string> _failSafeSensors;
 
+    bool _tempFailSafeMode = false;
+    int64_t _tempFailCounting = 0;
+    const int64_t _failTolerant = 60;
+
+    int64_t _fanFailCounting = 0;
+    const int64_t _checkPeriod = 3;
+    const int64_t _failFanNum = 2;
+    const double thresholdCoe = 0.75;
+
     std::vector<double> _SetPoints;
     std::vector<double> _RPMCeilings;
     std::vector<std::string> _fanInputs;
-- 
2.17.1

