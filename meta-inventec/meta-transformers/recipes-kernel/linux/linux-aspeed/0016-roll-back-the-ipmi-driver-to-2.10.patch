From 5d3b73664537fbb25caa16654b0c314208212da6 Mon Sep 17 00:00:00 2001
From: "liz.chiu" <Chiu.Liz@inventec.com>
Date: Wed, 12 Jul 2023 18:40:03 +0800
Subject: [PATCH] roll back the ipmi driver to 2.10.

---
 drivers/char/ipmi/Kconfig             |  43 --
 drivers/char/ipmi/Makefile            |   3 -
 drivers/char/ipmi/bt-bmc.c            |  74 ++-
 drivers/char/ipmi/ipmb_dev_int.c      |  25 +-
 drivers/char/ipmi/ipmi_devintf.c      |   1 +
 drivers/char/ipmi/ipmi_msghandler.c   |  74 ++-
 drivers/char/ipmi/ipmi_plat_data.c    |   2 +-
 drivers/char/ipmi/ipmi_si.h           |  10 +-
 drivers/char/ipmi/ipmi_si_hardcode.c  |  73 ++-
 drivers/char/ipmi/ipmi_si_hotmod.c    |  24 +-
 drivers/char/ipmi/ipmi_si_intf.c      |  67 +-
 drivers/char/ipmi/ipmi_si_parisc.c    |   4 +-
 drivers/char/ipmi/ipmi_si_pci.c       |  22 +-
 drivers/char/ipmi/ipmi_si_platform.c  |  99 +--
 drivers/char/ipmi/ipmi_ssif.c         |  81 ++-
 drivers/char/ipmi/ipmi_watchdog.c     |  48 +-
 drivers/char/ipmi/kcs_bmc.c           | 505 +++++++++++----
 drivers/char/ipmi/kcs_bmc.h           |  92 ++-
 drivers/char/ipmi/kcs_bmc_aspeed.c    | 649 ++++++-------------
 drivers/char/ipmi/kcs_bmc_cdev_ipmi.c | 568 -----------------
 drivers/char/ipmi/kcs_bmc_cdev_raw.c  | 447 -------------
 drivers/char/ipmi/kcs_bmc_client.h    |  45 --
 drivers/char/ipmi/kcs_bmc_device.h    |  22 -
 drivers/char/ipmi/kcs_bmc_npcm7xx.c   |  92 +--
 drivers/char/ipmi/kcs_bmc_serio.c     | 159 -----
 drivers/char/ipmi/ssif_bmc.c          | 873 --------------------------
 26 files changed, 1049 insertions(+), 3053 deletions(-)
 delete mode 100644 drivers/char/ipmi/kcs_bmc_cdev_ipmi.c
 delete mode 100644 drivers/char/ipmi/kcs_bmc_cdev_raw.c
 delete mode 100644 drivers/char/ipmi/kcs_bmc_client.h
 delete mode 100644 drivers/char/ipmi/kcs_bmc_device.h
 delete mode 100644 drivers/char/ipmi/kcs_bmc_serio.c
 delete mode 100644 drivers/char/ipmi/ssif_bmc.c

diff --git a/drivers/char/ipmi/Kconfig b/drivers/char/ipmi/Kconfig
index 8be37ea990cc..4ad1ba8f91e8 100644
--- a/drivers/char/ipmi/Kconfig
+++ b/drivers/char/ipmi/Kconfig
@@ -133,49 +133,6 @@ config NPCM7XX_KCS_IPMI_BMC
 	  This support is also available as a module.  If so, the module
 	  will be called kcs_bmc_npcm7xx.
 
-config IPMI_KCS_BMC_CDEV_IPMI
-	depends on IPMI_KCS_BMC
-	tristate "IPMI character device interface for BMC KCS devices"
-	help
-	  Provides a BMC-side character device implementing IPMI
-	  semantics for KCS IPMI devices.
-
-	  Say YES if you wish to expose KCS devices on the BMC for IPMI
-	  purposes.
-
-	  This support is also available as a module. The module will be
-	  called kcs_bmc_cdev_ipmi.
-
-config IPMI_KCS_BMC_SERIO
-	depends on IPMI_KCS_BMC && SERIO
-	tristate "SerIO adaptor for BMC KCS devices"
-	help
-	  Adapts the BMC KCS device for the SerIO subsystem. This allows users
-	  to take advantage of userspace interfaces provided by SerIO where
-	  appropriate.
-
-	  Say YES if you wish to expose KCS devices on the BMC via SerIO
-	  interfaces.
-
-	  This support is also available as a module. The module will be
-	  called kcs_bmc_serio.
-
-config IPMI_KCS_BMC_CDEV_RAW
-	depends on IPMI_KCS_BMC
-	tristate "Raw character device interface for BMC KCS devices"
-	help
-	  Provides a BMC-side character device directly exposing the
-	  data and status registers of a KCS device to userspace. While
-	  KCS devices are commonly used to implement IPMI message
-	  passing, they provide a general interface for exchange of
-	  interrupts, data and status information between the BMC and
-	  its host.
-
-	  Say YES if you wish to use the KCS devices to implement
-	  protocols that are not IPMI.
-
-	  This support is also available as a module. The module will be
-	  called kcs_bmc_cdev_raw.
 
 config ASPEED_BT_IPMI_BMC
 	depends on ARCH_ASPEED || COMPILE_TEST
diff --git a/drivers/char/ipmi/Makefile b/drivers/char/ipmi/Makefile
index e8910e15d7c5..709e89149c11 100644
--- a/drivers/char/ipmi/Makefile
+++ b/drivers/char/ipmi/Makefile
@@ -24,9 +24,6 @@ obj-$(CONFIG_IPMI_POWERNV) += ipmi_powernv.o
 obj-$(CONFIG_IPMI_WATCHDOG) += ipmi_watchdog.o
 obj-$(CONFIG_IPMI_POWEROFF) += ipmi_poweroff.o
 obj-$(CONFIG_IPMI_KCS_BMC) += kcs_bmc.o
-obj-$(CONFIG_IPMI_KCS_BMC_SERIO) += kcs_bmc_serio.o
-obj-$(CONFIG_IPMI_KCS_BMC_CDEV_IPMI) += kcs_bmc_cdev_ipmi.o
-obj-$(CONFIG_IPMI_KCS_BMC_CDEV_RAW) += kcs_bmc_cdev_raw.o
 obj-$(CONFIG_ASPEED_BT_IPMI_BMC) += bt-bmc.o
 obj-$(CONFIG_ASPEED_KCS_IPMI_BMC) += kcs_bmc_aspeed.o
 obj-$(CONFIG_NPCM7XX_KCS_IPMI_BMC) += kcs_bmc_npcm7xx.o
diff --git a/drivers/char/ipmi/bt-bmc.c b/drivers/char/ipmi/bt-bmc.c
index 7450904e330a..a514f531cb34 100644
--- a/drivers/char/ipmi/bt-bmc.c
+++ b/drivers/char/ipmi/bt-bmc.c
@@ -8,11 +8,13 @@
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
+#include <linux/mfd/syscon.h>
 #include <linux/miscdevice.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/poll.h>
+#include <linux/regmap.h>
 #include <linux/sched.h>
 #include <linux/timer.h>
 
@@ -57,7 +59,8 @@
 struct bt_bmc {
 	struct device		dev;
 	struct miscdevice	miscdev;
-	void __iomem		*base;
+	struct regmap		*map;
+	int			offset;
 	int			irq;
 	wait_queue_head_t	queue;
 	struct timer_list	poll_timer;
@@ -66,14 +69,29 @@ struct bt_bmc {
 
 static atomic_t open_count = ATOMIC_INIT(0);
 
+static const struct regmap_config bt_regmap_cfg = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+};
+
 static u8 bt_inb(struct bt_bmc *bt_bmc, int reg)
 {
-	return readb(bt_bmc->base + reg);
+	uint32_t val = 0;
+	int rc;
+
+	rc = regmap_read(bt_bmc->map, bt_bmc->offset + reg, &val);
+	WARN(rc != 0, "regmap_read() failed: %d\n", rc);
+
+	return rc == 0 ? (u8) val : 0;
 }
 
 static void bt_outb(struct bt_bmc *bt_bmc, u8 data, int reg)
 {
-	writeb(data, bt_bmc->base + reg);
+	int rc;
+
+	rc = regmap_write(bt_bmc->map, bt_bmc->offset + reg, data);
+	WARN(rc != 0, "regmap_write() failed: %d\n", rc);
 }
 
 static void clr_rd_ptr(struct bt_bmc *bt_bmc)
@@ -358,15 +376,18 @@ static irqreturn_t bt_bmc_irq(int irq, void *arg)
 {
 	struct bt_bmc *bt_bmc = arg;
 	u32 reg;
+	int rc;
 
-	reg = readl(bt_bmc->base + BT_CR2);
+	rc = regmap_read(bt_bmc->map, bt_bmc->offset + BT_CR2, &reg);
+	if (rc)
+		return IRQ_NONE;
 
 	reg &= BT_CR2_IRQ_H2B | BT_CR2_IRQ_HBUSY;
 	if (!reg)
 		return IRQ_NONE;
 
 	/* ack pending IRQs */
-	writel(reg, bt_bmc->base + BT_CR2);
+	regmap_write(bt_bmc->map, bt_bmc->offset + BT_CR2, reg);
 
 	wake_up(&bt_bmc->queue);
 	return IRQ_HANDLED;
@@ -377,7 +398,6 @@ static int bt_bmc_config_irq(struct bt_bmc *bt_bmc,
 {
 	struct device *dev = &pdev->dev;
 	int rc;
-	u32 reg;
 
 	bt_bmc->irq = platform_get_irq_optional(pdev, 0);
 	if (bt_bmc->irq < 0)
@@ -397,11 +417,11 @@ static int bt_bmc_config_irq(struct bt_bmc *bt_bmc,
 	 * will be cleared (along with B2H) when we can write the next
 	 * message to the BT buffer
 	 */
-	reg = readl(bt_bmc->base + BT_CR1);
-	reg |= BT_CR1_IRQ_H2B | BT_CR1_IRQ_HBUSY;
-	writel(reg, bt_bmc->base + BT_CR1);
+	rc = regmap_update_bits(bt_bmc->map, bt_bmc->offset + BT_CR1,
+				(BT_CR1_IRQ_H2B | BT_CR1_IRQ_HBUSY),
+				(BT_CR1_IRQ_H2B | BT_CR1_IRQ_HBUSY));
 
-	return 0;
+	return rc;
 }
 
 static int bt_bmc_probe(struct platform_device *pdev)
@@ -419,16 +439,32 @@ static int bt_bmc_probe(struct platform_device *pdev)
 
 	dev_set_drvdata(&pdev->dev, bt_bmc);
 
-	bt_bmc->base = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(bt_bmc->base))
-		return PTR_ERR(bt_bmc->base);
+	bt_bmc->map = syscon_node_to_regmap(pdev->dev.parent->of_node);
+	if (IS_ERR(bt_bmc->map)) {
+		void __iomem *base;
+
+		/*
+		 * Assume it's not the MFD-based devicetree description, in
+		 * which case generate a regmap ourselves
+		 */
+		base = devm_platform_ioremap_resource(pdev, 0);
+		if (IS_ERR(base))
+			return PTR_ERR(base);
+
+		bt_bmc->map = devm_regmap_init_mmio(dev, base, &bt_regmap_cfg);
+		bt_bmc->offset = 0;
+	} else {
+		rc = of_property_read_u32(dev->of_node, "reg", &bt_bmc->offset);
+		if (rc)
+			return rc;
+	}
 
 	mutex_init(&bt_bmc->mutex);
 	init_waitqueue_head(&bt_bmc->queue);
 
-	bt_bmc->miscdev.minor	= MISC_DYNAMIC_MINOR;
-	bt_bmc->miscdev.name	= DEVICE_NAME;
-	bt_bmc->miscdev.fops	= &bt_bmc_fops;
+	bt_bmc->miscdev.minor	= MISC_DYNAMIC_MINOR,
+	bt_bmc->miscdev.name	= DEVICE_NAME,
+	bt_bmc->miscdev.fops	= &bt_bmc_fops,
 	bt_bmc->miscdev.parent = dev;
 	rc = misc_register(&bt_bmc->miscdev);
 	if (rc) {
@@ -447,12 +483,12 @@ static int bt_bmc_probe(struct platform_device *pdev)
 		add_timer(&bt_bmc->poll_timer);
 	}
 
-	writel((BT_IO_BASE << BT_CR0_IO_BASE) |
+	regmap_write(bt_bmc->map, bt_bmc->offset + BT_CR0,
+		     (BT_IO_BASE << BT_CR0_IO_BASE) |
 		     (BT_IRQ << BT_CR0_IRQ) |
 		     BT_CR0_EN_CLR_SLV_RDP |
 		     BT_CR0_EN_CLR_SLV_WRP |
-		     BT_CR0_ENABLE_IBT,
-		bt_bmc->base + BT_CR0);
+		     BT_CR0_ENABLE_IBT);
 
 	clr_b_busy(bt_bmc);
 
diff --git a/drivers/char/ipmi/ipmb_dev_int.c b/drivers/char/ipmi/ipmb_dev_int.c
index a0e9e80d92ee..b21b66eb6bcc 100644
--- a/drivers/char/ipmi/ipmb_dev_int.c
+++ b/drivers/char/ipmi/ipmb_dev_int.c
@@ -137,7 +137,7 @@ static ssize_t ipmb_write(struct file *file, const char __user *buf,
 {
 	struct ipmb_dev *ipmb_dev = to_ipmb_dev(file);
 	u8 rq_sa, netf_rq_lun, msg_len;
-	struct i2c_client *temp_client;
+	union i2c_smbus_data data;
 	u8 msg[MAX_MSG_LEN];
 	ssize_t ret;
 
@@ -160,21 +160,20 @@ static ssize_t ipmb_write(struct file *file, const char __user *buf,
 	}
 
 	/*
-	 * subtract rq_sa and netf_rq_lun from the length of the msg. Fill the
-	 * temporary client. Note that its use is an exception for IPMI.
+	 * subtract rq_sa and netf_rq_lun from the length of the msg passed to
+	 * i2c_smbus_xfer
 	 */
-	msg_len = msg[IPMB_MSG_LEN_IDX] - SMBUS_MSG_HEADER_LENGTH;
-	temp_client = kmemdup(ipmb_dev->client, sizeof(*temp_client), GFP_KERNEL);
-	if (!temp_client)
-		return -ENOMEM;
-
-	temp_client->addr = rq_sa;
+	if (msg_len > I2C_SMBUS_BLOCK_MAX)
+		msg_len = I2C_SMBUS_BLOCK_MAX;
 
-	ret = i2c_smbus_write_block_data(temp_client, netf_rq_lun, msg_len,
-					 msg + SMBUS_MSG_IDX_OFFSET);
-	kfree(temp_client);
+	data.block[0] = msg_len;
+	memcpy(&data.block[1], msg + SMBUS_MSG_IDX_OFFSET, msg_len);
+	ret = i2c_smbus_xfer(ipmb_dev->client->adapter, rq_sa,
+			     ipmb_dev->client->flags,
+			     I2C_SMBUS_WRITE, netf_rq_lun,
+			     I2C_SMBUS_BLOCK_DATA, &data);
 
-	return ret < 0 ? ret : count;
+	return ret ? : count;
 }
 
 static __poll_t ipmb_poll(struct file *file, poll_table *wait)
diff --git a/drivers/char/ipmi/ipmi_devintf.c b/drivers/char/ipmi/ipmi_devintf.c
index d160fa4c73fe..e2048b5152b1 100644
--- a/drivers/char/ipmi/ipmi_devintf.c
+++ b/drivers/char/ipmi/ipmi_devintf.c
@@ -492,6 +492,7 @@ static long ipmi_ioctl(struct file   *file,
 		}
 
 		return ipmi_set_my_address(priv->user, val.channel, val.value);
+		break;
 	}
 
 	case IPMICTL_GET_MY_CHANNEL_ADDRESS_CMD:
diff --git a/drivers/char/ipmi/ipmi_msghandler.c b/drivers/char/ipmi/ipmi_msghandler.c
index 5d403fb5bd92..eff9210d1934 100644
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@ -16,7 +16,6 @@
 
 #include <linux/module.h>
 #include <linux/errno.h>
-#include <linux/panic_notifier.h>
 #include <linux/poll.h>
 #include <linux/sched.h>
 #include <linux/seq_file.h>
@@ -50,17 +49,11 @@ static int handle_one_recv_msg(struct ipmi_smi *intf,
 static bool initialized;
 static bool drvregistered;
 
-/* Numbers in this enumerator should be mapped to ipmi_panic_event_str */
 enum ipmi_panic_event_op {
 	IPMI_SEND_PANIC_EVENT_NONE,
 	IPMI_SEND_PANIC_EVENT,
-	IPMI_SEND_PANIC_EVENT_STRING,
-	IPMI_SEND_PANIC_EVENT_MAX
+	IPMI_SEND_PANIC_EVENT_STRING
 };
-
-/* Indices in this array should be mapped to enum ipmi_panic_event_op */
-static const char *const ipmi_panic_event_str[] = { "none", "event", "string", NULL };
-
 #ifdef CONFIG_IPMI_PANIC_STRING
 #define IPMI_PANIC_DEFAULT IPMI_SEND_PANIC_EVENT_STRING
 #elif defined(CONFIG_IPMI_PANIC_EVENT)
@@ -75,27 +68,46 @@ static int panic_op_write_handler(const char *val,
 				  const struct kernel_param *kp)
 {
 	char valcp[16];
-	int e;
+	char *s;
+
+	strncpy(valcp, val, 15);
+	valcp[15] = '\0';
 
-	strscpy(valcp, val, sizeof(valcp));
-	e = match_string(ipmi_panic_event_str, -1, strstrip(valcp));
-	if (e < 0)
-		return e;
+	s = strstrip(valcp);
+
+	if (strcmp(s, "none") == 0)
+		ipmi_send_panic_event = IPMI_SEND_PANIC_EVENT_NONE;
+	else if (strcmp(s, "event") == 0)
+		ipmi_send_panic_event = IPMI_SEND_PANIC_EVENT;
+	else if (strcmp(s, "string") == 0)
+		ipmi_send_panic_event = IPMI_SEND_PANIC_EVENT_STRING;
+	else
+		return -EINVAL;
 
-	ipmi_send_panic_event = e;
 	return 0;
 }
 
 static int panic_op_read_handler(char *buffer, const struct kernel_param *kp)
 {
-	const char *event_str;
+	switch (ipmi_send_panic_event) {
+	case IPMI_SEND_PANIC_EVENT_NONE:
+		strcpy(buffer, "none\n");
+		break;
 
-	if (ipmi_send_panic_event >= IPMI_SEND_PANIC_EVENT_MAX)
-		event_str = "???";
-	else
-		event_str = ipmi_panic_event_str[ipmi_send_panic_event];
+	case IPMI_SEND_PANIC_EVENT:
+		strcpy(buffer, "event\n");
+		break;
+
+	case IPMI_SEND_PANIC_EVENT_STRING:
+		strcpy(buffer, "string\n");
+		break;
 
-	return sprintf(buffer, "%s\n", event_str);
+	default:
+		strcpy(buffer, "???\n");
+		break;
+	}
+
+	return strlen(buffer);
 }
 
 static const struct kernel_param_ops panic_op_ops = {
@@ -754,8 +766,7 @@ int ipmi_smi_watcher_register(struct ipmi_smi_watcher *watcher)
 	list_add(&watcher->link, &smi_watchers);
 
 	index = srcu_read_lock(&ipmi_interfaces_srcu);
-	list_for_each_entry_rcu(intf, &ipmi_interfaces, link,
-			lockdep_is_held(&smi_watchers_mutex)) {
+	list_for_each_entry_rcu(intf, &ipmi_interfaces, link) {
 		int intf_num = READ_ONCE(intf->intf_num);
 
 		if (intf_num == -1)
@@ -2571,8 +2582,10 @@ static int __get_device_id(struct ipmi_smi *intf, struct bmc_device *bmc)
 	wait_event(intf->waitq, bmc->dyn_id_set != 2);
 
 	if (!bmc->dyn_id_set) {
-		if (bmc->cc != IPMI_CC_NO_ERROR &&
-		    ++retry_count <= GET_DEVICE_ID_MAX_RETRY) {
+		if ((bmc->cc == IPMI_DEVICE_IN_FW_UPDATE_ERR
+		     || bmc->cc ==  IPMI_DEVICE_IN_INIT_ERR
+		     || bmc->cc ==  IPMI_NOT_IN_MY_STATE_ERR)
+		     && ++retry_count <= GET_DEVICE_ID_MAX_RETRY) {
 			msleep(500);
 			dev_warn(intf->si_dev,
 			    "BMC returned 0x%2.2x, retry get bmc device id\n",
@@ -5128,9 +5141,7 @@ static atomic_t recv_msg_inuse_count = ATOMIC_INIT(0);
 static void free_smi_msg(struct ipmi_smi_msg *msg)
 {
 	atomic_dec(&smi_msg_inuse_count);
-	/* Try to keep as much stuff out of the panic path as possible. */
-	if (!oops_in_progress)
-		kfree(msg);
+	kfree(msg);
 }
 
 struct ipmi_smi_msg *ipmi_alloc_smi_msg(void)
@@ -5150,9 +5161,7 @@ EXPORT_SYMBOL(ipmi_alloc_smi_msg);
 static void free_recv_msg(struct ipmi_recv_msg *msg)
 {
 	atomic_dec(&recv_msg_inuse_count);
-	/* Try to keep as much stuff out of the panic path as possible. */
-	if (!oops_in_progress)
-		kfree(msg);
+	kfree(msg);
 }
 
 static struct ipmi_recv_msg *ipmi_alloc_recv_msg(void)
@@ -5170,7 +5179,7 @@ static struct ipmi_recv_msg *ipmi_alloc_recv_msg(void)
 
 void ipmi_free_recv_msg(struct ipmi_recv_msg *msg)
 {
-	if (msg->user && !oops_in_progress)
+	if (msg->user)
 		kref_put(&msg->user->refcount, free_user);
 	msg->done(msg);
 }
@@ -5568,6 +5577,7 @@ module_exit(cleanup_ipmi);
 module_init(ipmi_init_msghandler_mod);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Corey Minyard <minyard@mvista.com>");
-MODULE_DESCRIPTION("Incoming and outgoing message routing for an IPMI interface.");
+MODULE_DESCRIPTION("Incoming and outgoing message routing for an IPMI"
+		   " interface.");
 MODULE_VERSION(IPMI_DRIVER_VERSION);
 MODULE_SOFTDEP("post: ipmi_devintf");
diff --git a/drivers/char/ipmi/ipmi_plat_data.c b/drivers/char/ipmi/ipmi_plat_data.c
index 747b51ae01a8..28471ff2a3a3 100644
--- a/drivers/char/ipmi/ipmi_plat_data.c
+++ b/drivers/char/ipmi/ipmi_plat_data.c
@@ -102,7 +102,7 @@ struct platform_device *ipmi_platform_add(const char *name, unsigned int inst,
 		goto err;
 	}
  add_properties:
-	rv = device_create_managed_software_node(&pdev->dev, pr, NULL);
+	rv = platform_device_add_properties(pdev, pr);
 	if (rv) {
 		dev_err(&pdev->dev,
 			"Unable to add hard-code properties: %d\n", rv);
diff --git a/drivers/char/ipmi/ipmi_si.h b/drivers/char/ipmi/ipmi_si.h
index a7ead2a4c753..bac0ff86e48e 100644
--- a/drivers/char/ipmi/ipmi_si.h
+++ b/drivers/char/ipmi/ipmi_si.h
@@ -18,14 +18,10 @@
 #define DEFAULT_REGSPACING	1
 #define DEFAULT_REGSIZE		1
 
-/* Numbers in this enumerator should be mapped to si_to_str[] */
 enum si_type {
-	SI_TYPE_INVALID, SI_KCS, SI_SMIC, SI_BT, SI_TYPE_MAX
+	SI_TYPE_INVALID, SI_KCS, SI_SMIC, SI_BT
 };
 
-/* Array is defined in the ipmi_si_intf.c */
-extern const char *const si_to_str[];
-
 enum ipmi_addr_space {
 	IPMI_IO_ADDR_SPACE, IPMI_MEM_ADDR_SPACE
 };
@@ -52,6 +48,8 @@ struct si_sm_io {
 	enum ipmi_addr_space addr_space;
 	unsigned long addr_data;
 	enum ipmi_addr_src addr_source; /* ACPI, PCI, SMBIOS, hardcode, etc. */
+	void (*addr_source_cleanup)(struct si_sm_io *io);
+	void *addr_source_data;
 	union ipmi_smi_info_union addr_info;
 
 	int (*io_setup)(struct si_sm_io *info);
@@ -73,7 +71,7 @@ irqreturn_t ipmi_si_irq_handler(int irq, void *data);
 void ipmi_irq_start_cleanup(struct si_sm_io *io);
 int ipmi_std_irq_setup(struct si_sm_io *io);
 void ipmi_irq_finish_setup(struct si_sm_io *io);
-void ipmi_si_remove_by_dev(struct device *dev);
+int ipmi_si_remove_by_dev(struct device *dev);
 struct device *ipmi_si_remove_by_data(int addr_space, enum si_type si_type,
 				      unsigned long addr);
 void ipmi_hardcode_init(void);
diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
index ed5e91b1e040..f6ece7569504 100644
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -32,29 +32,47 @@ static int slave_addrs[SI_MAX_PARMS] __initdata;
 static unsigned int num_slave_addrs __initdata;
 
 module_param_string(type, si_type_str, MAX_SI_TYPE_STR, 0);
-MODULE_PARM_DESC(type,
-		 "Defines the type of each interface, each interface separated by commas.  The types are 'kcs', 'smic', and 'bt'.  For example si_type=kcs,bt will set the first interface to kcs and the second to bt");
+MODULE_PARM_DESC(type, "Defines the type of each interface, each"
+		 " interface separated by commas.  The types are 'kcs',"
+		 " 'smic', and 'bt'.  For example si_type=kcs,bt will set"
+		 " the first interface to kcs and the second to bt");
 module_param_hw_array(addrs, ulong, iomem, &num_addrs, 0);
-MODULE_PARM_DESC(addrs,
-		 "Sets the memory address of each interface, the addresses separated by commas.  Only use if an interface is in memory.  Otherwise, set it to zero or leave it blank.");
+MODULE_PARM_DESC(addrs, "Sets the memory address of each interface, the"
+		 " addresses separated by commas.  Only use if an interface"
+		 " is in memory.  Otherwise, set it to zero or leave"
+		 " it blank.");
 module_param_hw_array(ports, uint, ioport, &num_ports, 0);
-MODULE_PARM_DESC(ports,
-		 "Sets the port address of each interface, the addresses separated by commas.  Only use if an interface is a port.  Otherwise, set it to zero or leave it blank.");
+MODULE_PARM_DESC(ports, "Sets the port address of each interface, the"
+		 " addresses separated by commas.  Only use if an interface"
+		 " is a port.  Otherwise, set it to zero or leave"
+		 " it blank.");
 module_param_hw_array(irqs, int, irq, &num_irqs, 0);
-MODULE_PARM_DESC(irqs,
-		 "Sets the interrupt of each interface, the addresses separated by commas.  Only use if an interface has an interrupt.  Otherwise, set it to zero or leave it blank.");
+MODULE_PARM_DESC(irqs, "Sets the interrupt of each interface, the"
+		 " addresses separated by commas.  Only use if an interface"
+		 " has an interrupt.  Otherwise, set it to zero or leave"
+		 " it blank.");
 module_param_hw_array(regspacings, int, other, &num_regspacings, 0);
-MODULE_PARM_DESC(regspacings,
-		 "The number of bytes between the start address and each successive register used by the interface.  For instance, if the start address is 0xca2 and the spacing is 2, then the second address is at 0xca4.  Defaults to 1.");
+MODULE_PARM_DESC(regspacings, "The number of bytes between the start address"
+		 " and each successive register used by the interface.  For"
+		 " instance, if the start address is 0xca2 and the spacing"
+		 " is 2, then the second address is at 0xca4.  Defaults"
+		 " to 1.");
 module_param_hw_array(regsizes, int, other, &num_regsizes, 0);
-MODULE_PARM_DESC(regsizes,
-		 "The size of the specific IPMI register in bytes. This should generally be 1, 2, 4, or 8 for an 8-bit, 16-bit, 32-bit, or 64-bit register.  Use this if you the 8-bit IPMI register has to be read from a larger register.");
+MODULE_PARM_DESC(regsizes, "The size of the specific IPMI register in bytes."
+		 " This should generally be 1, 2, 4, or 8 for an 8-bit,"
+		 " 16-bit, 32-bit, or 64-bit register.  Use this if you"
+		 " the 8-bit IPMI register has to be read from a larger"
+		 " register.");
 module_param_hw_array(regshifts, int, other, &num_regshifts, 0);
-MODULE_PARM_DESC(regshifts,
-		 "The amount to shift the data read from the. IPMI register, in bits.  For instance, if the data is read from a 32-bit word and the IPMI data is in bit 8-15, then the shift would be 8");
+MODULE_PARM_DESC(regshifts, "The amount to shift the data read from the."
+		 " IPMI register, in bits.  For instance, if the data"
+		 " is read from a 32-bit word and the IPMI data is in"
+		 " bit 8-15, then the shift would be 8");
 module_param_hw_array(slave_addrs, int, other, &num_slave_addrs, 0);
-MODULE_PARM_DESC(slave_addrs,
-		 "Set the default IPMB slave address for the controller.  Normally this is 0x20, but can be overridden by this parm.  This is an array indexed by interface number.");
+MODULE_PARM_DESC(slave_addrs, "Set the default IPMB slave address for"
+		 " the controller.  Normally this is 0x20, but can be"
+		 " overridden by this parm.  This is an array indexed"
+		 " by interface number.");
 
 static void __init ipmi_hardcode_init_one(const char *si_type_str,
 					  unsigned int i,
@@ -62,21 +80,26 @@ static void __init ipmi_hardcode_init_one(const char *si_type_str,
 					  enum ipmi_addr_space addr_space)
 {
 	struct ipmi_plat_data p;
-	int t;
 
 	memset(&p, 0, sizeof(p));
 
 	p.iftype = IPMI_PLAT_IF_SI;
-	if (!si_type_str || !*si_type_str) {
+	if (!si_type_str || !*si_type_str || strcmp(si_type_str, "kcs") == 0) {
 		p.type = SI_KCS;
+	} else if (strcmp(si_type_str, "smic") == 0) {
+		p.type = SI_SMIC;
+	} else if (strcmp(si_type_str, "bt") == 0) {
+		p.type = SI_BT;
+	} else if (strcmp(si_type_str, "invalid") == 0) {
+		/*
+		 * Allow a firmware-specified interface to be
+		 * disabled.
+		 */
+		p.type = SI_TYPE_INVALID;
 	} else {
-		t = match_string(si_to_str, -1, si_type_str);
-		if (t < 0) {
-			pr_warn("Interface type specified for interface %d, was invalid: %s\n",
-				i, si_type_str);
-			return;
-		}
-		p.type = t;
+		pr_warn("Interface type specified for interface %d, was invalid: %s\n",
+			i, si_type_str);
+		return;
 	}
 
 	p.regsize = regsizes[i];
diff --git a/drivers/char/ipmi/ipmi_si_hotmod.c b/drivers/char/ipmi/ipmi_si_hotmod.c
index 6b12a83ccd4c..4fbb4e18bae2 100644
--- a/drivers/char/ipmi/ipmi_si_hotmod.c
+++ b/drivers/char/ipmi/ipmi_si_hotmod.c
@@ -17,8 +17,9 @@
 static int hotmod_handler(const char *val, const struct kernel_param *kp);
 
 module_param_call(hotmod, hotmod_handler, NULL, NULL, 0200);
-MODULE_PARM_DESC(hotmod,
-		 "Add and remove interfaces.  See Documentation/driver-api/ipmi.rst in the kernel sources for the gory details.");
+MODULE_PARM_DESC(hotmod, "Add and remove interfaces.  See"
+		 " Documentation/driver-api/ipmi.rst in the kernel sources for the"
+		 " gory details.");
 
 /*
  * Parms come in as <op1>[:op2[:op3...]].  ops are:
@@ -184,16 +185,24 @@ static atomic_t hotmod_nr;
 
 static int hotmod_handler(const char *val, const struct kernel_param *kp)
 {
+	char *str = kstrdup(val, GFP_KERNEL), *curr, *next;
 	int  rv;
 	struct ipmi_plat_data h;
-	char *str, *curr, *next;
+	unsigned int len;
+	int ival;
 
-	str = kstrdup(val, GFP_KERNEL);
 	if (!str)
 		return -ENOMEM;
 
 	/* Kill any trailing spaces, as we can get a "\n" from echo. */
-	for (curr = strstrip(str); curr; curr = next) {
+	len = strlen(str);
+	ival = len - 1;
+	while ((ival >= 0) && isspace(str[ival])) {
+		str[ival] = '\0';
+		ival--;
+	}
+
+	for (curr = str; curr; curr = next) {
 		enum hotmod_op op;
 
 		next = strchr(curr, ':');
@@ -222,10 +231,11 @@ static int hotmod_handler(const char *val, const struct kernel_param *kp)
 				if (strcmp(pdev->name, "hotmod-ipmi-si") == 0)
 					platform_device_unregister(pdev);
 			}
-			put_device(dev);
+			if (dev)
+				put_device(dev);
 		}
 	}
-	rv = strlen(val);
+	rv = len;
 out:
 	kfree(str);
 	return rv;
diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c
index abddd7e43a9a..1b3b00fbb408 100644
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@ -70,8 +70,7 @@ enum si_intf_state {
 #define IPMI_BT_INTMASK_CLEAR_IRQ_BIT	2
 #define IPMI_BT_INTMASK_ENABLE_IRQ_BIT	1
 
-/* 'invalid' to allow a firmware-specified interface to be disabled */
-const char *const si_to_str[] = { "invalid", "kcs", "smic", "bt", NULL };
+static const char * const si_to_str[] = { "invalid", "kcs", "smic", "bt" };
 
 static bool initialized;
 
@@ -592,7 +591,7 @@ static void handle_transaction_done(struct smi_info *smi_info)
 		smi_info->handlers->get_result(smi_info->si_sm, msg, 3);
 		if (msg[2] != 0) {
 			/* Error clearing flags */
-			dev_warn_ratelimited(smi_info->io.dev,
+			dev_warn(smi_info->io.dev,
 				 "Error clearing flags: %2.2x\n", msg[2]);
 		}
 		smi_info->si_state = SI_NORMAL;
@@ -684,10 +683,10 @@ static void handle_transaction_done(struct smi_info *smi_info)
 		/* We got the flags from the SMI, now handle them. */
 		smi_info->handlers->get_result(smi_info->si_sm, msg, 4);
 		if (msg[2] != 0) {
-			dev_warn_ratelimited(smi_info->io.dev,
-				"Couldn't get irq info: %x,\n"
-				"Maybe ok, but ipmi might run very slowly.\n",
-				msg[2]);
+			dev_warn(smi_info->io.dev,
+				 "Couldn't get irq info: %x.\n", msg[2]);
+			dev_warn(smi_info->io.dev,
+				 "Maybe ok, but ipmi might run very slowly.\n");
 			smi_info->si_state = SI_NORMAL;
 			break;
 		}
@@ -722,7 +721,7 @@ static void handle_transaction_done(struct smi_info *smi_info)
 
 		smi_info->handlers->get_result(smi_info->si_sm, msg, 4);
 		if (msg[2] != 0)
-			dev_warn_ratelimited(smi_info->io.dev,
+			dev_warn(smi_info->io.dev,
 				 "Could not set the global enables: 0x%x.\n",
 				 msg[2]);
 
@@ -1171,8 +1170,9 @@ static int smi_start_processing(void            *send_info,
 		new_smi->thread = kthread_run(ipmi_thread, new_smi,
 					      "kipmi%d", new_smi->si_num);
 		if (IS_ERR(new_smi->thread)) {
-			dev_notice(new_smi->io.dev,
-				   "Could not start kernel thread due to error %ld, only using timers to drive the interface\n",
+			dev_notice(new_smi->io.dev, "Could not start"
+				   " kernel thread due to error %ld, only using"
+				   " timers to drive the interface\n",
 				   PTR_ERR(new_smi->thread));
 			new_smi->thread = NULL;
 		}
@@ -1224,14 +1224,18 @@ static int smi_num; /* Used to sequence the SMIs */
 static const char * const addr_space_to_str[] = { "i/o", "mem" };
 
 module_param_array(force_kipmid, int, &num_force_kipmid, 0);
-MODULE_PARM_DESC(force_kipmid,
-		 "Force the kipmi daemon to be enabled (1) or disabled(0).  Normally the IPMI driver auto-detects this, but the value may be overridden by this parm.");
+MODULE_PARM_DESC(force_kipmid, "Force the kipmi daemon to be enabled (1) or"
+		 " disabled(0).  Normally the IPMI driver auto-detects"
+		 " this, but the value may be overridden by this parm.");
 module_param(unload_when_empty, bool, 0);
-MODULE_PARM_DESC(unload_when_empty,
-		 "Unload the module if no interfaces are specified or found, default is 1.  Setting to 0 is useful for hot add of devices using hotmod.");
+MODULE_PARM_DESC(unload_when_empty, "Unload the module if no interfaces are"
+		 " specified or found, default is 1.  Setting to 0"
+		 " is useful for hot add of devices using hotmod.");
 module_param_array(kipmid_max_busy_us, uint, &num_max_busy_us, 0644);
 MODULE_PARM_DESC(kipmid_max_busy_us,
-		 "Max time (in microseconds) to busy-wait for IPMI data before sleeping. 0 (default) means to wait forever. Set to 100-500 if kipmid is using up a lot of CPU time.");
+		 "Max time (in microseconds) to busy-wait for IPMI data before"
+		 " sleeping. 0 (default) means to wait forever. Set to 100-500"
+		 " if kipmid is using up a lot of CPU time.");
 
 void ipmi_irq_finish_setup(struct si_sm_io *io)
 {
@@ -1267,7 +1271,8 @@ int ipmi_std_irq_setup(struct si_sm_io *io)
 			 SI_DEVICE_NAME,
 			 io->irq_handler_data);
 	if (rv) {
-		dev_warn(io->dev, "%s unable to claim interrupt %d, running polled\n",
+		dev_warn(io->dev, "%s unable to claim interrupt %d,"
+			 " running polled\n",
 			 SI_DEVICE_NAME, io->irq);
 		io->irq = 0;
 	} else {
@@ -1342,9 +1347,11 @@ static int try_get_dev_id(struct smi_info *smi_info)
 		/* record completion code */
 		unsigned char cc = *(resp + 2);
 
-		if (cc != IPMI_CC_NO_ERROR &&
-		    ++retry_count <= GET_DEVICE_ID_MAX_RETRY) {
-			dev_warn_ratelimited(smi_info->io.dev,
+		if ((cc == IPMI_DEVICE_IN_FW_UPDATE_ERR
+		    || cc == IPMI_DEVICE_IN_INIT_ERR
+		    || cc == IPMI_NOT_IN_MY_STATE_ERR)
+		    && ++retry_count <= GET_DEVICE_ID_MAX_RETRY) {
+			dev_warn(smi_info->io.dev,
 			    "BMC returned 0x%2.2x, retry get bmc device id\n",
 			    cc);
 			goto retry;
@@ -1606,7 +1613,7 @@ static ssize_t name##_show(struct device *dev,			\
 									\
 	return sysfs_emit(buf, "%u\n", smi_get_stat(smi_info, name));	\
 }									\
-static DEVICE_ATTR_RO(name)
+static DEVICE_ATTR(name, 0444, name##_show, NULL)
 
 static ssize_t type_show(struct device *dev,
 			 struct device_attribute *attr,
@@ -1616,7 +1623,7 @@ static ssize_t type_show(struct device *dev,
 
 	return sysfs_emit(buf, "%s\n", si_to_str[smi_info->io.si_type]);
 }
-static DEVICE_ATTR_RO(type);
+static DEVICE_ATTR(type, 0444, type_show, NULL);
 
 static ssize_t interrupts_enabled_show(struct device *dev,
 				       struct device_attribute *attr,
@@ -1627,7 +1634,8 @@ static ssize_t interrupts_enabled_show(struct device *dev,
 
 	return sysfs_emit(buf, "%d\n", enabled);
 }
-static DEVICE_ATTR_RO(interrupts_enabled);
+static DEVICE_ATTR(interrupts_enabled, 0444,
+		   interrupts_enabled_show, NULL);
 
 IPMI_SI_ATTR(short_timeouts);
 IPMI_SI_ATTR(long_timeouts);
@@ -1658,7 +1666,7 @@ static ssize_t params_show(struct device *dev,
 			smi_info->io.irq,
 			smi_info->io.slave_addr);
 }
-static DEVICE_ATTR_RO(params);
+static DEVICE_ATTR(params, 0444, params_show, NULL);
 
 static struct attribute *ipmi_si_dev_attrs[] = {
 	&dev_attr_type.attr,
@@ -2211,6 +2219,10 @@ static void shutdown_smi(void *send_info)
 	if (smi_info->handlers)
 		smi_info->handlers->cleanup(smi_info->si_sm);
 
+	if (smi_info->io.addr_source_cleanup) {
+		smi_info->io.addr_source_cleanup(&smi_info->io);
+		smi_info->io.addr_source_cleanup = NULL;
+	}
 	if (smi_info->io.io_cleanup) {
 		smi_info->io.io_cleanup(&smi_info->io);
 		smi_info->io.io_cleanup = NULL;
@@ -2236,18 +2248,22 @@ static void cleanup_one_si(struct smi_info *smi_info)
 	kfree(smi_info);
 }
 
-void ipmi_si_remove_by_dev(struct device *dev)
+int ipmi_si_remove_by_dev(struct device *dev)
 {
 	struct smi_info *e;
+	int rv = -ENOENT;
 
 	mutex_lock(&smi_infos_lock);
 	list_for_each_entry(e, &smi_infos, link) {
 		if (e->io.dev == dev) {
 			cleanup_one_si(e);
+			rv = 0;			
 			break;
 		}
 	}
 	mutex_unlock(&smi_infos_lock);
+
+	return rv;
 }
 
 struct device *ipmi_si_remove_by_data(int addr_space, enum si_type si_type,
@@ -2299,4 +2315,5 @@ module_exit(cleanup_ipmi_si);
 MODULE_ALIAS("platform:dmi-ipmi-si");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Corey Minyard <minyard@mvista.com>");
-MODULE_DESCRIPTION("Interface to the IPMI driver for the KCS, SMIC, and BT system interfaces.");
+MODULE_DESCRIPTION("Interface to the IPMI driver for the KCS, SMIC, and BT"
+		   " system interfaces.");
diff --git a/drivers/char/ipmi/ipmi_si_parisc.c b/drivers/char/ipmi/ipmi_si_parisc.c
index 2be2967f6b5f..11c9160275df 100644
--- a/drivers/char/ipmi/ipmi_si_parisc.c
+++ b/drivers/char/ipmi/ipmi_si_parisc.c
@@ -29,9 +29,9 @@ static int __init ipmi_parisc_probe(struct parisc_device *dev)
 	return ipmi_si_add_smi(&io);
 }
 
-static void __exit ipmi_parisc_remove(struct parisc_device *dev)
+static int __exit ipmi_parisc_remove(struct parisc_device *dev)
 {
-	ipmi_si_remove_by_dev(&dev->dev);
+	return ipmi_si_remove_by_dev(&dev->dev);
 }
 
 static const struct parisc_device_id ipmi_parisc_tbl[] __initconst = {
diff --git a/drivers/char/ipmi/ipmi_si_pci.c b/drivers/char/ipmi/ipmi_si_pci.c
index 74fa2055868b..28f8ea6978cb 100644
--- a/drivers/char/ipmi/ipmi_si_pci.c
+++ b/drivers/char/ipmi/ipmi_si_pci.c
@@ -16,11 +16,18 @@ static bool pci_registered;
 static bool si_trypci = true;
 
 module_param_named(trypci, si_trypci, bool, 0);
-MODULE_PARM_DESC(trypci,
-		 "Setting this to zero will disable the default scan of the interfaces identified via pci");
+MODULE_PARM_DESC(trypci, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via pci");
 
 #define PCI_DEVICE_ID_HP_MMC 0x121A
 
++static void ipmi_pci_cleanup(struct si_sm_io *io)
+{
+	struct pci_dev *pdev = io->addr_source_data;
+
+	pci_disable_device(pdev);
+}
+
 static int ipmi_pci_probe_regspacing(struct si_sm_io *io)
 {
 	if (io->si_type == SI_KCS) {
@@ -90,12 +97,15 @@ static int ipmi_pci_probe(struct pci_dev *pdev,
 		return -ENOMEM;
 	}
 
-	rv = pcim_enable_device(pdev);
+	rv = pci_enable_device(pdev);
 	if (rv) {
 		dev_err(&pdev->dev, "couldn't enable PCI device\n");
 		return rv;
 	}
 
+	io.addr_source_cleanup = ipmi_pci_cleanup;
+	io.addr_source_data = pdev;
+
 	if (pci_resource_flags(pdev, 0) & IORESOURCE_IO) {
 		io.addr_space = IPMI_IO_ADDR_SPACE;
 		io.io_setup = ipmi_si_port_setup;
@@ -118,7 +128,11 @@ static int ipmi_pci_probe(struct pci_dev *pdev,
 	dev_info(&pdev->dev, "%pR regsize %d spacing %d irq %d\n",
 		 &pdev->resource[0], io.regsize, io.regspacing, io.irq);
 
-	return ipmi_si_add_smi(&io);
+	rv = ipmi_si_add_smi(&io);
+	if (rv)
+		pci_disable_device(pdev);
+
+	return rv;
 }
 
 static void ipmi_pci_remove(struct pci_dev *pdev)
diff --git a/drivers/char/ipmi/ipmi_si_platform.c b/drivers/char/ipmi/ipmi_si_platform.c
index 505cc978c97a..129b5713f187 100644
--- a/drivers/char/ipmi/ipmi_si_platform.c
+++ b/drivers/char/ipmi/ipmi_si_platform.c
@@ -34,22 +34,23 @@ static bool          si_trydmi = false;
 #endif
 
 module_param_named(tryplatform, si_tryplatform, bool, 0);
-MODULE_PARM_DESC(tryplatform,
-		 "Setting this to zero will disable the default scan of the interfaces identified via platform interfaces besides ACPI, OpenFirmware, and DMI");
+MODULE_PARM_DESC(tryplatform, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via platform"
+		 " interfaces besides ACPI, OpenFirmware, and DMI");
 #ifdef CONFIG_ACPI
 module_param_named(tryacpi, si_tryacpi, bool, 0);
-MODULE_PARM_DESC(tryacpi,
-		 "Setting this to zero will disable the default scan of the interfaces identified via ACPI");
+MODULE_PARM_DESC(tryacpi, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via ACPI");
 #endif
 #ifdef CONFIG_OF
 module_param_named(tryopenfirmware, si_tryopenfirmware, bool, 0);
-MODULE_PARM_DESC(tryopenfirmware,
-		 "Setting this to zero will disable the default scan of the interfaces identified via OpenFirmware");
+MODULE_PARM_DESC(tryopenfirmware, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via OpenFirmware");
 #endif
 #ifdef CONFIG_DMI
 module_param_named(trydmi, si_trydmi, bool, 0);
-MODULE_PARM_DESC(trydmi,
-		 "Setting this to zero will disable the default scan of the interfaces identified via DMI");
+MODULE_PARM_DESC(trydmi, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via DMI");
 #endif
 
 #ifdef CONFIG_ACPI
@@ -84,46 +85,47 @@ static int acpi_gpe_irq_setup(struct si_sm_io *io)
 					  ACPI_GPE_LEVEL_TRIGGERED,
 					  &ipmi_acpi_gpe,
 					  io);
-	if (ACPI_FAILURE(status)) {
+	if (status != AE_OK) {
 		dev_warn(io->dev,
 			 "Unable to claim ACPI GPE %d, running polled\n",
 			 io->irq);
 		io->irq = 0;
 		return -EINVAL;
+	} else {
+		io->irq_cleanup = acpi_gpe_irq_cleanup;
+		ipmi_irq_finish_setup(io);
+		dev_info(io->dev, "Using ACPI GPE %d\n", io->irq);
+		return 0;
 	}
-
-	io->irq_cleanup = acpi_gpe_irq_cleanup;
-	ipmi_irq_finish_setup(io);
-	dev_info(io->dev, "Using ACPI GPE %d\n", io->irq);
-	return 0;
 }
 #endif
 
-static void ipmi_set_addr_data_and_space(struct resource *r, struct si_sm_io *io)
-{
-	if (resource_type(r) == IORESOURCE_IO)
-		io->addr_space = IPMI_IO_ADDR_SPACE;
-	else
-		io->addr_space = IPMI_MEM_ADDR_SPACE;
-	io->addr_data = r->start;
-}
-
 static struct resource *
 ipmi_get_info_from_resources(struct platform_device *pdev,
 			     struct si_sm_io *io)
 {
 	struct resource *res, *res_second;
 
-	res = platform_get_mem_or_io(pdev, 0);
+	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+	if (res) {
+		io->addr_space = IPMI_IO_ADDR_SPACE;
+	} else {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (res)
+			io->addr_space = IPMI_MEM_ADDR_SPACE;
+	}
 	if (!res) {
 		dev_err(&pdev->dev, "no I/O or memory address\n");
 		return NULL;
 	}
-	ipmi_set_addr_data_and_space(res, io);
+	io->addr_data = res->start;
 
 	io->regspacing = DEFAULT_REGSPACING;
-	res_second = platform_get_mem_or_io(pdev, 1);
-	if (res_second && resource_type(res_second) == resource_type(res)) {
+	res_second = platform_get_resource(pdev,
+			       (io->addr_space == IPMI_IO_ADDR_SPACE) ?
+					IORESOURCE_IO : IORESOURCE_MEM,
+			       1);
+	if (res_second) {
 		if (res_second->start > io->addr_data)
 			io->regspacing = res_second->start - io->addr_data;
 	}
@@ -273,7 +275,12 @@ static int of_ipmi_probe(struct platform_device *pdev)
 	io.addr_source	= SI_DEVICETREE;
 	io.irq_setup	= ipmi_std_irq_setup;
 
-	ipmi_set_addr_data_and_space(&resource, &io);
+	if (resource.flags & IORESOURCE_IO)
+		io.addr_space = IPMI_IO_ADDR_SPACE;
+	else
+		io.addr_space = IPMI_MEM_ADDR_SPACE;
+
+	io.addr_data	= resource.start;
 
 	io.regsize	= regsize ? be32_to_cpup(regsize) : DEFAULT_REGSIZE;
 	io.regspacing	= regspacing ? be32_to_cpup(regspacing) : DEFAULT_REGSPACING;
@@ -310,31 +317,32 @@ static int find_slave_address(struct si_sm_io *io, int slave_addr)
 
 static int acpi_ipmi_probe(struct platform_device *pdev)
 {
-	struct device *dev = &pdev->dev;
 	struct si_sm_io io;
 	acpi_handle handle;
 	acpi_status status;
 	unsigned long long tmp;
 	struct resource *res;
+	int rv = -EINVAL;
 
 	if (!si_tryacpi)
 		return -ENODEV;
 
-	handle = ACPI_HANDLE(dev);
+	handle = ACPI_HANDLE(&pdev->dev);
 	if (!handle)
 		return -ENODEV;
 
 	memset(&io, 0, sizeof(io));
 	io.addr_source = SI_ACPI;
-	dev_info(dev, "probing via ACPI\n");
+	dev_info(&pdev->dev, "probing via ACPI\n");
 
 	io.addr_info.acpi_info.acpi_handle = handle;
 
 	/* _IFT tells us the interface type: KCS, BT, etc */
 	status = acpi_evaluate_integer(handle, "_IFT", NULL, &tmp);
 	if (ACPI_FAILURE(status)) {
-		dev_err(dev, "Could not find ACPI IPMI interface type\n");
-		return -EINVAL;
+		dev_err(&pdev->dev,
+			"Could not find ACPI IPMI interface type\n");
+		goto err_free;
 	}
 
 	switch (tmp) {
@@ -348,19 +356,21 @@ static int acpi_ipmi_probe(struct platform_device *pdev)
 		io.si_type = SI_BT;
 		break;
 	case 4: /* SSIF, just ignore */
-		return -ENODEV;
+		rv = -ENODEV;
+		goto err_free;
 	default:
-		dev_info(dev, "unknown IPMI type %lld\n", tmp);
-		return -EINVAL;
+		dev_info(&pdev->dev, "unknown IPMI type %lld\n", tmp);
+		goto err_free;
 	}
 
-	io.dev = dev;
 	io.regsize = DEFAULT_REGSIZE;
 	io.regshift = 0;
 
 	res = ipmi_get_info_from_resources(pdev, &io);
-	if (!res)
-		return -EINVAL;
+	if (!res) {
+		rv = -EINVAL;
+		goto err_free;
+	}
 
 	/* If _GPE exists, use it; otherwise use standard interrupts */
 	status = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);
@@ -378,12 +388,17 @@ static int acpi_ipmi_probe(struct platform_device *pdev)
 
 	io.slave_addr = find_slave_address(&io, io.slave_addr);
 
-	dev_info(dev, "%pR regsize %d spacing %d irq %d\n",
+	io.dev = &pdev->dev;
+
+	dev_info(io.dev, "%pR regsize %d spacing %d irq %d\n",
 		 res, io.regsize, io.regspacing, io.irq);
 
 	request_module("acpi_ipmi");
 
 	return ipmi_si_add_smi(&io);
+
+err_free:
+	return rv;
 }
 
 static const struct acpi_device_id acpi_ipmi_match[] = {
@@ -411,9 +426,7 @@ static int ipmi_probe(struct platform_device *pdev)
 
 static int ipmi_remove(struct platform_device *pdev)
 {
-	ipmi_si_remove_by_dev(&pdev->dev);
-
-	return 0;
+	return ipmi_si_remove_by_dev(&pdev->dev);
 }
 
 static int pdev_match_name(struct device *dev, const void *data)
diff --git a/drivers/char/ipmi/ipmi_ssif.c b/drivers/char/ipmi/ipmi_ssif.c
index e1072809fe31..9534beee8307 100644
--- a/drivers/char/ipmi/ipmi_ssif.c
+++ b/drivers/char/ipmi/ipmi_ssif.c
@@ -510,7 +510,7 @@ static int ipmi_ssif_thread(void *data)
 	return 0;
 }
 
-static void ssif_i2c_send(struct ssif_info *ssif_info,
+static int ssif_i2c_send(struct ssif_info *ssif_info,
 			ssif_i2c_done handler,
 			int read_write, int command,
 			unsigned char *data, unsigned int size)
@@ -522,6 +522,7 @@ static void ssif_i2c_send(struct ssif_info *ssif_info,
 	ssif_info->i2c_data = data;
 	ssif_info->i2c_size = size;
 	complete(&ssif_info->wake_thread);
+	return 0;
 }
 
 
@@ -530,12 +531,22 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 
 static void start_get(struct ssif_info *ssif_info)
 {
+	int rv;
+
 	ssif_info->rtc_us_timer = 0;
 	ssif_info->multi_pos = 0;
 
-	ssif_i2c_send(ssif_info, msg_done_handler, I2C_SMBUS_READ,
-		  SSIF_IPMI_RESPONSE,
-		  ssif_info->recv, I2C_SMBUS_BLOCK_DATA);
+	rv = ssif_i2c_send(ssif_info, msg_done_handler, I2C_SMBUS_READ,
+			  SSIF_IPMI_RESPONSE,
+			  ssif_info->recv, I2C_SMBUS_BLOCK_DATA);
+	if (rv < 0) {
+		/* request failed, just return the error. */
+		if (ssif_info->ssif_debug & SSIF_DEBUG_MSG)
+			dev_dbg(&ssif_info->client->dev,
+				"Error from i2c_non_blocking_op(5)\n");
+
+		msg_done_handler(ssif_info, -EIO, NULL, 0);
+	}
 }
 
 static void retry_timeout(struct timer_list *t)
@@ -609,6 +620,7 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 {
 	struct ipmi_smi_msg *msg;
 	unsigned long oflags, *flags;
+	int rv;
 
 	/*
 	 * We are single-threaded here, so no need for a lock until we
@@ -654,10 +666,17 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 		ssif_info->multi_len = len;
 		ssif_info->multi_pos = 1;
 
-		ssif_i2c_send(ssif_info, msg_done_handler, I2C_SMBUS_READ,
-			 SSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE,
-			 ssif_info->recv, I2C_SMBUS_BLOCK_DATA);
-		return;
+		rv = ssif_i2c_send(ssif_info, msg_done_handler, I2C_SMBUS_READ,
+				  SSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE,
+				  ssif_info->recv, I2C_SMBUS_BLOCK_DATA);
+		if (rv < 0) {
+			if (ssif_info->ssif_debug & SSIF_DEBUG_MSG)
+				dev_dbg(&ssif_info->client->dev,
+					"Error from i2c_non_blocking_op(1)\n");
+
+			result = -EIO;
+		} else
+			return;
 	} else if (ssif_info->multi_pos) {
 		/* Middle of multi-part read.  Start the next transaction. */
 		int i;
@@ -719,12 +738,19 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 
 			ssif_info->multi_pos++;
 
-			ssif_i2c_send(ssif_info, msg_done_handler,
-				  I2C_SMBUS_READ,
-				  SSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE,
-				  ssif_info->recv,
-				  I2C_SMBUS_BLOCK_DATA);
-			return;
+			rv = ssif_i2c_send(ssif_info, msg_done_handler,
+					   I2C_SMBUS_READ,
+					   SSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE,
+					   ssif_info->recv,
+					   I2C_SMBUS_BLOCK_DATA);
+			if (rv < 0) {
+				if (ssif_info->ssif_debug & SSIF_DEBUG_MSG)
+					dev_dbg(&ssif_info->client->dev,
+						"Error from ssif_i2c_send\n");
+
+				result = -EIO;
+			} else
+				return;
 		}
 	}
 
@@ -905,6 +931,8 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 static void msg_written_handler(struct ssif_info *ssif_info, int result,
 				unsigned char *data, unsigned int len)
 {
+	int rv;
+
 	/* We are single-threaded here, so no need for a lock. */
 	if (result < 0) {
 		ssif_info->retries_left--;
@@ -967,9 +995,18 @@ static void msg_written_handler(struct ssif_info *ssif_info, int result,
 			ssif_info->multi_data = NULL;
 		}
 
-		ssif_i2c_send(ssif_info, msg_written_handler,
-			  I2C_SMBUS_WRITE, cmd,
-			  data_to_send, I2C_SMBUS_BLOCK_DATA);
+		rv = ssif_i2c_send(ssif_info, msg_written_handler,
+				   I2C_SMBUS_WRITE, cmd,
+				   data_to_send, I2C_SMBUS_BLOCK_DATA);
+		if (rv < 0) {
+			/* request failed, just return the error. */
+			ssif_inc_stat(ssif_info, send_errors);
+
+			if (ssif_info->ssif_debug & SSIF_DEBUG_MSG)
+				dev_dbg(&ssif_info->client->dev,
+					"Error from i2c_non_blocking_op(3)\n");
+			msg_done_handler(ssif_info, -EIO, NULL, 0);
+		}
 	} else {
 		/* Ready to request the result. */
 		unsigned long oflags, *flags;
@@ -998,6 +1035,7 @@ static void msg_written_handler(struct ssif_info *ssif_info, int result,
 
 static int start_resend(struct ssif_info *ssif_info)
 {
+	int rv;
 	int command;
 
 	ssif_info->got_alert = false;
@@ -1019,9 +1057,12 @@ static int start_resend(struct ssif_info *ssif_info)
 		ssif_info->data[0] = ssif_info->data_len;
 	}
 
-	ssif_i2c_send(ssif_info, msg_written_handler, I2C_SMBUS_WRITE,
-		   command, ssif_info->data, I2C_SMBUS_BLOCK_DATA);
-	return 0;
+	rv = ssif_i2c_send(ssif_info, msg_written_handler, I2C_SMBUS_WRITE,
+			  command, ssif_info->data, I2C_SMBUS_BLOCK_DATA);
+	if (rv && (ssif_info->ssif_debug & SSIF_DEBUG_MSG))
+		dev_dbg(&ssif_info->client->dev,
+			"Error from i2c_non_blocking_op(4)\n");
+	return rv;
 }
 
 static int start_send(struct ssif_info *ssif_info,
diff --git a/drivers/char/ipmi/ipmi_watchdog.c b/drivers/char/ipmi/ipmi_watchdog.c
index 5b4e677929ca..2e5c64f851cb 100644
--- a/drivers/char/ipmi/ipmi_watchdog.c
+++ b/drivers/char/ipmi/ipmi_watchdog.c
@@ -342,17 +342,13 @@ static atomic_t msg_tofree = ATOMIC_INIT(0);
 static DECLARE_COMPLETION(msg_wait);
 static void msg_free_smi(struct ipmi_smi_msg *msg)
 {
-	if (atomic_dec_and_test(&msg_tofree)) {
-		if (!oops_in_progress)
-			complete(&msg_wait);
-	}
+	if (atomic_dec_and_test(&msg_tofree))
+		complete(&msg_wait);
 }
 static void msg_free_recv(struct ipmi_recv_msg *msg)
 {
-	if (atomic_dec_and_test(&msg_tofree)) {
-		if (!oops_in_progress)
-			complete(&msg_wait);
-	}
+	if (atomic_dec_and_test(&msg_tofree))
+		complete(&msg_wait);
 }
 static struct ipmi_smi_msg smi_msg = INIT_IPMI_SMI_MSG(msg_free_smi);
 static struct ipmi_recv_msg recv_msg = INIT_IPMI_RECV_MSG(msg_free_recv);
@@ -371,18 +367,17 @@ static int __ipmi_set_timeout(struct ipmi_smi_msg  *smi_msg,
 	data[0] = 0;
 	WDOG_SET_TIMER_USE(data[0], WDOG_TIMER_USE_SMS_OS);
 
-	if (ipmi_watchdog_state != WDOG_TIMEOUT_NONE) {
-		if ((ipmi_version_major > 1) ||
-		    ((ipmi_version_major == 1) && (ipmi_version_minor >= 5))) {
-			/* This is an IPMI 1.5-only feature. */
-			data[0] |= WDOG_DONT_STOP_ON_SET;
-		} else {
-			/*
-			 * In ipmi 1.0, setting the timer stops the watchdog, we
-			 * need to start it back up again.
-			 */
-			hbnow = 1;
-		}
+	if ((ipmi_version_major > 1)
+	    || ((ipmi_version_major == 1) && (ipmi_version_minor >= 5))) {
+		/* This is an IPMI 1.5-only feature. */
+		data[0] |= WDOG_DONT_STOP_ON_SET;
+	} else if (ipmi_watchdog_state != WDOG_TIMEOUT_NONE) {
+		/*
+		 * In ipmi 1.0, setting the timer stops the watchdog, we
+		 * need to start it back up again.
+		 */
+		hbnow = 1;
+
 	}
 
 	data[1] = 0;
@@ -434,10 +429,8 @@ static int _ipmi_set_timeout(int do_heartbeat)
 	rv = __ipmi_set_timeout(&smi_msg,
 				&recv_msg,
 				&send_heartbeat_now);
-	if (rv) {
-		atomic_set(&msg_tofree, 0);
+	if (rv) 
 		return rv;
-	}
 
 	wait_for_completion(&msg_wait);
 
@@ -497,7 +490,7 @@ static void panic_halt_ipmi_heartbeat(void)
 	msg.cmd = IPMI_WDOG_RESET_TIMER;
 	msg.data = NULL;
 	msg.data_len = 0;
-	atomic_add(2, &panic_done_count);
+	atomic_add(1, &panic_done_count);
 	rv = ipmi_request_supply_msgs(watchdog_user,
 				      (struct ipmi_addr *) &addr,
 				      0,
@@ -507,7 +500,7 @@ static void panic_halt_ipmi_heartbeat(void)
 				      &panic_halt_heartbeat_recv_msg,
 				      1);
 	if (rv)
-		atomic_sub(2, &panic_done_count);
+		atomic_sub(1, &panic_done_count);
 }
 
 static struct ipmi_smi_msg panic_halt_smi_msg =
@@ -529,12 +522,12 @@ static void panic_halt_ipmi_set_timeout(void)
 	/* Wait for the messages to be free. */
 	while (atomic_read(&panic_done_count) != 0)
 		ipmi_poll_interface(watchdog_user);
-	atomic_add(2, &panic_done_count);
+	atomic_add(1, &panic_done_count);
 	rv = __ipmi_set_timeout(&panic_halt_smi_msg,
 				&panic_halt_recv_msg,
 				&send_heartbeat_now);
 	if (rv) {
-		atomic_sub(2, &panic_done_count);
+		atomic_sub(1, &panic_done_count);
 		pr_warn("Unable to extend the watchdog timeout\n");
 	} else {
 		if (send_heartbeat_now)
@@ -578,7 +571,6 @@ static int __ipmi_heartbeat(void)
 				      &recv_msg,
 				      1);
 	if (rv) {
-		atomic_set(&msg_tofree, 0);
 		pr_warn("heartbeat send failure: %d\n", rv);
 		return rv;
 	}
diff --git a/drivers/char/ipmi/kcs_bmc.c b/drivers/char/ipmi/kcs_bmc.c
index 03d02a848f3a..f292e74bd4a5 100644
--- a/drivers/char/ipmi/kcs_bmc.c
+++ b/drivers/char/ipmi/kcs_bmc.c
@@ -1,189 +1,458 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (c) 2015-2018, Intel Corporation.
- * Copyright (c) 2021, IBM Corp.
  */
 
-#include <linux/device.h>
-#include <linux/list.h>
+#define pr_fmt(fmt) "kcs-bmc: " fmt
+
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/ipmi_bmc.h>
 #include <linux/module.h>
-#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
 
 #include "kcs_bmc.h"
 
-/* Implement both the device and client interfaces here */
-#include "kcs_bmc_device.h"
-#include "kcs_bmc_client.h"
+#define DEVICE_NAME "ipmi-kcs"
+
+#define KCS_MSG_BUFSIZ    1000
+
+#define KCS_ZERO_DATA     0
 
-/* Record registered devices and drivers */
-static DEFINE_MUTEX(kcs_bmc_lock);
-static LIST_HEAD(kcs_bmc_devices);
-static LIST_HEAD(kcs_bmc_drivers);
 
-/* Consumer data access */
+/* IPMI 2.0 - Table 9-1, KCS Interface Status Register Bits */
+#define KCS_STATUS_STATE(state) (state << 6)
+#define KCS_STATUS_STATE_MASK   GENMASK(7, 6)
+#define KCS_STATUS_CMD_DAT      BIT(3)
+#define KCS_STATUS_SMS_ATN      BIT(2)
+#define KCS_STATUS_IBF          BIT(1)
+#define KCS_STATUS_OBF          BIT(0)
 
-u8 kcs_bmc_read_data(struct kcs_bmc_device *kcs_bmc)
+/* IPMI 2.0 - Table 9-2, KCS Interface State Bits */
+enum kcs_states {
+	IDLE_STATE  = 0,
+	READ_STATE  = 1,
+	WRITE_STATE = 2,
+	ERROR_STATE = 3,
+};
+
+/* IPMI 2.0 - Table 9-3, KCS Interface Control Codes */
+#define KCS_CMD_GET_STATUS_ABORT  0x60
+#define KCS_CMD_WRITE_START       0x61
+#define KCS_CMD_WRITE_END         0x62
+#define KCS_CMD_READ_BYTE         0x68
+
+static inline u8 read_data(struct kcs_bmc *kcs_bmc)
 {
-	return kcs_bmc->ops->io_inputb(kcs_bmc, kcs_bmc->ioreg.idr);
+	return kcs_bmc->io_inputb(kcs_bmc, kcs_bmc->ioreg.idr);
 }
-EXPORT_SYMBOL(kcs_bmc_read_data);
 
-void kcs_bmc_write_data(struct kcs_bmc_device *kcs_bmc, u8 data)
+static inline void write_data(struct kcs_bmc *kcs_bmc, u8 data)
 {
-	kcs_bmc->ops->io_outputb(kcs_bmc, kcs_bmc->ioreg.odr, data);
+	kcs_bmc->io_outputb(kcs_bmc, kcs_bmc->ioreg.odr, data);
 }
-EXPORT_SYMBOL(kcs_bmc_write_data);
 
-u8 kcs_bmc_read_status(struct kcs_bmc_device *kcs_bmc)
+static inline u8 read_status(struct kcs_bmc *kcs_bmc)
 {
-	return kcs_bmc->ops->io_inputb(kcs_bmc, kcs_bmc->ioreg.str);
+	return kcs_bmc->io_inputb(kcs_bmc, kcs_bmc->ioreg.str);
 }
-EXPORT_SYMBOL(kcs_bmc_read_status);
 
-void kcs_bmc_write_status(struct kcs_bmc_device *kcs_bmc, u8 data)
+static inline void write_status(struct kcs_bmc *kcs_bmc, u8 data)
 {
-	kcs_bmc->ops->io_outputb(kcs_bmc, kcs_bmc->ioreg.str, data);
+	kcs_bmc->io_outputb(kcs_bmc, kcs_bmc->ioreg.str, data);
 }
-EXPORT_SYMBOL(kcs_bmc_write_status);
 
-void kcs_bmc_update_status(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 val)
+static void update_status_bits(struct kcs_bmc *kcs_bmc, u8 mask, u8 val)
 {
-	kcs_bmc->ops->io_updateb(kcs_bmc, kcs_bmc->ioreg.str, mask, val);
+	u8 tmp = read_status(kcs_bmc);
+
+	tmp &= ~mask;
+	tmp |= val & mask;
+
+	write_status(kcs_bmc, tmp);
 }
-EXPORT_SYMBOL(kcs_bmc_update_status);
 
-irqreturn_t kcs_bmc_handle_event(struct kcs_bmc_device *kcs_bmc)
+static inline void set_state(struct kcs_bmc *kcs_bmc, u8 state)
 {
-	struct kcs_bmc_client *client;
-	irqreturn_t rc = IRQ_NONE;
+	update_status_bits(kcs_bmc, KCS_STATUS_STATE_MASK,
+					KCS_STATUS_STATE(state));
+}
 
-	spin_lock(&kcs_bmc->lock);
-	client = kcs_bmc->client;
-	if (client)
-		rc = client->ops->event(client);
-	spin_unlock(&kcs_bmc->lock);
+static void kcs_force_abort(struct kcs_bmc *kcs_bmc)
+{
+	set_state(kcs_bmc, ERROR_STATE);
+	read_data(kcs_bmc);
+	write_data(kcs_bmc, KCS_ZERO_DATA);
 
-	return rc;
+	kcs_bmc->phase = KCS_PHASE_ERROR;
+	kcs_bmc->data_in_avail = false;
+	kcs_bmc->data_in_idx = 0;
 }
-EXPORT_SYMBOL(kcs_bmc_handle_event);
 
-int kcs_bmc_enable_device(struct kcs_bmc_device *kcs_bmc, struct kcs_bmc_client *client)
+static void kcs_bmc_handle_data(struct kcs_bmc *kcs_bmc)
 {
-	int rc;
+	u8 data;
+
+	switch (kcs_bmc->phase) {
+	case KCS_PHASE_WRITE_START:
+		kcs_bmc->phase = KCS_PHASE_WRITE_DATA;
+		fallthrough;
+
+	case KCS_PHASE_WRITE_DATA:
+		if (kcs_bmc->data_in_idx < KCS_MSG_BUFSIZ) {
+			set_state(kcs_bmc, WRITE_STATE);
+			write_data(kcs_bmc, KCS_ZERO_DATA);
+			kcs_bmc->data_in[kcs_bmc->data_in_idx++] =
+						read_data(kcs_bmc);
+		} else {
+			kcs_force_abort(kcs_bmc);
+			kcs_bmc->error = KCS_LENGTH_ERROR;
+		}
+		break;
+
+	case KCS_PHASE_WRITE_END_CMD:
+		if (kcs_bmc->data_in_idx < KCS_MSG_BUFSIZ) {
+			set_state(kcs_bmc, READ_STATE);
+			kcs_bmc->data_in[kcs_bmc->data_in_idx++] =
+						read_data(kcs_bmc);
+			kcs_bmc->phase = KCS_PHASE_WRITE_DONE;
+			kcs_bmc->data_in_avail = true;
+			wake_up_interruptible(&kcs_bmc->queue);
+		} else {
+			kcs_force_abort(kcs_bmc);
+			kcs_bmc->error = KCS_LENGTH_ERROR;
+		}
+		break;
+
+	case KCS_PHASE_READ:
+		if (kcs_bmc->data_out_idx == kcs_bmc->data_out_len)
+			set_state(kcs_bmc, IDLE_STATE);
+
+		data = read_data(kcs_bmc);
+		if (data != KCS_CMD_READ_BYTE) {
+			set_state(kcs_bmc, ERROR_STATE);
+			write_data(kcs_bmc, KCS_ZERO_DATA);
+			break;
+		}
+
+		if (kcs_bmc->data_out_idx == kcs_bmc->data_out_len) {
+			write_data(kcs_bmc, KCS_ZERO_DATA);
+			kcs_bmc->phase = KCS_PHASE_IDLE;
+			break;
+		}
+
+		write_data(kcs_bmc,
+			kcs_bmc->data_out[kcs_bmc->data_out_idx++]);
+		break;
+
+	case KCS_PHASE_ABORT_ERROR1:
+		set_state(kcs_bmc, READ_STATE);
+		read_data(kcs_bmc);
+		write_data(kcs_bmc, kcs_bmc->error);
+		kcs_bmc->phase = KCS_PHASE_ABORT_ERROR2;
+		break;
+
+	case KCS_PHASE_ABORT_ERROR2:
+		set_state(kcs_bmc, IDLE_STATE);
+		read_data(kcs_bmc);
+		write_data(kcs_bmc, KCS_ZERO_DATA);
+		kcs_bmc->phase = KCS_PHASE_IDLE;
+		break;
+
+	default:
+		kcs_force_abort(kcs_bmc);
+		break;
+	}
+}
 
-	spin_lock_irq(&kcs_bmc->lock);
-	if (kcs_bmc->client) {
-		rc = -EBUSY;
-	} else {
-		u8 mask = KCS_BMC_EVENT_TYPE_IBF;
+static void kcs_bmc_handle_cmd(struct kcs_bmc *kcs_bmc)
+{
+	u8 cmd;
+
+	set_state(kcs_bmc, WRITE_STATE);
+	write_data(kcs_bmc, KCS_ZERO_DATA);
+
+	cmd = read_data(kcs_bmc);
+	switch (cmd) {
+	case KCS_CMD_WRITE_START:
+		kcs_bmc->phase = KCS_PHASE_WRITE_START;
+		kcs_bmc->error = KCS_NO_ERROR;
+		kcs_bmc->data_in_avail = false;
+		kcs_bmc->data_in_idx = 0;
+		break;
+
+	case KCS_CMD_WRITE_END:
+		if (kcs_bmc->phase != KCS_PHASE_WRITE_DATA) {
+			kcs_force_abort(kcs_bmc);
+			break;
+		}
+
+		kcs_bmc->phase = KCS_PHASE_WRITE_END_CMD;
+		break;
+
+	case KCS_CMD_GET_STATUS_ABORT:
+		if (kcs_bmc->error == KCS_NO_ERROR)
+			kcs_bmc->error = KCS_ABORTED_BY_COMMAND;
+
+		kcs_bmc->phase = KCS_PHASE_ABORT_ERROR1;
+		kcs_bmc->data_in_avail = false;
+		kcs_bmc->data_in_idx = 0;
+		break;
+
+	default:
+		kcs_force_abort(kcs_bmc);
+		kcs_bmc->error = KCS_ILLEGAL_CONTROL_CODE;
+		break;
+	}
+}
 
-		kcs_bmc->client = client;
-		kcs_bmc_update_event_mask(kcs_bmc, mask, mask);
-		rc = 0;
+int kcs_bmc_handle_event(struct kcs_bmc *kcs_bmc)
+{
+	unsigned long flags;
+	int ret = -ENODATA;
+	u8 status;
+
+	spin_lock_irqsave(&kcs_bmc->lock, flags);
+
+	status = read_status(kcs_bmc);
+	if (status & KCS_STATUS_IBF) {
+		if (!kcs_bmc->running)
+			kcs_force_abort(kcs_bmc);
+		else if (status & KCS_STATUS_CMD_DAT)
+			kcs_bmc_handle_cmd(kcs_bmc);
+		else
+			kcs_bmc_handle_data(kcs_bmc);
+
+		ret = 0;
 	}
-	spin_unlock_irq(&kcs_bmc->lock);
 
-	return rc;
+	spin_unlock_irqrestore(&kcs_bmc->lock, flags);
+
+	return ret;
 }
-EXPORT_SYMBOL(kcs_bmc_enable_device);
+EXPORT_SYMBOL(kcs_bmc_handle_event);
 
-void kcs_bmc_disable_device(struct kcs_bmc_device *kcs_bmc, struct kcs_bmc_client *client)
+static inline struct kcs_bmc *to_kcs_bmc(struct file *filp)
 {
+	return container_of(filp->private_data, struct kcs_bmc, miscdev);
+}
+
+static int kcs_bmc_open(struct inode *inode, struct file *filp)
+{
+	struct kcs_bmc *kcs_bmc = to_kcs_bmc(filp);
+	int ret = 0;
+
 	spin_lock_irq(&kcs_bmc->lock);
-	if (client == kcs_bmc->client) {
-		u8 mask = KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE;
+	if (!kcs_bmc->running)
+		kcs_bmc->running = 1;
+	else
+		ret = -EBUSY;
+	spin_unlock_irq(&kcs_bmc->lock);
 
-		kcs_bmc_update_event_mask(kcs_bmc, mask, 0);
-		kcs_bmc->client = NULL;
-	}
+	return ret;
+}
+
+static __poll_t kcs_bmc_poll(struct file *filp, poll_table *wait)
+{
+	struct kcs_bmc *kcs_bmc = to_kcs_bmc(filp);
+	__poll_t mask = 0;
+
+	poll_wait(filp, &kcs_bmc->queue, wait);
+
+	spin_lock_irq(&kcs_bmc->lock);
+	if (kcs_bmc->data_in_avail)
+		mask |= EPOLLIN;
 	spin_unlock_irq(&kcs_bmc->lock);
+
+	return mask;
 }
-EXPORT_SYMBOL(kcs_bmc_disable_device);
 
-int kcs_bmc_add_device(struct kcs_bmc_device *kcs_bmc)
+static ssize_t kcs_bmc_read(struct file *filp, char __user *buf,
+			    size_t count, loff_t *ppos)
 {
-	struct kcs_bmc_driver *drv;
-	int error = 0;
-	int rc;
+	struct kcs_bmc *kcs_bmc = to_kcs_bmc(filp);
+	bool data_avail;
+	size_t data_len;
+	ssize_t ret;
 
-	spin_lock_init(&kcs_bmc->lock);
-	kcs_bmc->client = NULL;
-
-	mutex_lock(&kcs_bmc_lock);
-	list_add(&kcs_bmc->entry, &kcs_bmc_devices);
-	list_for_each_entry(drv, &kcs_bmc_drivers, entry) {
-		rc = drv->ops->add_device(kcs_bmc);
-		if (!rc)
-			continue;
-
-		dev_err(kcs_bmc->dev, "Failed to add chardev for KCS channel %d: %d",
-			kcs_bmc->channel, rc);
-		error = rc;
+	if (!(filp->f_flags & O_NONBLOCK))
+		wait_event_interruptible(kcs_bmc->queue,
+					 kcs_bmc->data_in_avail);
+
+	mutex_lock(&kcs_bmc->mutex);
+
+	spin_lock_irq(&kcs_bmc->lock);
+	data_avail = kcs_bmc->data_in_avail;
+	if (data_avail) {
+		data_len = kcs_bmc->data_in_idx;
+		memcpy(kcs_bmc->kbuffer, kcs_bmc->data_in, data_len);
+	}
+	spin_unlock_irq(&kcs_bmc->lock);
+
+	if (!data_avail) {
+		ret = -EAGAIN;
+		goto out_unlock;
 	}
-	mutex_unlock(&kcs_bmc_lock);
 
-	return error;
+	if (count < data_len) {
+		pr_err("channel=%u with too large data : %zu\n",
+			kcs_bmc->channel, data_len);
+
+		spin_lock_irq(&kcs_bmc->lock);
+		kcs_force_abort(kcs_bmc);
+		spin_unlock_irq(&kcs_bmc->lock);
+
+		ret = -EOVERFLOW;
+		goto out_unlock;
+	}
+
+	if (copy_to_user(buf, kcs_bmc->kbuffer, data_len)) {
+		ret = -EFAULT;
+		goto out_unlock;
+	}
+
+	ret = data_len;
+
+	spin_lock_irq(&kcs_bmc->lock);
+	if (kcs_bmc->phase == KCS_PHASE_WRITE_DONE) {
+		kcs_bmc->phase = KCS_PHASE_WAIT_READ;
+		kcs_bmc->data_in_avail = false;
+		kcs_bmc->data_in_idx = 0;
+	} else {
+		ret = -EAGAIN;
+	}
+	spin_unlock_irq(&kcs_bmc->lock);
+
+out_unlock:
+	mutex_unlock(&kcs_bmc->mutex);
+
+	return ret;
 }
-EXPORT_SYMBOL(kcs_bmc_add_device);
 
-void kcs_bmc_remove_device(struct kcs_bmc_device *kcs_bmc)
+static ssize_t kcs_bmc_write(struct file *filp, const char __user *buf,
+			     size_t count, loff_t *ppos)
 {
-	struct kcs_bmc_driver *drv;
-	int rc;
+	struct kcs_bmc *kcs_bmc = to_kcs_bmc(filp);
+	ssize_t ret;
+
+	/* a minimum response size '3' : netfn + cmd + ccode */
+	if (count < 3 || count > KCS_MSG_BUFSIZ)
+		return -EINVAL;
+
+	mutex_lock(&kcs_bmc->mutex);
+
+	if (copy_from_user(kcs_bmc->kbuffer, buf, count)) {
+		ret = -EFAULT;
+		goto out_unlock;
+	}
 
-	mutex_lock(&kcs_bmc_lock);
-	list_del(&kcs_bmc->entry);
-	list_for_each_entry(drv, &kcs_bmc_drivers, entry) {
-		rc = drv->ops->remove_device(kcs_bmc);
-		if (rc)
-			dev_err(kcs_bmc->dev, "Failed to remove chardev for KCS channel %d: %d",
-				kcs_bmc->channel, rc);
+	spin_lock_irq(&kcs_bmc->lock);
+	if (kcs_bmc->phase == KCS_PHASE_WAIT_READ) {
+		kcs_bmc->phase = KCS_PHASE_READ;
+		kcs_bmc->data_out_idx = 1;
+		kcs_bmc->data_out_len = count;
+		memcpy(kcs_bmc->data_out, kcs_bmc->kbuffer, count);
+		write_data(kcs_bmc, kcs_bmc->data_out[0]);
+		ret = count;
+	} else {
+		ret = -EINVAL;
 	}
-	mutex_unlock(&kcs_bmc_lock);
+	spin_unlock_irq(&kcs_bmc->lock);
+
+out_unlock:
+	mutex_unlock(&kcs_bmc->mutex);
+
+	return ret;
 }
-EXPORT_SYMBOL(kcs_bmc_remove_device);
 
-void kcs_bmc_register_driver(struct kcs_bmc_driver *drv)
+static long kcs_bmc_ioctl(struct file *filp, unsigned int cmd,
+			  unsigned long arg)
 {
-	struct kcs_bmc_device *kcs_bmc;
-	int rc;
+	struct kcs_bmc *kcs_bmc = to_kcs_bmc(filp);
+	long ret = 0;
+
+	spin_lock_irq(&kcs_bmc->lock);
+
+	switch (cmd) {
+	case IPMI_BMC_IOCTL_SET_SMS_ATN:
+		update_status_bits(kcs_bmc, KCS_STATUS_SMS_ATN,
+				   KCS_STATUS_SMS_ATN);
+		break;
+
+	case IPMI_BMC_IOCTL_CLEAR_SMS_ATN:
+		update_status_bits(kcs_bmc, KCS_STATUS_SMS_ATN,
+				   0);
+		break;
 
-	mutex_lock(&kcs_bmc_lock);
-	list_add(&drv->entry, &kcs_bmc_drivers);
-	list_for_each_entry(kcs_bmc, &kcs_bmc_devices, entry) {
-		rc = drv->ops->add_device(kcs_bmc);
-		if (rc)
-			dev_err(kcs_bmc->dev, "Failed to add driver for KCS channel %d: %d",
-				kcs_bmc->channel, rc);
+	case IPMI_BMC_IOCTL_FORCE_ABORT:
+		kcs_force_abort(kcs_bmc);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
 	}
-	mutex_unlock(&kcs_bmc_lock);
+
+	spin_unlock_irq(&kcs_bmc->lock);
+
+	return ret;
 }
-EXPORT_SYMBOL(kcs_bmc_register_driver);
 
-void kcs_bmc_unregister_driver(struct kcs_bmc_driver *drv)
+static int kcs_bmc_release(struct inode *inode, struct file *filp)
 {
-	struct kcs_bmc_device *kcs_bmc;
-	int rc;
+	struct kcs_bmc *kcs_bmc = to_kcs_bmc(filp);
 
-	mutex_lock(&kcs_bmc_lock);
-	list_del(&drv->entry);
-	list_for_each_entry(kcs_bmc, &kcs_bmc_devices, entry) {
-		rc = drv->ops->remove_device(kcs_bmc);
-		if (rc)
-			dev_err(kcs_bmc->dev, "Failed to remove driver for KCS channel %d: %d",
-				kcs_bmc->channel, rc);
-	}
-	mutex_unlock(&kcs_bmc_lock);
+	spin_lock_irq(&kcs_bmc->lock);
+	kcs_bmc->running = 0;
+	kcs_force_abort(kcs_bmc);
+	spin_unlock_irq(&kcs_bmc->lock);
+
+	return 0;
 }
-EXPORT_SYMBOL(kcs_bmc_unregister_driver);
 
-void kcs_bmc_update_event_mask(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 events)
+static const struct file_operations kcs_bmc_fops = {
+	.owner          = THIS_MODULE,
+	.open           = kcs_bmc_open,
+	.read           = kcs_bmc_read,
+	.write          = kcs_bmc_write,
+	.release        = kcs_bmc_release,
+	.poll           = kcs_bmc_poll,
+	.unlocked_ioctl = kcs_bmc_ioctl,
+};
+
+struct kcs_bmc *kcs_bmc_alloc(struct device *dev, int sizeof_priv, u32 channel)
 {
-	kcs_bmc->ops->irq_mask_update(kcs_bmc, mask, events);
+	struct kcs_bmc *kcs_bmc;
+
+	kcs_bmc = devm_kzalloc(dev, sizeof(*kcs_bmc) + sizeof_priv, GFP_KERNEL);
+	if (!kcs_bmc)
+		return NULL;
+
+	spin_lock_init(&kcs_bmc->lock);
+	kcs_bmc->channel = channel;
+
+	mutex_init(&kcs_bmc->mutex);
+	init_waitqueue_head(&kcs_bmc->queue);
+
+	kcs_bmc->data_in = devm_kmalloc(dev, KCS_MSG_BUFSIZ, GFP_KERNEL);
+	kcs_bmc->data_out = devm_kmalloc(dev, KCS_MSG_BUFSIZ, GFP_KERNEL);
+	kcs_bmc->kbuffer = devm_kmalloc(dev, KCS_MSG_BUFSIZ, GFP_KERNEL);
+
+	kcs_bmc->miscdev.minor = MISC_DYNAMIC_MINOR;
+	kcs_bmc->miscdev.name = devm_kasprintf(dev, GFP_KERNEL, "%s%u",
+					       DEVICE_NAME, channel);
+	if (!kcs_bmc->data_in || !kcs_bmc->data_out || !kcs_bmc->kbuffer ||
+	    !kcs_bmc->miscdev.name)
+		return NULL;
+	kcs_bmc->miscdev.fops = &kcs_bmc_fops;
+
+	return kcs_bmc;
 }
-EXPORT_SYMBOL(kcs_bmc_update_event_mask);
+EXPORT_SYMBOL(kcs_bmc_alloc);
 
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Haiyue Wang <haiyue.wang@linux.intel.com>");
-MODULE_AUTHOR("Andrew Jeffery <andrew@aj.id.au>");
 MODULE_DESCRIPTION("KCS BMC to handle the IPMI request from system software");
diff --git a/drivers/char/ipmi/kcs_bmc.h b/drivers/char/ipmi/kcs_bmc.h
index fa408b802c79..d34240dcdee6 100644
--- a/drivers/char/ipmi/kcs_bmc.h
+++ b/drivers/char/ipmi/kcs_bmc.h
@@ -6,14 +6,54 @@
 #ifndef __KCS_BMC_H__
 #define __KCS_BMC_H__
 
-#include <linux/list.h>
+#include <linux/miscdevice.h>
 
-#define KCS_BMC_EVENT_TYPE_OBE	BIT(0)
-#define KCS_BMC_EVENT_TYPE_IBF	BIT(1)
+/* Different phases of the KCS BMC module.
+ *  KCS_PHASE_IDLE:
+ *            BMC should not be expecting nor sending any data.
+ *  KCS_PHASE_WRITE_START:
+ *            BMC is receiving a WRITE_START command from system software.
+ *  KCS_PHASE_WRITE_DATA:
+ *            BMC is receiving a data byte from system software.
+ *  KCS_PHASE_WRITE_END_CMD:
+ *            BMC is waiting a last data byte from system software.
+ *  KCS_PHASE_WRITE_DONE:
+ *            BMC has received the whole request from system software.
+ *  KCS_PHASE_WAIT_READ:
+ *            BMC is waiting the response from the upper IPMI service.
+ *  KCS_PHASE_READ:
+ *            BMC is transferring the response to system software.
+ *  KCS_PHASE_ABORT_ERROR1:
+ *            BMC is waiting error status request from system software.
+ *  KCS_PHASE_ABORT_ERROR2:
+ *            BMC is waiting for idle status afer error from system software.
+ *  KCS_PHASE_ERROR:
+ *            BMC has detected a protocol violation at the interface level.
+ */
+enum kcs_phases {
+	KCS_PHASE_IDLE,
+
+	KCS_PHASE_WRITE_START,
+	KCS_PHASE_WRITE_DATA,
+	KCS_PHASE_WRITE_END_CMD,
+	KCS_PHASE_WRITE_DONE,
 
-#define KCS_BMC_STR_OBF		BIT(0)
-#define KCS_BMC_STR_IBF		BIT(1)
-#define KCS_BMC_STR_CMD_DAT	BIT(3)
+	KCS_PHASE_WAIT_READ,
+	KCS_PHASE_READ,
+
+KCS_PHASE_ABORT_ERROR1,
+	KCS_PHASE_ABORT_ERROR2,
+	KCS_PHASE_ERROR
+};
+
+/* IPMI 2.0 - Table 9-4, KCS Interface Status Codes */
+enum kcs_errors {
+	KCS_NO_ERROR                = 0x00,
+	KCS_ABORTED_BY_COMMAND      = 0x01,
+	KCS_ILLEGAL_CONTROL_CODE    = 0x02,
+	KCS_LENGTH_ERROR            = 0x06,
+	KCS_UNSPECIFIED_ERROR       = 0xFF
+};
 
 /* IPMI 2.0 - 9.5, KCS Interface Registers
  * @idr: Input Data Register
@@ -26,21 +66,43 @@ struct kcs_ioreg {
 	u32 str;
 };
 
-struct kcs_bmc_device_ops;
-struct kcs_bmc_client;
-
-struct kcs_bmc_device {
-	struct list_head entry;
+struct kcs_bmc {
+	spinlock_t lock;
 
-	struct device *dev;
 	u32 channel;
+	int running;
 
+	/* Setup by BMC KCS controller driver */
 	struct kcs_ioreg ioreg;
+	u8 (*io_inputb)(struct kcs_bmc *kcs_bmc, u32 reg);
+	void (*io_outputb)(struct kcs_bmc *kcs_bmc, u32 reg, u8 b);
 
-	const struct kcs_bmc_device_ops *ops;
+	enum kcs_phases phase;
+	enum kcs_errors error;
 
-	spinlock_t lock;
-	struct kcs_bmc_client *client;
+	wait_queue_head_t queue;
+	bool data_in_avail;
+	int  data_in_idx;
+	u8  *data_in;
+
+	int  data_out_idx;
+	int  data_out_len;
+	u8  *data_out;
+
+	struct mutex mutex;
+	u8 *kbuffer;
+
+	struct miscdevice miscdev;
+
+	unsigned long priv[];
 };
 
+static inline void *kcs_bmc_priv(struct kcs_bmc *kcs_bmc)
+{
+	return kcs_bmc->priv;
+}
+
+int kcs_bmc_handle_event(struct kcs_bmc *kcs_bmc);
+struct kcs_bmc *kcs_bmc_alloc(struct device *dev, int sizeof_priv,
+					u32 channel);
 #endif /* __KCS_BMC_H__ */
diff --git a/drivers/char/ipmi/kcs_bmc_aspeed.c b/drivers/char/ipmi/kcs_bmc_aspeed.c
index 2dea8cd5a09a..787f3252a8d1 100644
--- a/drivers/char/ipmi/kcs_bmc_aspeed.c
+++ b/drivers/char/ipmi/kcs_bmc_aspeed.c
@@ -9,12 +9,10 @@
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
-#include <linux/irq.h>
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
-#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/poll.h>
 #include <linux/regmap.h>
@@ -22,53 +20,24 @@
 #include <linux/slab.h>
 #include <linux/timer.h>
 
-#include "kcs_bmc_device.h"
+#include "kcs_bmc.h"
 
 
 #define DEVICE_NAME     "ast-kcs-bmc"
 
 #define KCS_CHANNEL_MAX     4
 
-/*
- * Field class descriptions
- *
- * LPCyE	Enable LPC channel y
- * IBFIEy	Input Buffer Full IRQ Enable for LPC channel y
- * IRQxEy	Assert SerIRQ x for LPC channel y (Deprecated, use IDyIRQX, IRQXEy)
- * IDyIRQX	Use the specified 4-bit SerIRQ for LPC channel y
- * SELyIRQX	SerIRQ polarity for LPC channel y (low: 0, high: 1)
- * IRQXEy	Assert the SerIRQ specified in IDyIRQX for LPC channel y
- */
-
-#define LPC_TYIRQX_LOW       0b00
-#define LPC_TYIRQX_HIGH      0b01
-#define LPC_TYIRQX_RSVD      0b10
-#define LPC_TYIRQX_RISING    0b11
-
 #define LPC_HICR0            0x000
 #define     LPC_HICR0_LPC3E          BIT(7)
 #define     LPC_HICR0_LPC2E          BIT(6)
 #define     LPC_HICR0_LPC1E          BIT(5)
 #define LPC_HICR2            0x008
-#define     LPC_HICR2_IBFIE3         BIT(3)
-#define     LPC_HICR2_IBFIE2         BIT(2)
-#define     LPC_HICR2_IBFIE1         BIT(1)
+#define     LPC_HICR2_IBFIF3         BIT(3)
+#define     LPC_HICR2_IBFIF2         BIT(2)
+#define     LPC_HICR2_IBFIF1         BIT(1)
 #define LPC_HICR4            0x010
 #define     LPC_HICR4_LADR12AS       BIT(7)
 #define     LPC_HICR4_KCSENBL        BIT(2)
-#define LPC_SIRQCR0	     0x070
-/* IRQ{12,1}E1 are deprecated as of AST2600 A3 but necessary for prior chips */
-#define     LPC_SIRQCR0_IRQ12E1	     BIT(1)
-#define     LPC_SIRQCR0_IRQ1E1	     BIT(0)
-#define LPC_HICR5	     0x080
-#define     LPC_HICR5_ID3IRQX_MASK   GENMASK(23, 20)
-#define     LPC_HICR5_ID3IRQX_SHIFT  20
-#define     LPC_HICR5_ID2IRQX_MASK   GENMASK(19, 16)
-#define     LPC_HICR5_ID2IRQX_SHIFT  16
-#define     LPC_HICR5_SEL3IRQX       BIT(15)
-#define     LPC_HICR5_IRQXE3         BIT(14)
-#define     LPC_HICR5_SEL2IRQX       BIT(13)
-#define     LPC_HICR5_IRQXE2         BIT(12)
 #define LPC_LADR3H           0x014
 #define LPC_LADR3L           0x018
 #define LPC_LADR12H          0x01C
@@ -83,59 +52,21 @@
 #define LPC_STR2             0x040
 #define LPC_STR3             0x044
 #define LPC_HICRB            0x100
-#define     LPC_HICRB_EN16LADR2      BIT(5)
-#define     LPC_HICRB_EN16LADR1      BIT(4)
-#define     LPC_HICRB_IBFIE4         BIT(1)
+#define     LPC_HICRB_IBFIF4         BIT(1)
 #define     LPC_HICRB_LPC4E          BIT(0)
-#define LPC_HICRC            0x104
-#define     LPC_HICRC_ID4IRQX_MASK   GENMASK(7, 4)
-#define     LPC_HICRC_ID4IRQX_SHIFT  4
-#define     LPC_HICRC_TY4IRQX_MASK   GENMASK(3, 2)
-#define     LPC_HICRC_TY4IRQX_SHIFT  2
-#define     LPC_HICRC_OBF4_AUTO_CLR  BIT(1)
-#define     LPC_HICRC_IRQXE4         BIT(0)
 #define LPC_LADR4            0x110
 #define LPC_IDR4             0x114
 #define LPC_ODR4             0x118
 #define LPC_STR4             0x11C
-#define LPC_LSADR12	     0x120
-#define     LPC_LSADR12_LSADR2_MASK  GENMASK(31, 16)
-#define     LPC_LSADR12_LSADR2_SHIFT 16
-#define     LPC_LSADR12_LSADR1_MASK  GENMASK(15, 0)
-#define     LPC_LSADR12_LSADR1_SHIFT 0
-
-#define OBE_POLL_PERIOD	     (HZ / 2)
 
-enum aspeed_kcs_irq_mode {
-	aspeed_kcs_irq_none,
-	aspeed_kcs_irq_serirq,
-};
 
 struct aspeed_kcs_bmc {
-	struct kcs_bmc_device kcs_bmc;
-
 	struct regmap *map;
-
-	struct {
-		enum aspeed_kcs_irq_mode mode;
-		int id;
-	} upstream_irq;
-
-	struct {
-		spinlock_t lock;
-		bool remove;
-		struct timer_list timer;
-	} obe;
 };
 
-static inline struct aspeed_kcs_bmc *to_aspeed_kcs_bmc(struct kcs_bmc_device *kcs_bmc)
-{
-	return container_of(kcs_bmc, struct aspeed_kcs_bmc, kcs_bmc);
-}
-
-static u8 aspeed_kcs_inb(struct kcs_bmc_device *kcs_bmc, u32 reg)
+static u8 aspeed_kcs_inb(struct kcs_bmc *kcs_bmc, u32 reg)
 {
-	struct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);
+	struct aspeed_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 	u32 val = 0;
 	int rc;
 
@@ -145,66 +76,16 @@ static u8 aspeed_kcs_inb(struct kcs_bmc_device *kcs_bmc, u32 reg)
 	return rc == 0 ? (u8) val : 0;
 }
 
-static void aspeed_kcs_outb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 data)
+static void aspeed_kcs_outb(struct kcs_bmc *kcs_bmc, u32 reg, u8 data)
 {
-	struct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);
+	struct aspeed_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 	int rc;
 
 	rc = regmap_write(priv->map, reg, data);
 	WARN(rc != 0, "regmap_write() failed: %d\n", rc);
-
-	/* Trigger the upstream IRQ on ODR writes, if enabled */
-
-	switch (reg) {
-	case LPC_ODR1:
-	case LPC_ODR2:
-	case LPC_ODR3:
-	case LPC_ODR4:
-		break;
-	default:
-		return;
-	}
-
-	if (priv->upstream_irq.mode != aspeed_kcs_irq_serirq)
-		return;
-
-	switch (kcs_bmc->channel) {
-	case 1:
-		switch (priv->upstream_irq.id) {
-		case 12:
-			regmap_update_bits(priv->map, LPC_SIRQCR0, LPC_SIRQCR0_IRQ12E1,
-					   LPC_SIRQCR0_IRQ12E1);
-			break;
-		case 1:
-			regmap_update_bits(priv->map, LPC_SIRQCR0, LPC_SIRQCR0_IRQ1E1,
-					   LPC_SIRQCR0_IRQ1E1);
-			break;
-		default:
-			break;
-		}
-		break;
-	case 2:
-		regmap_update_bits(priv->map, LPC_HICR5, LPC_HICR5_IRQXE2, LPC_HICR5_IRQXE2);
-		break;
-	case 3:
-		regmap_update_bits(priv->map, LPC_HICR5, LPC_HICR5_IRQXE3, LPC_HICR5_IRQXE3);
-		break;
-	case 4:
-		regmap_update_bits(priv->map, LPC_HICRC, LPC_HICRC_IRQXE4, LPC_HICRC_IRQXE4);
-		break;
-	default:
-		break;
-	}
 }
 
-static void aspeed_kcs_updateb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 mask, u8 val)
-{
-	struct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);
-	int rc;
 
-	rc = regmap_update_bits(priv->map, reg, mask, val);
-	WARN(rc != 0, "regmap_update_bits() failed: %d\n", rc);
-}
 
 /*
  * We note D for Data, and C for Cmd/Status, default rules are
@@ -226,255 +107,117 @@ static void aspeed_kcs_updateb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 mask,
  *   B. KCS3 (D/C: XX2/XX3h)
  *      D/C: CA2h/CA3h
  */
-static int aspeed_kcs_set_address(struct kcs_bmc_device *kcs_bmc, u32 addrs[2], int nr_addrs)
+static void aspeed_kcs_set_address(struct kcs_bmc *kcs_bmc, u16 addr)
 {
-	struct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);
-
-	if (WARN_ON(nr_addrs < 1 || nr_addrs > 2))
-		return -EINVAL;
+	struct aspeed_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 
-	switch (priv->kcs_bmc.channel) {
+	switch (kcs_bmc->channel) {
 	case 1:
-		regmap_update_bits(priv->map, LPC_HICR4, LPC_HICR4_LADR12AS, 0);
-		regmap_write(priv->map, LPC_LADR12H, addrs[0] >> 8);
-		regmap_write(priv->map, LPC_LADR12L, addrs[0] & 0xFF);
-		if (nr_addrs == 2) {
-			regmap_update_bits(priv->map, LPC_LSADR12, LPC_LSADR12_LSADR1_MASK,
-					   addrs[1] << LPC_LSADR12_LSADR1_SHIFT);
-
-			regmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_EN16LADR1,
-					   LPC_HICRB_EN16LADR1);
-		}
+		regmap_update_bits(priv->map, LPC_HICR4,
+				LPC_HICR4_LADR12AS, 0);
+		regmap_write(priv->map, LPC_LADR12H, addr >> 8);
+		regmap_write(priv->map, LPC_LADR12L, addr & 0xFF);
 		break;
 
 	case 2:
-		regmap_update_bits(priv->map, LPC_HICR4, LPC_HICR4_LADR12AS, LPC_HICR4_LADR12AS);
-		regmap_write(priv->map, LPC_LADR12H, addrs[0] >> 8);
-		regmap_write(priv->map, LPC_LADR12L, addrs[0] & 0xFF);
-		if (nr_addrs == 2) {
-			regmap_update_bits(priv->map, LPC_LSADR12, LPC_LSADR12_LSADR2_MASK,
-					   addrs[1] << LPC_LSADR12_LSADR2_SHIFT);
-
-			regmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_EN16LADR2,
-					   LPC_HICRB_EN16LADR2);
-		}
+		regmap_update_bits(priv->map, LPC_HICR4,
+				LPC_HICR4_LADR12AS, LPC_HICR4_LADR12AS);
+		regmap_write(priv->map, LPC_LADR12H, addr >> 8);
+		regmap_write(priv->map, LPC_LADR12L, addr & 0xFF);
 		break;
 
 	case 3:
-		if (nr_addrs == 2) {
-			dev_err(priv->kcs_bmc.dev,
-				"Channel 3 only supports inferred status IO address\n");
-			return -EINVAL;
-		}
-
-		regmap_write(priv->map, LPC_LADR3H, addrs[0] >> 8);
-		regmap_write(priv->map, LPC_LADR3L, addrs[0] & 0xFF);
+		regmap_write(priv->map, LPC_LADR3H, addr >> 8);
+		regmap_write(priv->map, LPC_LADR3L, addr & 0xFF);
 		break;
 
 	case 4:
-		if (nr_addrs == 1)
-			regmap_write(priv->map, LPC_LADR4, ((addrs[0] + 1) << 16) | addrs[0]);
-		else
-			regmap_write(priv->map, LPC_LADR4, (addrs[1] << 16) | addrs[0]);
-
+		regmap_write(priv->map, LPC_LADR4, ((addr + 1) << 16) |
+			addr);
 		break;
 
 	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static inline int aspeed_kcs_map_serirq_type(u32 dt_type)
-{
-	switch (dt_type) {
-	case IRQ_TYPE_EDGE_RISING:
-		return LPC_TYIRQX_RISING;
-	case IRQ_TYPE_LEVEL_HIGH:
-		return LPC_TYIRQX_HIGH;
-	case IRQ_TYPE_LEVEL_LOW:
-		return LPC_TYIRQX_LOW;
-	default:
-		return -EINVAL;
+		break;
 	}
 }
 
-static int aspeed_kcs_config_upstream_irq(struct aspeed_kcs_bmc *priv, u32 id, u32 dt_type)
+static void aspeed_kcs_enable_channel(struct kcs_bmc *kcs_bmc, bool enable)
 {
-	unsigned int mask, val, hw_type;
-	int ret;
+	struct aspeed_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 
-	if (id > 15)
-		return -EINVAL;
-
-	ret = aspeed_kcs_map_serirq_type(dt_type);
-	if (ret < 0)
-		return ret;
-	hw_type = ret;
-
-	priv->upstream_irq.mode = aspeed_kcs_irq_serirq;
-	priv->upstream_irq.id = id;
-
-	switch (priv->kcs_bmc.channel) {
+	switch (kcs_bmc->channel) {
 	case 1:
-		/* Needs IRQxE1 rather than (ID1IRQX, SEL1IRQX, IRQXE1) before AST2600 A3 */
+		if (enable) {
+			regmap_update_bits(priv->map, LPC_HICR2,
+					LPC_HICR2_IBFIF1, LPC_HICR2_IBFIF1);
+			regmap_update_bits(priv->map, LPC_HICR0,
+					LPC_HICR0_LPC1E, LPC_HICR0_LPC1E);
+		} else {
+			regmap_update_bits(priv->map, LPC_HICR0,
+					LPC_HICR0_LPC1E, 0);
+			regmap_update_bits(priv->map, LPC_HICR2,
+					LPC_HICR2_IBFIF1, 0);
+		}
 		break;
-	case 2:
-		if (!(hw_type == LPC_TYIRQX_LOW || hw_type == LPC_TYIRQX_HIGH))
-			return -EINVAL;
-
-		mask = LPC_HICR5_SEL2IRQX | LPC_HICR5_ID2IRQX_MASK;
-		val = (id << LPC_HICR5_ID2IRQX_SHIFT);
-		val |= (hw_type == LPC_TYIRQX_HIGH) ? LPC_HICR5_SEL2IRQX : 0;
-		regmap_update_bits(priv->map, LPC_HICR5, mask, val);
 
+	case 2:
+		if (enable) {
+			regmap_update_bits(priv->map, LPC_HICR2,
+					LPC_HICR2_IBFIF2, LPC_HICR2_IBFIF2);
+			regmap_update_bits(priv->map, LPC_HICR0,
+					LPC_HICR0_LPC2E, LPC_HICR0_LPC2E);
+		} else {
+			regmap_update_bits(priv->map, LPC_HICR0,
+					LPC_HICR0_LPC2E, 0);
+			regmap_update_bits(priv->map, LPC_HICR2,
+					LPC_HICR2_IBFIF2, 0);
+		}
 		break;
-	case 3:
-		if (!(hw_type == LPC_TYIRQX_LOW || hw_type == LPC_TYIRQX_HIGH))
-			return -EINVAL;
-
-		mask = LPC_HICR5_SEL3IRQX | LPC_HICR5_ID3IRQX_MASK;
-		val = (id << LPC_HICR5_ID3IRQX_SHIFT);
-		val |= (hw_type == LPC_TYIRQX_HIGH) ? LPC_HICR5_SEL3IRQX : 0;
-		regmap_update_bits(priv->map, LPC_HICR5, mask, val);
 
+	case 3:
+		if (enable) {
+			regmap_update_bits(priv->map, LPC_HICR2,
+					LPC_HICR2_IBFIF3, LPC_HICR2_IBFIF3);
+			regmap_update_bits(priv->map, LPC_HICR0,
+					LPC_HICR0_LPC3E, LPC_HICR0_LPC3E);
+			regmap_update_bits(priv->map, LPC_HICR4,
+					LPC_HICR4_KCSENBL, LPC_HICR4_KCSENBL);
+		} else {
+			regmap_update_bits(priv->map, LPC_HICR0,
+					LPC_HICR0_LPC3E, 0);
+			regmap_update_bits(priv->map, LPC_HICR4,
+					LPC_HICR4_KCSENBL, 0);
+			regmap_update_bits(priv->map, LPC_HICR2,
+					LPC_HICR2_IBFIF3, 0);
+		}
 		break;
 	case 4:
-		mask = LPC_HICRC_ID4IRQX_MASK | LPC_HICRC_TY4IRQX_MASK | LPC_HICRC_OBF4_AUTO_CLR;
-		val = (id << LPC_HICRC_ID4IRQX_SHIFT) | (hw_type << LPC_HICRC_TY4IRQX_SHIFT);
-		regmap_update_bits(priv->map, LPC_HICRC, mask, val);
+		if (enable)
+			regmap_update_bits(priv->map, LPC_HICRB,
+					LPC_HICRB_IBFIF4 | LPC_HICRB_LPC4E,
+					LPC_HICRB_IBFIF4 | LPC_HICRB_LPC4E);
+		else
+			regmap_update_bits(priv->map, LPC_HICRB,
+					LPC_HICRB_IBFIF4 | LPC_HICRB_LPC4E,
+					0);
 		break;
 	default:
-		dev_warn(priv->kcs_bmc.dev,
-			 "SerIRQ configuration not supported on KCS channel %d\n",
-			 priv->kcs_bmc.channel);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static void aspeed_kcs_enable_channel(struct kcs_bmc_device *kcs_bmc, bool enable)
-{
-	struct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);
-
-	switch (kcs_bmc->channel) {
-	case 1:
-		regmap_update_bits(priv->map, LPC_HICR0, LPC_HICR0_LPC1E, enable * LPC_HICR0_LPC1E);
-		return;
-	case 2:
-		regmap_update_bits(priv->map, LPC_HICR0, LPC_HICR0_LPC2E, enable * LPC_HICR0_LPC2E);
-		return;
-	case 3:
-		regmap_update_bits(priv->map, LPC_HICR0, LPC_HICR0_LPC3E, enable * LPC_HICR0_LPC3E);
-		regmap_update_bits(priv->map, LPC_HICR4,
-				   LPC_HICR4_KCSENBL, enable * LPC_HICR4_KCSENBL);
-		return;
-	case 4:
-		regmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_LPC4E, enable * LPC_HICRB_LPC4E);
-		return;
-	default:
-		pr_warn("%s: Unsupported channel: %d", __func__, kcs_bmc->channel);
-		return;
-	}
-}
-
-static void aspeed_kcs_check_obe(struct timer_list *timer)
-{
-	struct aspeed_kcs_bmc *priv = container_of(timer, struct aspeed_kcs_bmc, obe.timer);
-	unsigned long flags;
-	u8 str;
-
-	spin_lock_irqsave(&priv->obe.lock, flags);
-	if (priv->obe.remove) {
-		spin_unlock_irqrestore(&priv->obe.lock, flags);
-		return;
-	}
-
-	str = aspeed_kcs_inb(&priv->kcs_bmc, priv->kcs_bmc.ioreg.str);
-	if (str & KCS_BMC_STR_OBF) {
-		mod_timer(timer, jiffies + OBE_POLL_PERIOD);
-		spin_unlock_irqrestore(&priv->obe.lock, flags);
-		return;
-	}
-	spin_unlock_irqrestore(&priv->obe.lock, flags);
-
-	kcs_bmc_handle_event(&priv->kcs_bmc);
-}
-
-static void aspeed_kcs_irq_mask_update(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 state)
-{
-	struct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);
-	int rc;
-	u8 str;
-
-	/* We don't have an OBE IRQ, emulate it */
-	if (mask & KCS_BMC_EVENT_TYPE_OBE) {
-		if (KCS_BMC_EVENT_TYPE_OBE & state) {
-			/*
-			 * Given we don't have an OBE IRQ, delay by polling briefly to see if we can
-			 * observe such an event before returning to the caller. This is not
-			 * incorrect because OBF may have already become clear before enabling the
-			 * IRQ if we had one, under which circumstance no event will be propagated
-			 * anyway.
-			 *
-			 * The onus is on the client to perform a race-free check that it hasn't
-			 * missed the event.
-			 */
-			rc = read_poll_timeout_atomic(aspeed_kcs_inb, str,
-						      !(str & KCS_BMC_STR_OBF), 1, 100, false,
-						      &priv->kcs_bmc, priv->kcs_bmc.ioreg.str);
-			/* Time for the slow path? */
-			if (rc == -ETIMEDOUT)
-				mod_timer(&priv->obe.timer, jiffies + OBE_POLL_PERIOD);
-		} else {
-			del_timer(&priv->obe.timer);
-		}
-	}
+		break;
 
-	if (mask & KCS_BMC_EVENT_TYPE_IBF) {
-		const bool enable = !!(state & KCS_BMC_EVENT_TYPE_IBF);
-
-		switch (kcs_bmc->channel) {
-		case 1:
-			regmap_update_bits(priv->map, LPC_HICR2, LPC_HICR2_IBFIE1,
-					   enable * LPC_HICR2_IBFIE1);
-			return;
-		case 2:
-			regmap_update_bits(priv->map, LPC_HICR2, LPC_HICR2_IBFIE2,
-					   enable * LPC_HICR2_IBFIE2);
-			return;
-		case 3:
-			regmap_update_bits(priv->map, LPC_HICR2, LPC_HICR2_IBFIE3,
-					   enable * LPC_HICR2_IBFIE3);
-			return;
-		case 4:
-			regmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_IBFIE4,
-					   enable * LPC_HICRB_IBFIE4);
-			return;
-		default:
-			pr_warn("%s: Unsupported channel: %d", __func__, kcs_bmc->channel);
-			return;
-		}
 	}
 }
 
-static const struct kcs_bmc_device_ops aspeed_kcs_ops = {
-	.irq_mask_update = aspeed_kcs_irq_mask_update,
-	.io_inputb = aspeed_kcs_inb,
-	.io_outputb = aspeed_kcs_outb,
-	.io_updateb = aspeed_kcs_updateb,
-};
-
 static irqreturn_t aspeed_kcs_irq(int irq, void *arg)
 {
-	struct kcs_bmc_device *kcs_bmc = arg;
+	struct kcs_bmc *kcs_bmc = arg;
+
+	if (!kcs_bmc_handle_event(kcs_bmc))
+		return IRQ_HANDLED;
 
-	return kcs_bmc_handle_event(kcs_bmc);
+	return IRQ_NONE;
 }
 
-static int aspeed_kcs_config_downstream_irq(struct kcs_bmc_device *kcs_bmc,
+static int aspeed_kcs_config_irq(struct kcs_bmc *kcs_bmc,
 			struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -495,176 +238,143 @@ static const struct kcs_ioreg ast_kcs_bmc_ioregs[KCS_CHANNEL_MAX] = {
 	{ .idr = LPC_IDR4, .odr = LPC_ODR4, .str = LPC_STR4 },
 };
 
-static int aspeed_kcs_of_get_channel(struct platform_device *pdev)
+static struct kcs_bmc *aspeed_kcs_probe_of_v1(struct platform_device *pdev)
 {
+	struct aspeed_kcs_bmc *priv;
 	struct device_node *np;
-	struct kcs_ioreg ioreg;
-	const __be32 *reg;
+	struct kcs_bmc *kcs;
+	u32 channel;
+	u32 slave;
+	int rc;
+	np = pdev->dev.of_node;
+	rc = of_property_read_u32(np, "kcs_chan", &channel);
+	if ((rc != 0) || (channel == 0 || channel > KCS_CHANNEL_MAX)) {
+		dev_err(&pdev->dev, "no valid 'kcs_chan' configured\n");
+		return ERR_PTR(-EINVAL);
+	}
+	kcs = kcs_bmc_alloc(&pdev->dev, sizeof(struct aspeed_kcs_bmc), channel);
+	if (!kcs)
+		return ERR_PTR(-ENOMEM);
+	priv = kcs_bmc_priv(kcs);
+	priv->map = syscon_node_to_regmap(pdev->dev.parent->of_node);
+	if (IS_ERR(priv->map)) {
+		dev_err(&pdev->dev, "Couldn't get regmap\n");
+		return ERR_PTR(-ENODEV);
+	}
+	rc = of_property_read_u32(np, "kcs_addr", &slave);
+	if (rc) {
+		dev_err(&pdev->dev, "no valid 'kcs_addr' configured\n");
+		return ERR_PTR(-EINVAL);
+	}
+	kcs->ioreg = ast_kcs_bmc_ioregs[channel - 1];
+	aspeed_kcs_set_address(kcs, slave);
+
+	return kcs;
+}
+
+static int aspeed_kcs_calculate_channel(const struct kcs_ioreg *regs)
+{
 	int i;
+	for (i = 0; i < ARRAY_SIZE(ast_kcs_bmc_ioregs); i++) {
+		if (!memcmp(&ast_kcs_bmc_ioregs[i], regs, sizeof(*regs)))
+			return i + 1;
+	}
+	return -EINVAL;
+}
 
+static struct kcs_bmc *aspeed_kcs_probe_of_v2(struct platform_device *pdev)
+{
+	struct aspeed_kcs_bmc *priv;
+	struct device_node *np;
+	struct kcs_ioreg ioreg;
+	struct kcs_bmc *kcs;
+	const __be32 *reg;
+	int channel;
+	u32 slave;
+	int rc;
 	np = pdev->dev.of_node;
-
 	/* Don't translate addresses, we want offsets for the regmaps */
 	reg = of_get_address(np, 0, NULL, NULL);
 	if (!reg)
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	ioreg.idr = be32_to_cpup(reg);
-
 	reg = of_get_address(np, 1, NULL, NULL);
 	if (!reg)
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	ioreg.odr = be32_to_cpup(reg);
-
 	reg = of_get_address(np, 2, NULL, NULL);
 	if (!reg)
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	ioreg.str = be32_to_cpup(reg);
-
-	for (i = 0; i < ARRAY_SIZE(ast_kcs_bmc_ioregs); i++) {
-		if (!memcmp(&ast_kcs_bmc_ioregs[i], &ioreg, sizeof(ioreg)))
-			return i + 1;
-	}
-	return -EINVAL;
-}
-
-static int
-aspeed_kcs_of_get_io_address(struct platform_device *pdev, u32 addrs[2])
-{
-	int rc;
-
-	rc = of_property_read_variable_u32_array(pdev->dev.of_node,
-						 "aspeed,lpc-io-reg",
-						 addrs, 1, 2);
-	if (rc < 0) {
-		dev_err(&pdev->dev, "No valid 'aspeed,lpc-io-reg' configured\n");
-		return rc;
-	}
-
-	if (addrs[0] > 0xffff) {
-		dev_err(&pdev->dev, "Invalid data address in 'aspeed,lpc-io-reg'\n");
-		return -EINVAL;
-	}
-
-	if (rc == 2 && addrs[1] > 0xffff) {
-		dev_err(&pdev->dev, "Invalid status address in 'aspeed,lpc-io-reg'\n");
-		return -EINVAL;
+	channel = aspeed_kcs_calculate_channel(&ioreg);
+	if (channel < 0)
+		return ERR_PTR(channel);
+	kcs = kcs_bmc_alloc(&pdev->dev, sizeof(struct aspeed_kcs_bmc), channel);
+	if (!kcs)
+		return ERR_PTR(-ENOMEM);
+	kcs->ioreg = ioreg;
+	priv = kcs_bmc_priv(kcs);
+	priv->map = syscon_node_to_regmap(pdev->dev.parent->of_node);
+	if (IS_ERR(priv->map)) {
+		dev_err(&pdev->dev, "Couldn't get regmap\n");
+		return ERR_PTR(-ENODEV);
 	}
-
-	return rc;
+	rc = of_property_read_u32(np, "aspeed,lpc-io-reg", &slave);
+	if (rc)
+		return ERR_PTR(rc);
+	aspeed_kcs_set_address(kcs, slave);
+	return kcs;
 }
 
 static int aspeed_kcs_probe(struct platform_device *pdev)
 {
-	struct kcs_bmc_device *kcs_bmc;
-	struct aspeed_kcs_bmc *priv;
+	struct device *dev = &pdev->dev;
+	struct kcs_bmc *kcs_bmc;
 	struct device_node *np;
-	bool have_upstream_irq;
-	u32 upstream_irq[2];
-	int rc, channel;
-	int nr_addrs;
-	u32 addrs[2];
-
-	np = pdev->dev.of_node->parent;
-	if (!of_device_is_compatible(np, "aspeed,ast2400-lpc-v2") &&
-	    !of_device_is_compatible(np, "aspeed,ast2500-lpc-v2") &&
-	    !of_device_is_compatible(np, "aspeed,ast2600-lpc-v2")) {
-		dev_err(&pdev->dev, "unsupported LPC device binding\n");
-		return -ENODEV;
-	}
-
-	channel = aspeed_kcs_of_get_channel(pdev);
-	if (channel < 0)
-		return channel;
-
-	nr_addrs = aspeed_kcs_of_get_io_address(pdev, addrs);
-	if (nr_addrs < 0)
-		return nr_addrs;
-
+	int rc;
 	np = pdev->dev.of_node;
-	rc = of_property_read_u32_array(np, "aspeed,lpc-interrupts", upstream_irq, 2);
-	if (rc && rc != -EINVAL)
+	if (of_device_is_compatible(np, "aspeed,ast2400-kcs-bmc") ||
+			of_device_is_compatible(np, "aspeed,ast2500-kcs-bmc"))
+		kcs_bmc = aspeed_kcs_probe_of_v1(pdev);
+	else if (of_device_is_compatible(np, "aspeed,ast2400-kcs-bmc-v2") ||
+			of_device_is_compatible(np, "aspeed,ast2500-kcs-bmc-v2"))
+		kcs_bmc = aspeed_kcs_probe_of_v2(pdev);
+	else
 		return -EINVAL;
-
-	have_upstream_irq = !rc;
-
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	kcs_bmc = &priv->kcs_bmc;
-	kcs_bmc->dev = &pdev->dev;
-	kcs_bmc->channel = channel;
-	kcs_bmc->ioreg = ast_kcs_bmc_ioregs[channel - 1];
-	kcs_bmc->ops = &aspeed_kcs_ops;
-
-	priv->map = syscon_node_to_regmap(pdev->dev.parent->of_node);
-	if (IS_ERR(priv->map)) {
-		dev_err(&pdev->dev, "Couldn't get regmap\n");
-		return -ENODEV;
-	}
-
-	spin_lock_init(&priv->obe.lock);
-	priv->obe.remove = false;
-	timer_setup(&priv->obe.timer, aspeed_kcs_check_obe, 0);
-
-	rc = aspeed_kcs_set_address(kcs_bmc, addrs, nr_addrs);
-	if (rc)
-		return rc;
-
-	/* Host to BMC IRQ */
-	rc = aspeed_kcs_config_downstream_irq(kcs_bmc, pdev);
+	if (IS_ERR(kcs_bmc))
+		return PTR_ERR(kcs_bmc);
+	kcs_bmc->io_inputb = aspeed_kcs_inb;
+	kcs_bmc->io_outputb = aspeed_kcs_outb;
+	rc = aspeed_kcs_config_irq(kcs_bmc, pdev);
 	if (rc)
 		return rc;
-
-	/* BMC to Host IRQ */
-	if (have_upstream_irq) {
-		rc = aspeed_kcs_config_upstream_irq(priv, upstream_irq[0], upstream_irq[1]);
-		if (rc < 0)
-			return rc;
-	} else {
-		priv->upstream_irq.mode = aspeed_kcs_irq_none;
-	}
-
-	platform_set_drvdata(pdev, priv);
-
-	aspeed_kcs_irq_mask_update(kcs_bmc, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);
+	dev_set_drvdata(dev, kcs_bmc);
 	aspeed_kcs_enable_channel(kcs_bmc, true);
-
-	rc = kcs_bmc_add_device(&priv->kcs_bmc);
+	rc = misc_register(&kcs_bmc->miscdev);
 	if (rc) {
-		dev_warn(&pdev->dev, "Failed to register channel %d: %d\n", kcs_bmc->channel, rc);
+		dev_err(dev, "Unable to register device\n");
 		return rc;
 	}
-
-	dev_info(&pdev->dev, "Initialised channel %d at 0x%x\n",
-			kcs_bmc->channel, addrs[0]);
-
+	dev_dbg(&pdev->dev,
+		"Probed KCS device %d (IDR=0x%x, ODR=0x%x, STR=0x%x)\n",
+		kcs_bmc->channel, kcs_bmc->ioreg.idr, kcs_bmc->ioreg.odr,
+		kcs_bmc->ioreg.str);
 	return 0;
 }
 
 static int aspeed_kcs_remove(struct platform_device *pdev)
 {
-	struct aspeed_kcs_bmc *priv = platform_get_drvdata(pdev);
-	struct kcs_bmc_device *kcs_bmc = &priv->kcs_bmc;
-
-	kcs_bmc_remove_device(kcs_bmc);
-
-	aspeed_kcs_enable_channel(kcs_bmc, false);
-	aspeed_kcs_irq_mask_update(kcs_bmc, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);
-
-	/* Make sure it's proper dead */
-	spin_lock_irq(&priv->obe.lock);
-	priv->obe.remove = true;
-	spin_unlock_irq(&priv->obe.lock);
-	del_timer_sync(&priv->obe.timer);
-
+	struct kcs_bmc *kcs_bmc = dev_get_drvdata(&pdev->dev);
+	misc_deregister(&kcs_bmc->miscdev);
 	return 0;
 }
 
+
 static const struct of_device_id ast_kcs_bmc_match[] = {
+	{ .compatible = "aspeed,ast2400-kcs-bmc" },
+	{ .compatible = "aspeed,ast2500-kcs-bmc" },
 	{ .compatible = "aspeed,ast2400-kcs-bmc-v2" },
 	{ .compatible = "aspeed,ast2500-kcs-bmc-v2" },
-	{ .compatible = "aspeed,ast2600-kcs-bmc" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, ast_kcs_bmc_match);
@@ -681,5 +391,4 @@ module_platform_driver(ast_kcs_bmc_driver);
 
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Haiyue Wang <haiyue.wang@linux.intel.com>");
-MODULE_AUTHOR("Andrew Jeffery <andrew@aj.id.au>");
 MODULE_DESCRIPTION("Aspeed device interface to the KCS BMC device");
diff --git a/drivers/char/ipmi/kcs_bmc_cdev_ipmi.c b/drivers/char/ipmi/kcs_bmc_cdev_ipmi.c
deleted file mode 100644
index cf670e891966..000000000000
--- a/drivers/char/ipmi/kcs_bmc_cdev_ipmi.c
+++ /dev/null
@@ -1,568 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2015-2018, Intel Corporation.
- */
-
-#define pr_fmt(fmt) "kcs-bmc: " fmt
-
-#include <linux/errno.h>
-#include <linux/io.h>
-#include <linux/ipmi_bmc.h>
-#include <linux/list.h>
-#include <linux/miscdevice.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/poll.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-
-#include "kcs_bmc_client.h"
-
-/* Different phases of the KCS BMC module.
- *  KCS_PHASE_IDLE:
- *            BMC should not be expecting nor sending any data.
- *  KCS_PHASE_WRITE_START:
- *            BMC is receiving a WRITE_START command from system software.
- *  KCS_PHASE_WRITE_DATA:
- *            BMC is receiving a data byte from system software.
- *  KCS_PHASE_WRITE_END_CMD:
- *            BMC is waiting a last data byte from system software.
- *  KCS_PHASE_WRITE_DONE:
- *            BMC has received the whole request from system software.
- *  KCS_PHASE_WAIT_READ:
- *            BMC is waiting the response from the upper IPMI service.
- *  KCS_PHASE_READ:
- *            BMC is transferring the response to system software.
- *  KCS_PHASE_ABORT_ERROR1:
- *            BMC is waiting error status request from system software.
- *  KCS_PHASE_ABORT_ERROR2:
- *            BMC is waiting for idle status afer error from system software.
- *  KCS_PHASE_ERROR:
- *            BMC has detected a protocol violation at the interface level.
- */
-enum kcs_ipmi_phases {
-	KCS_PHASE_IDLE,
-
-	KCS_PHASE_WRITE_START,
-	KCS_PHASE_WRITE_DATA,
-	KCS_PHASE_WRITE_END_CMD,
-	KCS_PHASE_WRITE_DONE,
-
-	KCS_PHASE_WAIT_READ,
-	KCS_PHASE_READ,
-
-	KCS_PHASE_ABORT_ERROR1,
-	KCS_PHASE_ABORT_ERROR2,
-	KCS_PHASE_ERROR
-};
-
-/* IPMI 2.0 - Table 9-4, KCS Interface Status Codes */
-enum kcs_ipmi_errors {
-	KCS_NO_ERROR                = 0x00,
-	KCS_ABORTED_BY_COMMAND      = 0x01,
-	KCS_ILLEGAL_CONTROL_CODE    = 0x02,
-	KCS_LENGTH_ERROR            = 0x06,
-	KCS_UNSPECIFIED_ERROR       = 0xFF
-};
-
-struct kcs_bmc_ipmi {
-	struct list_head entry;
-
-	struct kcs_bmc_client client;
-
-	spinlock_t lock;
-
-	enum kcs_ipmi_phases phase;
-	enum kcs_ipmi_errors error;
-
-	wait_queue_head_t queue;
-	bool data_in_avail;
-	int  data_in_idx;
-	u8  *data_in;
-
-	int  data_out_idx;
-	int  data_out_len;
-	u8  *data_out;
-
-	struct mutex mutex;
-	u8 *kbuffer;
-
-	struct miscdevice miscdev;
-};
-
-#define DEVICE_NAME "ipmi-kcs"
-
-#define KCS_MSG_BUFSIZ    1000
-
-#define KCS_ZERO_DATA     0
-
-/* IPMI 2.0 - Table 9-1, KCS Interface Status Register Bits */
-#define KCS_STATUS_STATE(state) (state << 6)
-#define KCS_STATUS_STATE_MASK   GENMASK(7, 6)
-#define KCS_STATUS_CMD_DAT      BIT(3)
-#define KCS_STATUS_SMS_ATN      BIT(2)
-#define KCS_STATUS_IBF          BIT(1)
-#define KCS_STATUS_OBF          BIT(0)
-
-/* IPMI 2.0 - Table 9-2, KCS Interface State Bits */
-enum kcs_states {
-	IDLE_STATE  = 0,
-	READ_STATE  = 1,
-	WRITE_STATE = 2,
-	ERROR_STATE = 3,
-};
-
-/* IPMI 2.0 - Table 9-3, KCS Interface Control Codes */
-#define KCS_CMD_GET_STATUS_ABORT  0x60
-#define KCS_CMD_WRITE_START       0x61
-#define KCS_CMD_WRITE_END         0x62
-#define KCS_CMD_READ_BYTE         0x68
-
-static inline void set_state(struct kcs_bmc_ipmi *priv, u8 state)
-{
-	kcs_bmc_update_status(priv->client.dev, KCS_STATUS_STATE_MASK, KCS_STATUS_STATE(state));
-}
-
-static void kcs_bmc_ipmi_force_abort(struct kcs_bmc_ipmi *priv)
-{
-	set_state(priv, ERROR_STATE);
-	kcs_bmc_read_data(priv->client.dev);
-	kcs_bmc_write_data(priv->client.dev, KCS_ZERO_DATA);
-
-	priv->phase = KCS_PHASE_ERROR;
-	priv->data_in_avail = false;
-	priv->data_in_idx = 0;
-}
-
-static void kcs_bmc_ipmi_handle_data(struct kcs_bmc_ipmi *priv)
-{
-	struct kcs_bmc_device *dev;
-	u8 data;
-
-	dev = priv->client.dev;
-
-	switch (priv->phase) {
-	case KCS_PHASE_WRITE_START:
-		priv->phase = KCS_PHASE_WRITE_DATA;
-		fallthrough;
-
-	case KCS_PHASE_WRITE_DATA:
-		if (priv->data_in_idx < KCS_MSG_BUFSIZ) {
-			set_state(priv, WRITE_STATE);
-			kcs_bmc_write_data(dev, KCS_ZERO_DATA);
-			priv->data_in[priv->data_in_idx++] = kcs_bmc_read_data(dev);
-		} else {
-			kcs_bmc_ipmi_force_abort(priv);
-			priv->error = KCS_LENGTH_ERROR;
-		}
-		break;
-
-	case KCS_PHASE_WRITE_END_CMD:
-		if (priv->data_in_idx < KCS_MSG_BUFSIZ) {
-			set_state(priv, READ_STATE);
-			priv->data_in[priv->data_in_idx++] = kcs_bmc_read_data(dev);
-			priv->phase = KCS_PHASE_WRITE_DONE;
-			priv->data_in_avail = true;
-			wake_up_interruptible(&priv->queue);
-		} else {
-			kcs_bmc_ipmi_force_abort(priv);
-			priv->error = KCS_LENGTH_ERROR;
-		}
-		break;
-
-	case KCS_PHASE_READ:
-		if (priv->data_out_idx == priv->data_out_len)
-			set_state(priv, IDLE_STATE);
-
-		data = kcs_bmc_read_data(dev);
-		if (data != KCS_CMD_READ_BYTE) {
-			set_state(priv, ERROR_STATE);
-			kcs_bmc_write_data(dev, KCS_ZERO_DATA);
-			break;
-		}
-
-		if (priv->data_out_idx == priv->data_out_len) {
-			kcs_bmc_write_data(dev, KCS_ZERO_DATA);
-			priv->phase = KCS_PHASE_IDLE;
-			break;
-		}
-
-		kcs_bmc_write_data(dev, priv->data_out[priv->data_out_idx++]);
-		break;
-
-	case KCS_PHASE_ABORT_ERROR1:
-		set_state(priv, READ_STATE);
-		kcs_bmc_read_data(dev);
-		kcs_bmc_write_data(dev, priv->error);
-		priv->phase = KCS_PHASE_ABORT_ERROR2;
-		break;
-
-	case KCS_PHASE_ABORT_ERROR2:
-		set_state(priv, IDLE_STATE);
-		kcs_bmc_read_data(dev);
-		kcs_bmc_write_data(dev, KCS_ZERO_DATA);
-		priv->phase = KCS_PHASE_IDLE;
-		break;
-
-	default:
-		kcs_bmc_ipmi_force_abort(priv);
-		break;
-	}
-}
-
-static void kcs_bmc_ipmi_handle_cmd(struct kcs_bmc_ipmi *priv)
-{
-	u8 cmd;
-
-	set_state(priv, WRITE_STATE);
-	kcs_bmc_write_data(priv->client.dev, KCS_ZERO_DATA);
-
-	cmd = kcs_bmc_read_data(priv->client.dev);
-	switch (cmd) {
-	case KCS_CMD_WRITE_START:
-		priv->phase = KCS_PHASE_WRITE_START;
-		priv->error = KCS_NO_ERROR;
-		priv->data_in_avail = false;
-		priv->data_in_idx = 0;
-		break;
-
-	case KCS_CMD_WRITE_END:
-		if (priv->phase != KCS_PHASE_WRITE_DATA) {
-			kcs_bmc_ipmi_force_abort(priv);
-			break;
-		}
-
-		priv->phase = KCS_PHASE_WRITE_END_CMD;
-		break;
-
-	case KCS_CMD_GET_STATUS_ABORT:
-		if (priv->error == KCS_NO_ERROR)
-			priv->error = KCS_ABORTED_BY_COMMAND;
-
-		priv->phase = KCS_PHASE_ABORT_ERROR1;
-		priv->data_in_avail = false;
-		priv->data_in_idx = 0;
-		break;
-
-	default:
-		kcs_bmc_ipmi_force_abort(priv);
-		priv->error = KCS_ILLEGAL_CONTROL_CODE;
-		break;
-	}
-}
-
-static inline struct kcs_bmc_ipmi *client_to_kcs_bmc_ipmi(struct kcs_bmc_client *client)
-{
-	return container_of(client, struct kcs_bmc_ipmi, client);
-}
-
-static irqreturn_t kcs_bmc_ipmi_event(struct kcs_bmc_client *client)
-{
-	struct kcs_bmc_ipmi *priv;
-	u8 status;
-	int ret;
-
-	priv = client_to_kcs_bmc_ipmi(client);
-	if (!priv)
-		return IRQ_NONE;
-
-	spin_lock(&priv->lock);
-
-	status = kcs_bmc_read_status(client->dev);
-	if (status & KCS_STATUS_IBF) {
-		if (status & KCS_STATUS_CMD_DAT)
-			kcs_bmc_ipmi_handle_cmd(priv);
-		else
-			kcs_bmc_ipmi_handle_data(priv);
-
-		ret = IRQ_HANDLED;
-	} else {
-		ret = IRQ_NONE;
-	}
-
-	spin_unlock(&priv->lock);
-
-	return ret;
-}
-
-static const struct kcs_bmc_client_ops kcs_bmc_ipmi_client_ops = {
-	.event = kcs_bmc_ipmi_event,
-};
-
-static inline struct kcs_bmc_ipmi *to_kcs_bmc(struct file *filp)
-{
-	return container_of(filp->private_data, struct kcs_bmc_ipmi, miscdev);
-}
-
-static int kcs_bmc_ipmi_open(struct inode *inode, struct file *filp)
-{
-	struct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);
-
-	return kcs_bmc_enable_device(priv->client.dev, &priv->client);
-}
-
-static __poll_t kcs_bmc_ipmi_poll(struct file *filp, poll_table *wait)
-{
-	struct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);
-	__poll_t mask = 0;
-
-	poll_wait(filp, &priv->queue, wait);
-
-	spin_lock_irq(&priv->lock);
-	if (priv->data_in_avail)
-		mask |= EPOLLIN;
-	spin_unlock_irq(&priv->lock);
-
-	return mask;
-}
-
-static ssize_t kcs_bmc_ipmi_read(struct file *filp, char __user *buf,
-			    size_t count, loff_t *ppos)
-{
-	struct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);
-	bool data_avail;
-	size_t data_len;
-	ssize_t ret;
-
-	if (!(filp->f_flags & O_NONBLOCK))
-		wait_event_interruptible(priv->queue,
-					 priv->data_in_avail);
-
-	mutex_lock(&priv->mutex);
-
-	spin_lock_irq(&priv->lock);
-	data_avail = priv->data_in_avail;
-	if (data_avail) {
-		data_len = priv->data_in_idx;
-		memcpy(priv->kbuffer, priv->data_in, data_len);
-	}
-	spin_unlock_irq(&priv->lock);
-
-	if (!data_avail) {
-		ret = -EAGAIN;
-		goto out_unlock;
-	}
-
-	if (count < data_len) {
-		pr_err("channel=%u with too large data : %zu\n",
-			priv->client.dev->channel, data_len);
-
-		spin_lock_irq(&priv->lock);
-		kcs_bmc_ipmi_force_abort(priv);
-		spin_unlock_irq(&priv->lock);
-
-		ret = -EOVERFLOW;
-		goto out_unlock;
-	}
-
-	if (copy_to_user(buf, priv->kbuffer, data_len)) {
-		ret = -EFAULT;
-		goto out_unlock;
-	}
-
-	ret = data_len;
-
-	spin_lock_irq(&priv->lock);
-	if (priv->phase == KCS_PHASE_WRITE_DONE) {
-		priv->phase = KCS_PHASE_WAIT_READ;
-		priv->data_in_avail = false;
-		priv->data_in_idx = 0;
-	} else {
-		ret = -EAGAIN;
-	}
-	spin_unlock_irq(&priv->lock);
-
-out_unlock:
-	mutex_unlock(&priv->mutex);
-
-	return ret;
-}
-
-static ssize_t kcs_bmc_ipmi_write(struct file *filp, const char __user *buf,
-			     size_t count, loff_t *ppos)
-{
-	struct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);
-	ssize_t ret;
-
-	/* a minimum response size '3' : netfn + cmd + ccode */
-	if (count < 3 || count > KCS_MSG_BUFSIZ)
-		return -EINVAL;
-
-	mutex_lock(&priv->mutex);
-
-	if (copy_from_user(priv->kbuffer, buf, count)) {
-		ret = -EFAULT;
-		goto out_unlock;
-	}
-
-	spin_lock_irq(&priv->lock);
-	if (priv->phase == KCS_PHASE_WAIT_READ) {
-		priv->phase = KCS_PHASE_READ;
-		priv->data_out_idx = 1;
-		priv->data_out_len = count;
-		memcpy(priv->data_out, priv->kbuffer, count);
-		kcs_bmc_write_data(priv->client.dev, priv->data_out[0]);
-		ret = count;
-	} else {
-		ret = -EINVAL;
-	}
-	spin_unlock_irq(&priv->lock);
-
-out_unlock:
-	mutex_unlock(&priv->mutex);
-
-	return ret;
-}
-
-static long kcs_bmc_ipmi_ioctl(struct file *filp, unsigned int cmd,
-			  unsigned long arg)
-{
-	struct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);
-	long ret = 0;
-
-	spin_lock_irq(&priv->lock);
-
-	switch (cmd) {
-	case IPMI_BMC_IOCTL_SET_SMS_ATN:
-		kcs_bmc_update_status(priv->client.dev, KCS_STATUS_SMS_ATN, KCS_STATUS_SMS_ATN);
-		break;
-
-	case IPMI_BMC_IOCTL_CLEAR_SMS_ATN:
-		kcs_bmc_update_status(priv->client.dev, KCS_STATUS_SMS_ATN, 0);
-		break;
-
-	case IPMI_BMC_IOCTL_FORCE_ABORT:
-		kcs_bmc_ipmi_force_abort(priv);
-		break;
-
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	spin_unlock_irq(&priv->lock);
-
-	return ret;
-}
-
-static int kcs_bmc_ipmi_release(struct inode *inode, struct file *filp)
-{
-	struct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);
-
-	kcs_bmc_ipmi_force_abort(priv);
-	kcs_bmc_disable_device(priv->client.dev, &priv->client);
-
-	return 0;
-}
-
-static const struct file_operations kcs_bmc_ipmi_fops = {
-	.owner          = THIS_MODULE,
-	.open           = kcs_bmc_ipmi_open,
-	.read           = kcs_bmc_ipmi_read,
-	.write          = kcs_bmc_ipmi_write,
-	.release        = kcs_bmc_ipmi_release,
-	.poll           = kcs_bmc_ipmi_poll,
-	.unlocked_ioctl = kcs_bmc_ipmi_ioctl,
-};
-
-static DEFINE_SPINLOCK(kcs_bmc_ipmi_instances_lock);
-static LIST_HEAD(kcs_bmc_ipmi_instances);
-
-static int kcs_bmc_ipmi_add_device(struct kcs_bmc_device *kcs_bmc)
-{
-	struct kcs_bmc_ipmi *priv;
-	int rc;
-
-	priv = devm_kzalloc(kcs_bmc->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	spin_lock_init(&priv->lock);
-	mutex_init(&priv->mutex);
-
-	init_waitqueue_head(&priv->queue);
-
-	priv->client.dev = kcs_bmc;
-	priv->client.ops = &kcs_bmc_ipmi_client_ops;
-	priv->data_in = devm_kmalloc(kcs_bmc->dev, KCS_MSG_BUFSIZ, GFP_KERNEL);
-	priv->data_out = devm_kmalloc(kcs_bmc->dev, KCS_MSG_BUFSIZ, GFP_KERNEL);
-	priv->kbuffer = devm_kmalloc(kcs_bmc->dev, KCS_MSG_BUFSIZ, GFP_KERNEL);
-
-	priv->miscdev.minor = MISC_DYNAMIC_MINOR;
-	priv->miscdev.name = devm_kasprintf(kcs_bmc->dev, GFP_KERNEL, "%s%u", DEVICE_NAME,
-					   kcs_bmc->channel);
-	if (!priv->data_in || !priv->data_out || !priv->kbuffer || !priv->miscdev.name)
-		return -EINVAL;
-
-	priv->miscdev.fops = &kcs_bmc_ipmi_fops;
-
-	rc = misc_register(&priv->miscdev);
-	if (rc) {
-		dev_err(kcs_bmc->dev, "Unable to register device: %d\n", rc);
-		return rc;
-	}
-
-	spin_lock_irq(&kcs_bmc_ipmi_instances_lock);
-	list_add(&priv->entry, &kcs_bmc_ipmi_instances);
-	spin_unlock_irq(&kcs_bmc_ipmi_instances_lock);
-
-	dev_info(kcs_bmc->dev, "Initialised IPMI client for channel %d", kcs_bmc->channel);
-
-	return 0;
-}
-
-static int kcs_bmc_ipmi_remove_device(struct kcs_bmc_device *kcs_bmc)
-{
-	struct kcs_bmc_ipmi *priv = NULL, *pos;
-
-	spin_lock_irq(&kcs_bmc_ipmi_instances_lock);
-	list_for_each_entry(pos, &kcs_bmc_ipmi_instances, entry) {
-		if (pos->client.dev == kcs_bmc) {
-			priv = pos;
-			list_del(&pos->entry);
-			break;
-		}
-	}
-	spin_unlock_irq(&kcs_bmc_ipmi_instances_lock);
-
-	if (!priv)
-		return -ENODEV;
-
-	misc_deregister(&priv->miscdev);
-	kcs_bmc_disable_device(priv->client.dev, &priv->client);
-	devm_kfree(kcs_bmc->dev, priv->kbuffer);
-	devm_kfree(kcs_bmc->dev, priv->data_out);
-	devm_kfree(kcs_bmc->dev, priv->data_in);
-	devm_kfree(kcs_bmc->dev, priv);
-
-	return 0;
-}
-
-static const struct kcs_bmc_driver_ops kcs_bmc_ipmi_driver_ops = {
-	.add_device = kcs_bmc_ipmi_add_device,
-	.remove_device = kcs_bmc_ipmi_remove_device,
-};
-
-static struct kcs_bmc_driver kcs_bmc_ipmi_driver = {
-	.ops = &kcs_bmc_ipmi_driver_ops,
-};
-
-static int __init kcs_bmc_ipmi_init(void)
-{
-	kcs_bmc_register_driver(&kcs_bmc_ipmi_driver);
-
-	return 0;
-}
-module_init(kcs_bmc_ipmi_init);
-
-static void __exit kcs_bmc_ipmi_exit(void)
-{
-	kcs_bmc_unregister_driver(&kcs_bmc_ipmi_driver);
-}
-module_exit(kcs_bmc_ipmi_exit);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Haiyue Wang <haiyue.wang@linux.intel.com>");
-MODULE_AUTHOR("Andrew Jeffery <andrew@aj.id.au>");
-MODULE_DESCRIPTION("KCS BMC to handle the IPMI request from system software");
diff --git a/drivers/char/ipmi/kcs_bmc_cdev_raw.c b/drivers/char/ipmi/kcs_bmc_cdev_raw.c
deleted file mode 100644
index 6865628476e1..000000000000
--- a/drivers/char/ipmi/kcs_bmc_cdev_raw.c
+++ /dev/null
@@ -1,447 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/* Copyright (c) 2021 IBM Corp. */
-
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/errno.h>
-#include <linux/fs.h>
-#include <linux/list.h>
-#include <linux/miscdevice.h>
-#include <linux/module.h>
-#include <linux/poll.h>
-
-#include "kcs_bmc_client.h"
-
-#define DEVICE_NAME "raw-kcs"
-
-struct kcs_bmc_raw {
-	struct list_head entry;
-
-	struct kcs_bmc_client client;
-
-	wait_queue_head_t queue;
-	u8 events;
-	bool writable;
-	bool readable;
-	u8 idr;
-
-	struct miscdevice miscdev;
-};
-
-static inline struct kcs_bmc_raw *client_to_kcs_bmc_raw(struct kcs_bmc_client *client)
-{
-	return container_of(client, struct kcs_bmc_raw, client);
-}
-
-/* Call under priv->queue.lock */
-static void kcs_bmc_raw_update_event_mask(struct kcs_bmc_raw *priv, u8 mask, u8 state)
-{
-	kcs_bmc_update_event_mask(priv->client.dev, mask, state);
-	priv->events &= ~mask;
-	priv->events |= state & mask;
-}
-
-static irqreturn_t kcs_bmc_raw_event(struct kcs_bmc_client *client)
-{
-	struct kcs_bmc_raw *priv;
-	struct device *dev;
-	u8 status, handled;
-
-	priv = client_to_kcs_bmc_raw(client);
-	dev = priv->miscdev.this_device;
-
-	spin_lock(&priv->queue.lock);
-
-	status = kcs_bmc_read_status(client->dev);
-	handled = 0;
-
-	if ((priv->events & KCS_BMC_EVENT_TYPE_IBF) && (status & KCS_BMC_STR_IBF)) {
-		if (priv->readable)
-			dev_err(dev, "Unexpected IBF IRQ, dropping data");
-
-		dev_dbg(dev, "Disabling IDR events for back-pressure\n");
-		kcs_bmc_raw_update_event_mask(priv, KCS_BMC_EVENT_TYPE_IBF, 0);
-		priv->idr = kcs_bmc_read_data(client->dev);
-		priv->readable = true;
-
-		dev_dbg(dev, "IDR read, waking waiters\n");
-		wake_up_locked(&priv->queue);
-
-		handled |= KCS_BMC_EVENT_TYPE_IBF;
-	}
-
-	if ((priv->events & KCS_BMC_EVENT_TYPE_OBE) && !(status & KCS_BMC_STR_OBF)) {
-		kcs_bmc_raw_update_event_mask(priv, KCS_BMC_EVENT_TYPE_OBE, 0);
-		priv->writable = true;
-
-		dev_dbg(dev, "ODR writable, waking waiters\n");
-		wake_up_locked(&priv->queue);
-
-		handled |= KCS_BMC_EVENT_TYPE_OBE;
-	}
-
-	spin_unlock(&priv->queue.lock);
-
-	return handled ? IRQ_HANDLED : IRQ_NONE;
-}
-
-static const struct kcs_bmc_client_ops kcs_bmc_raw_client_ops = {
-	.event = kcs_bmc_raw_event,
-};
-
-static inline struct kcs_bmc_raw *file_to_kcs_bmc_raw(struct file *filp)
-{
-	return container_of(filp->private_data, struct kcs_bmc_raw, miscdev);
-}
-
-static int kcs_bmc_raw_open(struct inode *inode, struct file *filp)
-{
-	struct kcs_bmc_raw *priv = file_to_kcs_bmc_raw(filp);
-	int rc;
-
-	priv->events = KCS_BMC_EVENT_TYPE_IBF;
-	rc = kcs_bmc_enable_device(priv->client.dev, &priv->client);
-	if (rc)
-		priv->events = 0;
-
-	return rc;
-}
-
-static bool kcs_bmc_raw_prepare_obe(struct kcs_bmc_raw *priv)
-{
-	bool writable;
-
-	/* Enable the OBE event so we can catch the host clearing OBF */
-	kcs_bmc_raw_update_event_mask(priv, KCS_BMC_EVENT_TYPE_OBE, KCS_BMC_EVENT_TYPE_OBE);
-
-	/* Now that we'll catch an OBE event, check if it's already occurred */
-	writable = !(kcs_bmc_read_status(priv->client.dev) & KCS_BMC_STR_OBF);
-
-	/* If OBF is clear we've missed the OBE event, so disable it */
-	if (writable)
-		kcs_bmc_raw_update_event_mask(priv, KCS_BMC_EVENT_TYPE_OBE, 0);
-
-	return writable;
-}
-
-static __poll_t kcs_bmc_raw_poll(struct file *filp, poll_table *wait)
-{
-	struct kcs_bmc_raw *priv;
-	__poll_t events = 0;
-
-	priv = file_to_kcs_bmc_raw(filp);
-
-	poll_wait(filp, &priv->queue, wait);
-
-	spin_lock_irq(&priv->queue.lock);
-	if (kcs_bmc_raw_prepare_obe(priv))
-		events |= (EPOLLOUT | EPOLLWRNORM);
-
-	if (priv->readable || (kcs_bmc_read_status(priv->client.dev) & KCS_BMC_STR_IBF))
-		events |= (EPOLLIN | EPOLLRDNORM);
-	spin_unlock_irq(&priv->queue.lock);
-
-	return events;
-}
-
-static ssize_t kcs_bmc_raw_read(struct file *filp, char __user *buf,
-			     size_t count, loff_t *ppos)
-{
-	struct kcs_bmc_device *kcs_bmc;
-	struct kcs_bmc_raw *priv;
-	bool read_idr, read_str;
-	struct device *dev;
-	u8 idr, str;
-	ssize_t rc;
-
-	priv = file_to_kcs_bmc_raw(filp);
-	kcs_bmc = priv->client.dev;
-	dev = priv->miscdev.this_device;
-
-	if (!count)
-		return 0;
-
-	if (count > 2 || *ppos > 1)
-		return -EINVAL;
-
-	if (*ppos + count > 2)
-		return -EINVAL;
-
-	read_idr = (*ppos == 0);
-	read_str = (*ppos == 1) || (count == 2);
-
-	spin_lock_irq(&priv->queue.lock);
-	if (read_idr) {
-		dev_dbg(dev, "Waiting for IBF\n");
-		str = kcs_bmc_read_status(kcs_bmc);
-		if ((filp->f_flags & O_NONBLOCK) && (str & KCS_BMC_STR_IBF)) {
-			rc = -EWOULDBLOCK;
-			goto out;
-		}
-
-		rc = wait_event_interruptible_locked(priv->queue,
-						     priv->readable || (str & KCS_BMC_STR_IBF));
-		if (rc < 0)
-			goto out;
-
-		if (signal_pending(current)) {
-			dev_dbg(dev, "Interrupted waiting for IBF\n");
-			rc = -EINTR;
-			goto out;
-		}
-
-		/*
-		 * Re-enable events prior to possible read of IDR (which clears
-		 * IBF) to ensure we receive interrupts for subsequent writes
-		 * to IDR. Writes to IDR by the host should not occur while IBF
-		 * is set.
-		 */
-		dev_dbg(dev, "Woken by IBF, enabling IRQ\n");
-		kcs_bmc_raw_update_event_mask(priv, KCS_BMC_EVENT_TYPE_IBF,
-					      KCS_BMC_EVENT_TYPE_IBF);
-
-		/* Read data out of IDR into internal storage if necessary */
-		if (!priv->readable) {
-			WARN(!(str & KCS_BMC_STR_IBF), "Unknown reason for wakeup!");
-
-			priv->idr = kcs_bmc_read_data(kcs_bmc);
-		}
-
-		/* Copy data from internal storage to userspace */
-		idr = priv->idr;
-
-		/* We're done consuming the internally stored value */
-		priv->readable = false;
-	}
-
-	if (read_str) {
-		str = kcs_bmc_read_status(kcs_bmc);
-		if (*ppos == 0 || priv->readable)
-			/*
-			 * If we got this far with `*ppos == 0` then we've read
-			 * data out of IDR, so set IBF when reporting back to
-			 * userspace so userspace knows the IDR value is valid.
-			 */
-			str |= KCS_BMC_STR_IBF;
-
-		dev_dbg(dev, "Read status 0x%x\n", str);
-
-	}
-
-	rc = count;
-out:
-	spin_unlock_irq(&priv->queue.lock);
-
-	if (rc < 0)
-		return rc;
-
-	/* Now copy the data in to the userspace buffer */
-
-	if (read_idr)
-		if (copy_to_user(buf++, &idr, sizeof(idr)))
-			return -EFAULT;
-
-	if (read_str)
-		if (copy_to_user(buf, &str, sizeof(str)))
-			return -EFAULT;
-
-	return count;
-}
-
-static ssize_t kcs_bmc_raw_write(struct file *filp, const char __user *buf,
-			      size_t count, loff_t *ppos)
-{
-	struct kcs_bmc_device *kcs_bmc;
-	bool write_odr, write_str;
-	struct kcs_bmc_raw *priv;
-	struct device *dev;
-	ssize_t result;
-	u8 data[2];
-	u8 str;
-
-	priv = file_to_kcs_bmc_raw(filp);
-	kcs_bmc = priv->client.dev;
-	dev = priv->miscdev.this_device;
-
-	if (!count)
-		return count;
-
-	if (count > 2)
-		return -EINVAL;
-
-	if (*ppos >= 2)
-		return -EINVAL;
-
-	if (*ppos + count > 2)
-		return -EINVAL;
-
-	if (copy_from_user(data, buf, count))
-		return -EFAULT;
-
-	write_odr = (*ppos == 0);
-	write_str = (*ppos == 1) || (count == 2);
-
-	spin_lock_irq(&priv->queue.lock);
-
-	/* Always write status before data, we generate the SerIRQ by writing ODR */
-	if (write_str) {
-		/* The index of STR in the userspace buffer depends on whether ODR is written */
-		str = data[*ppos == 0];
-		if (!(str & KCS_BMC_STR_OBF))
-			dev_warn(dev, "Clearing OBF with status write: 0x%x\n", str);
-		dev_dbg(dev, "Writing status 0x%x\n", str);
-		kcs_bmc_write_status(kcs_bmc, str);
-	}
-
-	if (write_odr) {
-		/* If we're writing ODR it's always the first byte in the buffer */
-		u8 odr = data[0];
-
-		str = kcs_bmc_read_status(kcs_bmc);
-		if (str & KCS_BMC_STR_OBF) {
-			if (filp->f_flags & O_NONBLOCK) {
-				result = -EWOULDBLOCK;
-				goto out;
-			}
-
-			priv->writable = kcs_bmc_raw_prepare_obe(priv);
-
-			/* Now either OBF is already clear, or we'll get an OBE event to wake us */
-			dev_dbg(dev, "Waiting for OBF to clear\n");
-			wait_event_interruptible_locked(priv->queue, priv->writable);
-
-			if (signal_pending(current)) {
-				kcs_bmc_raw_update_event_mask(priv, KCS_BMC_EVENT_TYPE_OBE, 0);
-				result = -EINTR;
-				goto out;
-			}
-
-			WARN_ON(kcs_bmc_read_status(kcs_bmc) & KCS_BMC_STR_OBF);
-		}
-
-		dev_dbg(dev, "Writing 0x%x to ODR\n", odr);
-		kcs_bmc_write_data(kcs_bmc, odr);
-	}
-
-	result = count;
-out:
-	spin_unlock_irq(&priv->queue.lock);
-
-	return result;
-}
-
-static int kcs_bmc_raw_release(struct inode *inode, struct file *filp)
-{
-	struct kcs_bmc_raw *priv = file_to_kcs_bmc_raw(filp);
-
-	kcs_bmc_disable_device(priv->client.dev, &priv->client);
-	priv->events = 0;
-
-	return 0;
-}
-
-static const struct file_operations kcs_bmc_raw_fops = {
-	.owner          = THIS_MODULE,
-	.open		= kcs_bmc_raw_open,
-	.llseek		= no_seek_end_llseek,
-	.read           = kcs_bmc_raw_read,
-	.write          = kcs_bmc_raw_write,
-	.poll		= kcs_bmc_raw_poll,
-	.release	= kcs_bmc_raw_release,
-};
-
-static DEFINE_SPINLOCK(kcs_bmc_raw_instances_lock);
-static LIST_HEAD(kcs_bmc_raw_instances);
-
-static int kcs_bmc_raw_add_device(struct kcs_bmc_device *kcs_bmc)
-{
-	struct kcs_bmc_raw *priv;
-	int rc;
-
-	priv = devm_kzalloc(kcs_bmc->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	priv->client.dev = kcs_bmc;
-	priv->client.ops = &kcs_bmc_raw_client_ops;
-
-	init_waitqueue_head(&priv->queue);
-	priv->writable = false;
-	priv->readable = false;
-
-	priv->miscdev.minor = MISC_DYNAMIC_MINOR;
-	priv->miscdev.name = devm_kasprintf(kcs_bmc->dev, GFP_KERNEL, "%s%u", DEVICE_NAME,
-					   kcs_bmc->channel);
-	if (!priv->miscdev.name)
-		return -EINVAL;
-
-	priv->miscdev.fops = &kcs_bmc_raw_fops;
-
-	/* Disable interrupts until userspace opens the the chardev */
-	kcs_bmc_raw_update_event_mask(priv, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);
-
-	rc = misc_register(&priv->miscdev);
-	if (rc) {
-		dev_err(kcs_bmc->dev, "Unable to register device\n");
-		return rc;
-	}
-
-	spin_lock_irq(&kcs_bmc_raw_instances_lock);
-	list_add(&priv->entry, &kcs_bmc_raw_instances);
-	spin_unlock_irq(&kcs_bmc_raw_instances_lock);
-
-	dev_info(kcs_bmc->dev, "Initialised raw client for channel %d", kcs_bmc->channel);
-
-	return 0;
-}
-
-static int kcs_bmc_raw_remove_device(struct kcs_bmc_device *kcs_bmc)
-{
-	struct kcs_bmc_raw *priv = NULL, *pos;
-
-	spin_lock_irq(&kcs_bmc_raw_instances_lock);
-	list_for_each_entry(pos, &kcs_bmc_raw_instances, entry) {
-		if (pos->client.dev == kcs_bmc) {
-			priv = pos;
-			list_del(&pos->entry);
-			break;
-		}
-	}
-	spin_unlock_irq(&kcs_bmc_raw_instances_lock);
-
-	if (!priv)
-		return -ENODEV;
-
-	misc_deregister(&priv->miscdev);
-	kcs_bmc_disable_device(kcs_bmc, &priv->client);
-	devm_kfree(priv->client.dev->dev, priv);
-
-	return 0;
-}
-
-static const struct kcs_bmc_driver_ops kcs_bmc_raw_driver_ops = {
-	.add_device = kcs_bmc_raw_add_device,
-	.remove_device = kcs_bmc_raw_remove_device,
-};
-
-static struct kcs_bmc_driver kcs_bmc_raw_driver = {
-	.ops = &kcs_bmc_raw_driver_ops,
-};
-
-static int kcs_bmc_raw_init(void)
-{
-	kcs_bmc_register_driver(&kcs_bmc_raw_driver);
-
-	return 0;
-}
-module_init(kcs_bmc_raw_init);
-
-static void kcs_bmc_raw_exit(void)
-{
-	kcs_bmc_unregister_driver(&kcs_bmc_raw_driver);
-}
-module_exit(kcs_bmc_raw_exit);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Andrew Jeffery <andrew@aj.id.au>");
-MODULE_DESCRIPTION("Character device for raw access to a KCS device");
diff --git a/drivers/char/ipmi/kcs_bmc_client.h b/drivers/char/ipmi/kcs_bmc_client.h
deleted file mode 100644
index 6fdcde0a7169..000000000000
--- a/drivers/char/ipmi/kcs_bmc_client.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright (c) 2021, IBM Corp. */
-
-#ifndef __KCS_BMC_CONSUMER_H__
-#define __KCS_BMC_CONSUMER_H__
-
-#include <linux/irqreturn.h>
-
-#include "kcs_bmc.h"
-
-struct kcs_bmc_driver_ops {
-	int (*add_device)(struct kcs_bmc_device *kcs_bmc);
-	int (*remove_device)(struct kcs_bmc_device *kcs_bmc);
-};
-
-struct kcs_bmc_driver {
-	struct list_head entry;
-
-	const struct kcs_bmc_driver_ops *ops;
-};
-
-struct kcs_bmc_client_ops {
-	irqreturn_t (*event)(struct kcs_bmc_client *client);
-};
-
-struct kcs_bmc_client {
-	const struct kcs_bmc_client_ops *ops;
-
-	struct kcs_bmc_device *dev;
-};
-
-void kcs_bmc_register_driver(struct kcs_bmc_driver *drv);
-void kcs_bmc_unregister_driver(struct kcs_bmc_driver *drv);
-
-int kcs_bmc_enable_device(struct kcs_bmc_device *kcs_bmc, struct kcs_bmc_client *client);
-void kcs_bmc_disable_device(struct kcs_bmc_device *kcs_bmc, struct kcs_bmc_client *client);
-
-void kcs_bmc_update_event_mask(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 events);
-
-u8 kcs_bmc_read_data(struct kcs_bmc_device *kcs_bmc);
-void kcs_bmc_write_data(struct kcs_bmc_device *kcs_bmc, u8 data);
-u8 kcs_bmc_read_status(struct kcs_bmc_device *kcs_bmc);
-void kcs_bmc_write_status(struct kcs_bmc_device *kcs_bmc, u8 data);
-void kcs_bmc_update_status(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 val);
-#endif
diff --git a/drivers/char/ipmi/kcs_bmc_device.h b/drivers/char/ipmi/kcs_bmc_device.h
deleted file mode 100644
index 17c572f25c54..000000000000
--- a/drivers/char/ipmi/kcs_bmc_device.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright (c) 2021, IBM Corp. */
-
-#ifndef __KCS_BMC_DEVICE_H__
-#define __KCS_BMC_DEVICE_H__
-
-#include <linux/irqreturn.h>
-
-#include "kcs_bmc.h"
-
-struct kcs_bmc_device_ops {
-	void (*irq_mask_update)(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 enable);
-	u8 (*io_inputb)(struct kcs_bmc_device *kcs_bmc, u32 reg);
-	void (*io_outputb)(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 b);
-	void (*io_updateb)(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 mask, u8 b);
-};
-
-irqreturn_t kcs_bmc_handle_event(struct kcs_bmc_device *kcs_bmc);
-int kcs_bmc_add_device(struct kcs_bmc_device *kcs_bmc);
-void kcs_bmc_remove_device(struct kcs_bmc_device *kcs_bmc);
-
-#endif
diff --git a/drivers/char/ipmi/kcs_bmc_npcm7xx.c b/drivers/char/ipmi/kcs_bmc_npcm7xx.c
index 7961fec56476..722f7391fe1f 100644
--- a/drivers/char/ipmi/kcs_bmc_npcm7xx.c
+++ b/drivers/char/ipmi/kcs_bmc_npcm7xx.c
@@ -17,7 +17,7 @@
 #include <linux/regmap.h>
 #include <linux/slab.h>
 
-#include "kcs_bmc_device.h"
+#include "kcs_bmc.h"
 
 #define DEVICE_NAME	"npcm-kcs-bmc"
 #define KCS_CHANNEL_MAX	3
@@ -38,7 +38,6 @@
 #define KCS2CTL		0x2A
 #define KCS3CTL		0x3C
 #define    KCS_CTL_IBFIE	BIT(0)
-#define    KCS_CTL_OBEIE	BIT(1)
 
 #define KCS1IE		0x1C
 #define KCS2IE		0x2E
@@ -66,8 +65,6 @@ struct npcm7xx_kcs_reg {
 };
 
 struct npcm7xx_kcs_bmc {
-	struct kcs_bmc_device kcs_bmc;
-
 	struct regmap *map;
 
 	const struct npcm7xx_kcs_reg *reg;
@@ -79,14 +76,9 @@ static const struct npcm7xx_kcs_reg npcm7xx_kcs_reg_tbl[KCS_CHANNEL_MAX] = {
 	{ .sts = KCS3ST, .dob = KCS3DO, .dib = KCS3DI, .ctl = KCS3CTL, .ie = KCS3IE },
 };
 
-static inline struct npcm7xx_kcs_bmc *to_npcm7xx_kcs_bmc(struct kcs_bmc_device *kcs_bmc)
+static u8 npcm7xx_kcs_inb(struct kcs_bmc *kcs_bmc, u32 reg)
 {
-	return container_of(kcs_bmc, struct npcm7xx_kcs_bmc, kcs_bmc);
-}
-
-static u8 npcm7xx_kcs_inb(struct kcs_bmc_device *kcs_bmc, u32 reg)
-{
-	struct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);
+	struct npcm7xx_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 	u32 val = 0;
 	int rc;
 
@@ -96,53 +88,37 @@ static u8 npcm7xx_kcs_inb(struct kcs_bmc_device *kcs_bmc, u32 reg)
 	return rc == 0 ? (u8)val : 0;
 }
 
-static void npcm7xx_kcs_outb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 data)
+static void npcm7xx_kcs_outb(struct kcs_bmc *kcs_bmc, u32 reg, u8 data)
 {
-	struct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);
+	struct npcm7xx_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 	int rc;
 
 	rc = regmap_write(priv->map, reg, data);
 	WARN(rc != 0, "regmap_write() failed: %d\n", rc);
 }
 
-static void npcm7xx_kcs_updateb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 mask, u8 data)
+static void npcm7xx_kcs_enable_channel(struct kcs_bmc *kcs_bmc, bool enable)
 {
-	struct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);
-	int rc;
+	struct npcm7xx_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 
-	rc = regmap_update_bits(priv->map, reg, mask, data);
-	WARN(rc != 0, "regmap_update_bits() failed: %d\n", rc);
-}
-
-static void npcm7xx_kcs_enable_channel(struct kcs_bmc_device *kcs_bmc, bool enable)
-{
-	struct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);
+	regmap_update_bits(priv->map, priv->reg->ctl, KCS_CTL_IBFIE,
+			   enable ? KCS_CTL_IBFIE : 0);
 
 	regmap_update_bits(priv->map, priv->reg->ie, KCS_IE_IRQE | KCS_IE_HIRQE,
 			   enable ? KCS_IE_IRQE | KCS_IE_HIRQE : 0);
 }
 
-static void npcm7xx_kcs_irq_mask_update(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 state)
-{
-	struct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);
-
-	if (mask & KCS_BMC_EVENT_TYPE_OBE)
-		regmap_update_bits(priv->map, priv->reg->ctl, KCS_CTL_OBEIE,
-				   !!(state & KCS_BMC_EVENT_TYPE_OBE) * KCS_CTL_OBEIE);
-
-	if (mask & KCS_BMC_EVENT_TYPE_IBF)
-		regmap_update_bits(priv->map, priv->reg->ctl, KCS_CTL_IBFIE,
-				   !!(state & KCS_BMC_EVENT_TYPE_IBF) * KCS_CTL_IBFIE);
-}
-
 static irqreturn_t npcm7xx_kcs_irq(int irq, void *arg)
 {
-	struct kcs_bmc_device *kcs_bmc = arg;
+	struct kcs_bmc *kcs_bmc = arg;
 
-	return kcs_bmc_handle_event(kcs_bmc);
+	if (!kcs_bmc_handle_event(kcs_bmc))
+		return IRQ_HANDLED;
+
+	return IRQ_NONE;
 }
 
-static int npcm7xx_kcs_config_irq(struct kcs_bmc_device *kcs_bmc,
+static int npcm7xx_kcs_config_irq(struct kcs_bmc *kcs_bmc,
 				  struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -156,18 +132,11 @@ static int npcm7xx_kcs_config_irq(struct kcs_bmc_device *kcs_bmc,
 				dev_name(dev), kcs_bmc);
 }
 
-static const struct kcs_bmc_device_ops npcm7xx_kcs_ops = {
-	.irq_mask_update = npcm7xx_kcs_irq_mask_update,
-	.io_inputb = npcm7xx_kcs_inb,
-	.io_outputb = npcm7xx_kcs_outb,
-	.io_updateb = npcm7xx_kcs_updateb,
-};
-
 static int npcm7xx_kcs_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct npcm7xx_kcs_bmc *priv;
-	struct kcs_bmc_device *kcs_bmc;
+	struct kcs_bmc *kcs_bmc;
 	u32 chan;
 	int rc;
 
@@ -177,10 +146,11 @@ static int npcm7xx_kcs_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
+	kcs_bmc = kcs_bmc_alloc(dev, sizeof(*priv), chan);
+	if (!kcs_bmc)
 		return -ENOMEM;
 
+	priv = kcs_bmc_priv(kcs_bmc);
 	priv->map = syscon_node_to_regmap(dev->parent->of_node);
 	if (IS_ERR(priv->map)) {
 		dev_err(dev, "Couldn't get regmap\n");
@@ -188,26 +158,22 @@ static int npcm7xx_kcs_probe(struct platform_device *pdev)
 	}
 	priv->reg = &npcm7xx_kcs_reg_tbl[chan - 1];
 
-	kcs_bmc = &priv->kcs_bmc;
-	kcs_bmc->dev = &pdev->dev;
-	kcs_bmc->channel = chan;
 	kcs_bmc->ioreg.idr = priv->reg->dib;
 	kcs_bmc->ioreg.odr = priv->reg->dob;
 	kcs_bmc->ioreg.str = priv->reg->sts;
-	kcs_bmc->ops = &npcm7xx_kcs_ops;
+	kcs_bmc->io_inputb = npcm7xx_kcs_inb;
+	kcs_bmc->io_outputb = npcm7xx_kcs_outb;
 
-	platform_set_drvdata(pdev, priv);
+	dev_set_drvdata(dev, kcs_bmc);
 
+	npcm7xx_kcs_enable_channel(kcs_bmc, true);
 	rc = npcm7xx_kcs_config_irq(kcs_bmc, pdev);
 	if (rc)
 		return rc;
 
-	npcm7xx_kcs_irq_mask_update(kcs_bmc, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);
-	npcm7xx_kcs_enable_channel(kcs_bmc, true);
-
-	rc = kcs_bmc_add_device(kcs_bmc);
+	rc = misc_register(&kcs_bmc->miscdev);
 	if (rc) {
-		dev_warn(&pdev->dev, "Failed to register channel %d: %d\n", kcs_bmc->channel, rc);
+		dev_err(dev, "Unable to register device\n");
 		return rc;
 	}
 
@@ -220,13 +186,9 @@ static int npcm7xx_kcs_probe(struct platform_device *pdev)
 
 static int npcm7xx_kcs_remove(struct platform_device *pdev)
 {
-	struct npcm7xx_kcs_bmc *priv = platform_get_drvdata(pdev);
-	struct kcs_bmc_device *kcs_bmc = &priv->kcs_bmc;
-
-	kcs_bmc_remove_device(kcs_bmc);
+	struct kcs_bmc *kcs_bmc = dev_get_drvdata(&pdev->dev);
 
-	npcm7xx_kcs_enable_channel(kcs_bmc, false);
-	npcm7xx_kcs_irq_mask_update(kcs_bmc, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);
+	misc_deregister(&kcs_bmc->miscdev);
 
 	return 0;
 }
diff --git a/drivers/char/ipmi/kcs_bmc_serio.c b/drivers/char/ipmi/kcs_bmc_serio.c
deleted file mode 100644
index 1793358be782..000000000000
--- a/drivers/char/ipmi/kcs_bmc_serio.c
+++ /dev/null
@@ -1,159 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/* Copyright (c) 2021 IBM Corp. */
-
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/errno.h>
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/sched/signal.h>
-#include <linux/serio.h>
-#include <linux/slab.h>
-
-#include "kcs_bmc_client.h"
-
-struct kcs_bmc_serio {
-	struct list_head entry;
-
-	struct kcs_bmc_client client;
-	struct serio *port;
-
-	spinlock_t lock;
-};
-
-static inline struct kcs_bmc_serio *client_to_kcs_bmc_serio(struct kcs_bmc_client *client)
-{
-	return container_of(client, struct kcs_bmc_serio, client);
-}
-
-static irqreturn_t kcs_bmc_serio_event(struct kcs_bmc_client *client)
-{
-	struct kcs_bmc_serio *priv;
-	u8 handled = IRQ_NONE;
-	u8 status;
-
-	priv = client_to_kcs_bmc_serio(client);
-
-	spin_lock(&priv->lock);
-
-	status = kcs_bmc_read_status(client->dev);
-
-	if (status & KCS_BMC_STR_IBF)
-		handled = serio_interrupt(priv->port, kcs_bmc_read_data(client->dev), 0);
-
-	spin_unlock(&priv->lock);
-
-	return handled;
-}
-
-static const struct kcs_bmc_client_ops kcs_bmc_serio_client_ops = {
-	.event = kcs_bmc_serio_event,
-};
-
-static int kcs_bmc_serio_open(struct serio *port)
-{
-	struct kcs_bmc_serio *priv = port->port_data;
-
-	return kcs_bmc_enable_device(priv->client.dev, &priv->client);
-}
-
-static void kcs_bmc_serio_close(struct serio *port)
-{
-	struct kcs_bmc_serio *priv = port->port_data;
-
-	kcs_bmc_disable_device(priv->client.dev, &priv->client);
-}
-
-static DEFINE_SPINLOCK(kcs_bmc_serio_instances_lock);
-static LIST_HEAD(kcs_bmc_serio_instances);
-
-static int kcs_bmc_serio_add_device(struct kcs_bmc_device *kcs_bmc)
-{
-	struct kcs_bmc_serio *priv;
-	struct serio *port;
-
-	priv = devm_kzalloc(kcs_bmc->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	/* Use kzalloc() as the allocation is cleaned up with kfree() via serio_unregister_port() */
-	port = kzalloc(sizeof(*port), GFP_KERNEL);
-	if (!port)
-		return -ENOMEM;
-
-	port->id.type = SERIO_8042;
-	port->open = kcs_bmc_serio_open;
-	port->close = kcs_bmc_serio_close;
-	port->port_data = priv;
-	port->dev.parent = kcs_bmc->dev;
-
-	spin_lock_init(&priv->lock);
-	priv->port = port;
-	priv->client.dev = kcs_bmc;
-	priv->client.ops = &kcs_bmc_serio_client_ops;
-
-	spin_lock_irq(&kcs_bmc_serio_instances_lock);
-	list_add(&priv->entry, &kcs_bmc_serio_instances);
-	spin_unlock_irq(&kcs_bmc_serio_instances_lock);
-
-	serio_register_port(port);
-
-	dev_info(kcs_bmc->dev, "Initialised serio client for channel %d", kcs_bmc->channel);
-
-	return 0;
-}
-
-static int kcs_bmc_serio_remove_device(struct kcs_bmc_device *kcs_bmc)
-{
-	struct kcs_bmc_serio *priv = NULL, *pos;
-
-	spin_lock_irq(&kcs_bmc_serio_instances_lock);
-	list_for_each_entry(pos, &kcs_bmc_serio_instances, entry) {
-		if (pos->client.dev == kcs_bmc) {
-			priv = pos;
-			list_del(&pos->entry);
-			break;
-		}
-	}
-	spin_unlock_irq(&kcs_bmc_serio_instances_lock);
-
-	if (!priv)
-		return -ENODEV;
-
-	/* kfree()s priv->port via put_device() */
-	serio_unregister_port(priv->port);
-
-	/* Ensure the IBF IRQ is disabled if we were the active client */
-	kcs_bmc_disable_device(kcs_bmc, &priv->client);
-
-	devm_kfree(priv->client.dev->dev, priv);
-
-	return 0;
-}
-
-static const struct kcs_bmc_driver_ops kcs_bmc_serio_driver_ops = {
-	.add_device = kcs_bmc_serio_add_device,
-	.remove_device = kcs_bmc_serio_remove_device,
-};
-
-static struct kcs_bmc_driver kcs_bmc_serio_driver = {
-	.ops = &kcs_bmc_serio_driver_ops,
-};
-
-static int __init kcs_bmc_serio_init(void)
-{
-	kcs_bmc_register_driver(&kcs_bmc_serio_driver);
-
-	return 0;
-}
-module_init(kcs_bmc_serio_init);
-
-static void __exit kcs_bmc_serio_exit(void)
-{
-	kcs_bmc_unregister_driver(&kcs_bmc_serio_driver);
-}
-module_exit(kcs_bmc_serio_exit);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Andrew Jeffery <andrew@aj.id.au>");
-MODULE_DESCRIPTION("Adapter driver for serio access to BMC KCS devices");
diff --git a/drivers/char/ipmi/ssif_bmc.c b/drivers/char/ipmi/ssif_bmc.c
deleted file mode 100644
index caee848261e9..000000000000
--- a/drivers/char/ipmi/ssif_bmc.c
+++ /dev/null
@@ -1,873 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * The driver for BMC side of SSIF interface
- *
- * Copyright (c) 2022, Ampere Computing LLC
- *
- */
-
-#include <linux/i2c.h>
-#include <linux/miscdevice.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/platform_device.h>
-#include <linux/poll.h>
-#include <linux/sched.h>
-#include <linux/mutex.h>
-#include <linux/spinlock.h>
-#include <linux/timer.h>
-#include <linux/jiffies.h>
-#include <linux/ipmi_ssif_bmc.h>
-
-#define DEVICE_NAME                             "ipmi-ssif-host"
-
-#define GET_8BIT_ADDR(addr_7bit)                (((addr_7bit) << 1) & 0xff)
-
-/* A standard SMBus Transaction is limited to 32 data bytes */
-#define MAX_PAYLOAD_PER_TRANSACTION             32
-/* Transaction includes the address, the command, the length and the PEC byte */
-#define MAX_TRANSACTION                         (MAX_PAYLOAD_PER_TRANSACTION + 4)
-
-#define MAX_IPMI_DATA_PER_START_TRANSACTION     30
-#define MAX_IPMI_DATA_PER_MIDDLE_TRANSACTION    31
-
-#define SSIF_IPMI_SINGLEPART_WRITE              0x2
-#define SSIF_IPMI_SINGLEPART_READ               0x3
-#define SSIF_IPMI_MULTIPART_WRITE_START         0x6
-#define SSIF_IPMI_MULTIPART_WRITE_MIDDLE        0x7
-#define SSIF_IPMI_MULTIPART_WRITE_END           0x8
-#define SSIF_IPMI_MULTIPART_READ_START          0x3
-#define SSIF_IPMI_MULTIPART_READ_MIDDLE         0x9
-
-/*
- * IPMI 2.0 Spec, section 12.7 SSIF Timing,
- * Request-to-Response Time is T6max(250ms) - T1max(20ms) - 3ms = 227ms
- * Recover ssif_bmc from busy state if it takes up to 500ms
- */
-#define RESPONSE_TIMEOUT                        500 /* ms */
-
-struct ssif_part_buffer {
-	u8 address;
-	u8 smbus_cmd;
-	u8 length;
-	u8 payload[MAX_PAYLOAD_PER_TRANSACTION];
-	u8 pec;
-	u8 index;
-};
-
-/*
- * SSIF internal states:
- *   SSIF_READY         0x00 : Ready state
- *   SSIF_START         0x01 : Start smbus transaction
- *   SSIF_SMBUS_CMD     0x02 : Received SMBus command
- *   SSIF_REQ_RECVING   0x03 : Receiving request
- *   SSIF_RES_SENDING   0x04 : Sending response
- *   SSIF_ABORTING      0x05 : Aborting state
- */
-enum ssif_state {
-	SSIF_READY,
-	SSIF_START,
-	SSIF_SMBUS_CMD,
-	SSIF_REQ_RECVING,
-	SSIF_RES_SENDING,
-	SSIF_ABORTING,
-	SSIF_STATE_MAX
-};
-
-struct ssif_bmc_ctx {
-	struct i2c_client       *client;
-	struct miscdevice       miscdev;
-	int                     msg_idx;
-	bool                    pec_support;
-	/* ssif bmc spinlock */
-	spinlock_t              lock;
-	wait_queue_head_t       wait_queue;
-	u8                      running;
-	enum ssif_state         state;
-	/* Timeout waiting for response */
-	struct timer_list       response_timer;
-	bool                    response_timer_inited;
-	/* Flag to identify a Multi-part Read Transaction */
-	bool                    is_singlepart_read;
-	u8                      nbytes_processed;
-	u8                      remain_len;
-	u8                      recv_len;
-	/* Block Number of a Multi-part Read Transaction */
-	u8                      block_num;
-	bool                    request_available;
-	bool                    response_in_progress;
-	bool                    busy;
-	bool                    aborting;
-	/* Buffer for SSIF Transaction part*/
-	struct ssif_part_buffer part_buf;
-	struct ipmi_ssif_msg    response;
-	struct ipmi_ssif_msg    request;
-};
-
-static inline struct ssif_bmc_ctx *to_ssif_bmc(struct file *file)
-{
-	return container_of(file->private_data, struct ssif_bmc_ctx, miscdev);
-}
-
-static const char *state_to_string(enum ssif_state state)
-{
-	switch (state) {
-	case SSIF_READY:
-		return "SSIF_READY";
-	case SSIF_START:
-		return "SSIF_START";
-	case SSIF_SMBUS_CMD:
-		return "SSIF_SMBUS_CMD";
-	case SSIF_REQ_RECVING:
-		return "SSIF_REQ_RECVING";
-	case SSIF_RES_SENDING:
-		return "SSIF_RES_SENDING";
-	case SSIF_ABORTING:
-		return "SSIF_ABORTING";
-	default:
-		return "SSIF_STATE_UNKNOWN";
-	}
-}
-
-/* Handle SSIF message that will be sent to user */
-static ssize_t ssif_bmc_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
-{
-	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
-	struct ipmi_ssif_msg msg;
-	unsigned long flags;
-	ssize_t ret;
-
-	spin_lock_irqsave(&ssif_bmc->lock, flags);
-	while (!ssif_bmc->request_available) {
-		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-		if (file->f_flags & O_NONBLOCK)
-			return -EAGAIN;
-		ret = wait_event_interruptible(ssif_bmc->wait_queue,
-					       ssif_bmc->request_available);
-		if (ret)
-			return ret;
-		spin_lock_irqsave(&ssif_bmc->lock, flags);
-	}
-
-	if (count < min_t(ssize_t,
-			  sizeof_field(struct ipmi_ssif_msg, len) + ssif_bmc->request.len,
-			  sizeof(struct ipmi_ssif_msg))) {
-		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-		ret = -EINVAL;
-	} else {
-		count = min_t(ssize_t,
-			      sizeof_field(struct ipmi_ssif_msg, len) + ssif_bmc->request.len,
-			      sizeof(struct ipmi_ssif_msg));
-		memcpy(&msg, &ssif_bmc->request, count);
-		ssif_bmc->request_available = false;
-		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-
-		ret = copy_to_user(buf, &msg, count);
-	}
-
-	return (ret < 0) ? ret : count;
-}
-
-/* Handle SSIF message that is written by user */
-static ssize_t ssif_bmc_write(struct file *file, const char __user *buf, size_t count,
-			      loff_t *ppos)
-{
-	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
-	struct ipmi_ssif_msg msg;
-	unsigned long flags;
-	ssize_t ret;
-
-	if (count > sizeof(struct ipmi_ssif_msg))
-		return -EINVAL;
-
-	if (copy_from_user(&msg, buf, count))
-		return -EFAULT;
-
-	if (!msg.len || count < sizeof_field(struct ipmi_ssif_msg, len) + msg.len)
-		return -EINVAL;
-
-	spin_lock_irqsave(&ssif_bmc->lock, flags);
-	while (ssif_bmc->response_in_progress) {
-		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-		if (file->f_flags & O_NONBLOCK)
-			return -EAGAIN;
-		ret = wait_event_interruptible(ssif_bmc->wait_queue,
-					       !ssif_bmc->response_in_progress);
-		if (ret)
-			return ret;
-		spin_lock_irqsave(&ssif_bmc->lock, flags);
-	}
-
-	/*
-	 * The write must complete before the response timeout fired, otherwise
-	 * the response is aborted and wait for next request
-	 * Return -EINVAL if the response is aborted
-	 */
-	ret = (ssif_bmc->response_timer_inited) ? 0 : -EINVAL;
-	if (ret)
-		goto exit;
-
-	del_timer(&ssif_bmc->response_timer);
-	ssif_bmc->response_timer_inited = false;
-
-	memcpy(&ssif_bmc->response, &msg, count);
-	ssif_bmc->is_singlepart_read = (msg.len <= MAX_PAYLOAD_PER_TRANSACTION);
-
-	ssif_bmc->response_in_progress = true;
-
-	/* ssif_bmc not busy */
-	ssif_bmc->busy = false;
-
-	/* Clean old request buffer */
-	memset(&ssif_bmc->request, 0, sizeof(struct ipmi_ssif_msg));
-exit:
-	spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-
-	return (ret < 0) ? ret : count;
-}
-
-static int ssif_bmc_open(struct inode *inode, struct file *file)
-{
-	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
-	int ret = 0;
-
-	spin_lock_irq(&ssif_bmc->lock);
-	if (!ssif_bmc->running)
-		ssif_bmc->running = 1;
-	else
-		ret = -EBUSY;
-	spin_unlock_irq(&ssif_bmc->lock);
-
-	return ret;
-}
-
-static __poll_t ssif_bmc_poll(struct file *file, poll_table *wait)
-{
-	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
-	__poll_t mask = 0;
-
-	poll_wait(file, &ssif_bmc->wait_queue, wait);
-
-	spin_lock_irq(&ssif_bmc->lock);
-	/* The request is available, userspace application can get the request */
-	if (ssif_bmc->request_available)
-		mask |= EPOLLIN;
-
-	spin_unlock_irq(&ssif_bmc->lock);
-
-	return mask;
-}
-
-static int ssif_bmc_release(struct inode *inode, struct file *file)
-{
-	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
-
-	spin_lock_irq(&ssif_bmc->lock);
-	ssif_bmc->running = 0;
-	spin_unlock_irq(&ssif_bmc->lock);
-
-	return 0;
-}
-
-/*
- * System calls to device interface for user apps
- */
-static const struct file_operations ssif_bmc_fops = {
-	.owner		= THIS_MODULE,
-	.open		= ssif_bmc_open,
-	.read		= ssif_bmc_read,
-	.write		= ssif_bmc_write,
-	.release	= ssif_bmc_release,
-	.poll		= ssif_bmc_poll,
-};
-
-/* Called with ssif_bmc->lock held. */
-static void complete_response(struct ssif_bmc_ctx *ssif_bmc)
-{
-	/* Invalidate response in buffer to denote it having been sent. */
-	ssif_bmc->response.len = 0;
-	ssif_bmc->response_in_progress = false;
-	ssif_bmc->nbytes_processed = 0;
-	ssif_bmc->remain_len = 0;
-	ssif_bmc->busy = false;
-	memset(&ssif_bmc->part_buf, 0, sizeof(struct ssif_part_buffer));
-	wake_up_all(&ssif_bmc->wait_queue);
-}
-
-static void response_timeout(struct timer_list *t)
-{
-	struct ssif_bmc_ctx *ssif_bmc = from_timer(ssif_bmc, t, response_timer);
-	unsigned long flags;
-
-	spin_lock_irqsave(&ssif_bmc->lock, flags);
-
-	/* Do nothing if the response is in progress */
-	if (!ssif_bmc->response_in_progress) {
-		/* Recover ssif_bmc from busy */
-		ssif_bmc->busy = false;
-		ssif_bmc->response_timer_inited = false;
-		/* Set aborting flag */
-		ssif_bmc->aborting = true;
-	}
-
-	spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-}
-
-/* Called with ssif_bmc->lock held. */
-static void handle_request(struct ssif_bmc_ctx *ssif_bmc)
-{
-	/* set ssif_bmc to busy waiting for response */
-	ssif_bmc->busy = true;
-	/* Request message is available to process */
-	ssif_bmc->request_available = true;
-	/* Clean old response buffer */
-	memset(&ssif_bmc->response, 0, sizeof(struct ipmi_ssif_msg));
-	/* This is the new READ request.*/
-	wake_up_all(&ssif_bmc->wait_queue);
-
-	/* Armed timer to recover slave from busy state in case of no response */
-	if (!ssif_bmc->response_timer_inited) {
-		timer_setup(&ssif_bmc->response_timer, response_timeout, 0);
-		ssif_bmc->response_timer_inited = true;
-	}
-	mod_timer(&ssif_bmc->response_timer, jiffies + msecs_to_jiffies(RESPONSE_TIMEOUT));
-}
-
-static void calculate_response_part_pec(struct ssif_part_buffer *part)
-{
-	u8 addr = part->address;
-
-	/* PEC - Start Read Address */
-	part->pec = i2c_smbus_pec(0, &addr, 1);
-	/* PEC - SSIF Command */
-	part->pec = i2c_smbus_pec(part->pec, &part->smbus_cmd, 1);
-	/* PEC - Restart Write Address */
-	addr = addr | 0x01;
-	part->pec = i2c_smbus_pec(part->pec, &addr, 1);
-	part->pec = i2c_smbus_pec(part->pec, &part->length, 1);
-	if (part->length)
-		part->pec = i2c_smbus_pec(part->pec, part->payload, part->length);
-}
-
-static void set_singlepart_response_buffer(struct ssif_bmc_ctx *ssif_bmc)
-{
-	struct ssif_part_buffer *part = &ssif_bmc->part_buf;
-
-	part->address = GET_8BIT_ADDR(ssif_bmc->client->addr);
-	part->length = (u8)ssif_bmc->response.len;
-
-	/* Clear the rest to 0 */
-	memset(part->payload + part->length, 0, MAX_PAYLOAD_PER_TRANSACTION - part->length);
-	memcpy(&part->payload[0], &ssif_bmc->response.payload[0], part->length);
-}
-
-static void set_multipart_response_buffer(struct ssif_bmc_ctx *ssif_bmc)
-{
-	struct ssif_part_buffer *part = &ssif_bmc->part_buf;
-	u8 part_len = 0;
-
-	part->address = GET_8BIT_ADDR(ssif_bmc->client->addr);
-	switch (part->smbus_cmd) {
-	case SSIF_IPMI_MULTIPART_READ_START:
-		/*
-		 * Read Start length is 32 bytes.
-		 * Read Start transfer first 30 bytes of IPMI response
-		 * and 2 special code 0x00, 0x01.
-		 */
-		ssif_bmc->nbytes_processed = 0;
-		ssif_bmc->block_num = 0;
-		part->length = MAX_PAYLOAD_PER_TRANSACTION;
-		part_len = MAX_IPMI_DATA_PER_START_TRANSACTION;
-		ssif_bmc->remain_len = ssif_bmc->response.len - part_len;
-
-		part->payload[0] = 0x00; /* Start Flag */
-		part->payload[1] = 0x01; /* Start Flag */
-
-		memcpy(&part->payload[2], &ssif_bmc->response.payload[0], part_len);
-		break;
-
-	case SSIF_IPMI_MULTIPART_READ_MIDDLE:
-		/*
-		 * IPMI READ Middle or READ End messages can carry up to 31 bytes
-		 * IPMI data plus block number byte.
-		 */
-		if (ssif_bmc->remain_len <= MAX_IPMI_DATA_PER_MIDDLE_TRANSACTION) {
-			/*
-			 * This is READ End message
-			 *  Return length is the remaining response data length
-			 *  plus block number
-			 *  Block number 0xFF is to indicate this is last message
-			 *
-			 */
-			/* Clean the buffer */
-			memset(&part->payload[0], 0, MAX_PAYLOAD_PER_TRANSACTION);
-			part->length = ssif_bmc->remain_len + 1;
-			part_len = ssif_bmc->remain_len;
-			ssif_bmc->block_num = 0xFF;
-			part->payload[0] = ssif_bmc->block_num;
-		} else {
-			/*
-			 * This is READ Middle message
-			 *  Response length is the maximum SMBUS transfer length
-			 *  Block number byte is incremented
-			 * Return length is maximum SMBUS transfer length
-			 */
-			part->length = MAX_PAYLOAD_PER_TRANSACTION;
-			part_len = MAX_IPMI_DATA_PER_MIDDLE_TRANSACTION;
-			part->payload[0] = ssif_bmc->block_num;
-			ssif_bmc->block_num++;
-		}
-
-		ssif_bmc->remain_len -= part_len;
-		memcpy(&part->payload[1], ssif_bmc->response.payload + ssif_bmc->nbytes_processed,
-		       part_len);
-		break;
-
-	default:
-		/* Do not expect to go to this case */
-		dev_err(&ssif_bmc->client->dev, "%s: Unexpected SMBus command 0x%x\n",
-			__func__, part->smbus_cmd);
-		break;
-	}
-
-	ssif_bmc->nbytes_processed += part_len;
-}
-
-static bool supported_read_cmd(u8 cmd)
-{
-	if (cmd == SSIF_IPMI_SINGLEPART_READ ||
-	    cmd == SSIF_IPMI_MULTIPART_READ_START ||
-	    cmd == SSIF_IPMI_MULTIPART_READ_MIDDLE)
-		return true;
-
-	return false;
-}
-
-static bool supported_write_cmd(u8 cmd)
-{
-	if (cmd == SSIF_IPMI_SINGLEPART_WRITE ||
-	    cmd == SSIF_IPMI_MULTIPART_WRITE_START ||
-	    cmd == SSIF_IPMI_MULTIPART_WRITE_MIDDLE ||
-	    cmd == SSIF_IPMI_MULTIPART_WRITE_END)
-		return true;
-
-	return false;
-}
-
-/* Process the IPMI response that will be read by master */
-static void handle_read_processed(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
-{
-	struct ssif_part_buffer *part = &ssif_bmc->part_buf;
-
-	/* msg_idx start from 0 */
-	if (part->index < part->length)
-		*val = part->payload[part->index];
-	else if (part->index == part->length && ssif_bmc->pec_support)
-		*val = part->pec;
-	else
-		*val = 0;
-
-	part->index++;
-}
-
-static void handle_write_received(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
-{
-	/*
-	 * The msg_idx must be 1 when first enter SSIF_REQ_RECVING state
-	 * And it would never exceeded 36 bytes included the 32 bytes max payload +
-	 * the address + the command + the len and the PEC.
-	 */
-	if (ssif_bmc->msg_idx < 1  || ssif_bmc->msg_idx > MAX_TRANSACTION)
-		return;
-
-	if (ssif_bmc->msg_idx == 1) {
-		ssif_bmc->part_buf.length = *val;
-		ssif_bmc->part_buf.index = 0;
-	} else {
-		ssif_bmc->part_buf.payload[ssif_bmc->part_buf.index++] = *val;
-	}
-
-	ssif_bmc->msg_idx++;
-}
-
-static bool validate_request_part(struct ssif_bmc_ctx *ssif_bmc)
-{
-	struct ssif_part_buffer *part = &ssif_bmc->part_buf;
-	bool ret = true;
-	u8 cpec;
-	u8 addr;
-
-	if (part->index == part->length) {
-		/* PEC is not included */
-		ssif_bmc->pec_support = false;
-		ret = true;
-		goto exit;
-	}
-
-	if (part->index != part->length + 1) {
-		ret = false;
-		goto exit;
-	}
-
-	/* PEC is included */
-	ssif_bmc->pec_support = true;
-	part->pec = part->payload[part->length];
-	addr = GET_8BIT_ADDR(ssif_bmc->client->addr);
-	cpec = i2c_smbus_pec(0, &addr, 1);
-	cpec = i2c_smbus_pec(cpec, &part->smbus_cmd, 1);
-	cpec = i2c_smbus_pec(cpec, &part->length, 1);
-	/*
-	 * As SMBus specification does not allow the length
-	 * (byte count) in the Write-Block protocol to be zero.
-	 * Therefore, it is illegal to have the last Middle
-	 * transaction in the sequence carry 32-byte and have
-	 * a length of ‘0’ in the End transaction.
-	 * But some users may try to use this way and we should
-	 * prevent ssif_bmc driver broken in this case.
-	 */
-	if (part->length)
-		cpec = i2c_smbus_pec(cpec, part->payload, part->length);
-
-	if (cpec != part->pec)
-		ret = false;
-
-exit:
-	return ret;
-}
-
-static void process_request_part(struct ssif_bmc_ctx *ssif_bmc)
-{
-	struct ssif_part_buffer *part = &ssif_bmc->part_buf;
-	unsigned int len;
-
-	switch (part->smbus_cmd) {
-	case SSIF_IPMI_SINGLEPART_WRITE:
-		/* save the whole part to request*/
-		ssif_bmc->request.len = part->length;
-		memcpy(ssif_bmc->request.payload, part->payload, part->length);
-
-		break;
-	case SSIF_IPMI_MULTIPART_WRITE_START:
-		ssif_bmc->request.len = 0;
-
-		fallthrough;
-	case SSIF_IPMI_MULTIPART_WRITE_MIDDLE:
-	case SSIF_IPMI_MULTIPART_WRITE_END:
-		len = ssif_bmc->request.len + part->length;
-		/* Do the bound check here, not allow the request len exceed 254 bytes */
-		if (len > IPMI_SSIF_PAYLOAD_MAX) {
-			dev_warn(&ssif_bmc->client->dev,
-				 "Warn: Request exceeded 254 bytes, aborting");
-			/* Request too long, aborting */
-			ssif_bmc->aborting =  true;
-		} else {
-			memcpy(ssif_bmc->request.payload + ssif_bmc->request.len,
-			       part->payload, part->length);
-			ssif_bmc->request.len += part->length;
-		}
-		break;
-	default:
-		/* Do not expect to go to this case */
-		dev_err(&ssif_bmc->client->dev, "%s: Unexpected SMBus command 0x%x\n",
-			__func__, part->smbus_cmd);
-		break;
-	}
-}
-
-static void process_smbus_cmd(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
-{
-	/* SMBUS command can vary (single or multi-part) */
-	ssif_bmc->part_buf.smbus_cmd = *val;
-	ssif_bmc->msg_idx = 1;
-	memset(&ssif_bmc->part_buf.payload[0], 0, MAX_PAYLOAD_PER_TRANSACTION);
-
-	if (*val == SSIF_IPMI_SINGLEPART_WRITE || *val == SSIF_IPMI_MULTIPART_WRITE_START) {
-		/*
-		 * The response maybe not come in-time, causing host SSIF driver
-		 * to timeout and resend a new request. In such case check for
-		 * pending response and clear it
-		 */
-		if (ssif_bmc->response_in_progress)
-			complete_response(ssif_bmc);
-
-		/* This is new request, flip aborting flag if set */
-		if (ssif_bmc->aborting)
-			ssif_bmc->aborting = false;
-	}
-}
-
-static void on_read_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
-{
-	if (ssif_bmc->state == SSIF_READY ||
-	    ssif_bmc->state == SSIF_START ||
-	    ssif_bmc->state == SSIF_REQ_RECVING ||
-	    ssif_bmc->state == SSIF_RES_SENDING) {
-		dev_warn(&ssif_bmc->client->dev,
-			 "Warn: %s unexpected READ REQUESTED in state=%s\n",
-			 __func__, state_to_string(ssif_bmc->state));
-		ssif_bmc->state = SSIF_ABORTING;
-		*val = 0;
-		return;
-
-	} else if (ssif_bmc->state == SSIF_SMBUS_CMD) {
-		if (!supported_read_cmd(ssif_bmc->part_buf.smbus_cmd)) {
-			dev_warn(&ssif_bmc->client->dev, "Warn: Unknown SMBus read command=0x%x",
-				 ssif_bmc->part_buf.smbus_cmd);
-			ssif_bmc->aborting = true;
-		}
-
-		if (ssif_bmc->aborting)
-			ssif_bmc->state = SSIF_ABORTING;
-		else
-			ssif_bmc->state = SSIF_RES_SENDING;
-	}
-
-	ssif_bmc->msg_idx = 0;
-
-	/* Send 0 if there is nothing to send */
-	if (!ssif_bmc->response_in_progress || ssif_bmc->state == SSIF_ABORTING) {
-		*val = 0;
-		return;
-	}
-
-	if (ssif_bmc->is_singlepart_read)
-		set_singlepart_response_buffer(ssif_bmc);
-	else
-		set_multipart_response_buffer(ssif_bmc);
-
-	calculate_response_part_pec(&ssif_bmc->part_buf);
-	ssif_bmc->part_buf.index = 0;
-	*val = ssif_bmc->part_buf.length;
-}
-
-static void on_read_processed_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
-{
-	if (ssif_bmc->state == SSIF_READY ||
-	    ssif_bmc->state == SSIF_START ||
-	    ssif_bmc->state == SSIF_REQ_RECVING ||
-	    ssif_bmc->state == SSIF_SMBUS_CMD) {
-		dev_warn(&ssif_bmc->client->dev,
-			 "Warn: %s unexpected READ PROCESSED in state=%s\n",
-			 __func__, state_to_string(ssif_bmc->state));
-		ssif_bmc->state = SSIF_ABORTING;
-		*val = 0;
-		return;
-	}
-
-	/* Send 0 if there is nothing to send */
-	if (!ssif_bmc->response_in_progress || ssif_bmc->state == SSIF_ABORTING) {
-		*val = 0;
-		return;
-	}
-
-	handle_read_processed(ssif_bmc, val);
-}
-
-static void on_write_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
-{
-	if (ssif_bmc->state == SSIF_READY || ssif_bmc->state == SSIF_SMBUS_CMD) {
-		ssif_bmc->state = SSIF_START;
-
-	} else if (ssif_bmc->state == SSIF_START ||
-		   ssif_bmc->state == SSIF_REQ_RECVING ||
-		   ssif_bmc->state == SSIF_RES_SENDING) {
-		dev_warn(&ssif_bmc->client->dev,
-			 "Warn: %s unexpected WRITE REQUEST in state=%s\n",
-			 __func__, state_to_string(ssif_bmc->state));
-		ssif_bmc->state = SSIF_ABORTING;
-		return;
-	}
-
-	ssif_bmc->msg_idx = 0;
-	ssif_bmc->part_buf.address = *val;
-}
-
-static void on_write_received_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
-{
-	if (ssif_bmc->state == SSIF_READY ||
-	    ssif_bmc->state == SSIF_RES_SENDING) {
-		dev_warn(&ssif_bmc->client->dev,
-			 "Warn: %s unexpected WRITE RECEIVED in state=%s\n",
-			 __func__, state_to_string(ssif_bmc->state));
-		ssif_bmc->state = SSIF_ABORTING;
-
-	} else if (ssif_bmc->state == SSIF_START) {
-		ssif_bmc->state = SSIF_SMBUS_CMD;
-
-	} else if (ssif_bmc->state == SSIF_SMBUS_CMD) {
-		if (!supported_write_cmd(ssif_bmc->part_buf.smbus_cmd)) {
-			dev_warn(&ssif_bmc->client->dev, "Warn: Unknown SMBus write command=0x%x",
-				 ssif_bmc->part_buf.smbus_cmd);
-			ssif_bmc->aborting = true;
-		}
-
-		if (ssif_bmc->aborting)
-			ssif_bmc->state = SSIF_ABORTING;
-		else
-			ssif_bmc->state = SSIF_REQ_RECVING;
-	}
-
-	/* This is response sending state */
-	if (ssif_bmc->state == SSIF_REQ_RECVING)
-		handle_write_received(ssif_bmc, val);
-	else if (ssif_bmc->state == SSIF_SMBUS_CMD)
-		process_smbus_cmd(ssif_bmc, val);
-}
-
-static void on_stop_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
-{
-	if (ssif_bmc->state == SSIF_READY ||
-	    ssif_bmc->state == SSIF_START ||
-	    ssif_bmc->state == SSIF_SMBUS_CMD ||
-	    ssif_bmc->state == SSIF_ABORTING) {
-		dev_warn(&ssif_bmc->client->dev,
-			 "Warn: %s unexpected SLAVE STOP in state=%s\n",
-			 __func__, state_to_string(ssif_bmc->state));
-		ssif_bmc->state = SSIF_READY;
-
-	} else if (ssif_bmc->state == SSIF_REQ_RECVING) {
-		if (validate_request_part(ssif_bmc)) {
-			process_request_part(ssif_bmc);
-			if (ssif_bmc->part_buf.smbus_cmd == SSIF_IPMI_SINGLEPART_WRITE ||
-			    ssif_bmc->part_buf.smbus_cmd == SSIF_IPMI_MULTIPART_WRITE_END)
-				handle_request(ssif_bmc);
-			ssif_bmc->state = SSIF_READY;
-		} else {
-			/*
-			 * A BMC that receives an invalid request drop the data for the write
-			 * transaction and any further transactions (read or write) until
-			 * the next valid read or write Start transaction is received
-			 */
-			dev_err(&ssif_bmc->client->dev, "Error: invalid pec\n");
-			ssif_bmc->aborting = true;
-		}
-	} else if (ssif_bmc->state == SSIF_RES_SENDING) {
-		if (ssif_bmc->is_singlepart_read || ssif_bmc->block_num == 0xFF)
-			/* Invalidate response buffer to denote it is sent */
-			complete_response(ssif_bmc);
-		ssif_bmc->state = SSIF_READY;
-	}
-
-	/* Reset message index */
-	ssif_bmc->msg_idx = 0;
-}
-
-/*
- * Callback function to handle I2C slave events
- */
-static int ssif_bmc_cb(struct i2c_client *client, enum i2c_slave_event event, u8 *val)
-{
-	unsigned long flags;
-	struct ssif_bmc_ctx *ssif_bmc = i2c_get_clientdata(client);
-	int ret = 0;
-
-	spin_lock_irqsave(&ssif_bmc->lock, flags);
-
-	switch (event) {
-	case I2C_SLAVE_READ_REQUESTED:
-		on_read_requested_event(ssif_bmc, val);
-		break;
-
-	case I2C_SLAVE_WRITE_REQUESTED:
-		on_write_requested_event(ssif_bmc, val);
-		break;
-
-	case I2C_SLAVE_READ_PROCESSED:
-		on_read_processed_event(ssif_bmc, val);
-		break;
-
-	case I2C_SLAVE_WRITE_RECEIVED:
-		on_write_received_event(ssif_bmc, val);
-		break;
-
-	case I2C_SLAVE_STOP:
-		on_stop_event(ssif_bmc, val);
-		break;
-
-	default:
-		dev_warn(&ssif_bmc->client->dev, "Warn: Unknown i2c slave event\n");
-		break;
-	}
-
-	if (!ssif_bmc->aborting && ssif_bmc->busy)
-		ret = -EBUSY;
-
-	spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-
-	return ret;
-}
-
-static int ssif_bmc_probe(struct i2c_client *client)
-{
-	struct ssif_bmc_ctx *ssif_bmc;
-	int ret;
-
-	ssif_bmc = devm_kzalloc(&client->dev, sizeof(*ssif_bmc), GFP_KERNEL);
-	if (!ssif_bmc)
-		return -ENOMEM;
-
-	spin_lock_init(&ssif_bmc->lock);
-
-	init_waitqueue_head(&ssif_bmc->wait_queue);
-	ssif_bmc->request_available = false;
-	ssif_bmc->response_in_progress = false;
-	ssif_bmc->busy = false;
-	ssif_bmc->response_timer_inited = false;
-
-	/* Register misc device interface */
-	ssif_bmc->miscdev.minor = MISC_DYNAMIC_MINOR;
-	ssif_bmc->miscdev.name = DEVICE_NAME;
-	ssif_bmc->miscdev.fops = &ssif_bmc_fops;
-	ssif_bmc->miscdev.parent = &client->dev;
-	ret = misc_register(&ssif_bmc->miscdev);
-	if (ret)
-		return ret;
-
-	ssif_bmc->client = client;
-	ssif_bmc->client->flags |= I2C_CLIENT_SLAVE;
-
-	/* Register I2C slave */
-	i2c_set_clientdata(client, ssif_bmc);
-	ret = i2c_slave_register(client, ssif_bmc_cb);
-	if (ret)
-		misc_deregister(&ssif_bmc->miscdev);
-
-	return ret;
-}
-
-static void ssif_bmc_remove(struct i2c_client *client)
-{
-	struct ssif_bmc_ctx *ssif_bmc = i2c_get_clientdata(client);
-
-	i2c_slave_unregister(client);
-	misc_deregister(&ssif_bmc->miscdev);
-}
-
-static const struct of_device_id ssif_bmc_match[] = {
-	{ .compatible = "ssif-bmc" },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, ssif_bmc_match);
-
-static const struct i2c_device_id ssif_bmc_id[] = {
-	{ DEVICE_NAME, 0 },
-	{ },
-};
-MODULE_DEVICE_TABLE(i2c, ssif_bmc_id);
-
-static struct i2c_driver ssif_bmc_driver = {
-	.driver         = {
-		.name           = DEVICE_NAME,
-		.of_match_table = ssif_bmc_match,
-	},
-	.probe_new      = ssif_bmc_probe,
-	.remove         = ssif_bmc_remove,
-	.id_table       = ssif_bmc_id,
-};
-
-module_i2c_driver(ssif_bmc_driver);
-
-MODULE_AUTHOR("Quan Nguyen <quan@os.amperecomputing.com>");
-MODULE_AUTHOR("Chuong Tran <chuong@os.amperecomputing.com>");
-MODULE_DESCRIPTION("Linux device driver of the BMC IPMI SSIF interface.");
-MODULE_LICENSE("GPL");
-- 
2.25.1

