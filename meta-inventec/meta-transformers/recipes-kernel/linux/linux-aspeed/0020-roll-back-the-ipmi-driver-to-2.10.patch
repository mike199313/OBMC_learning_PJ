From 3cf30fe5535a807534e8e462a884090184a427dd Mon Sep 17 00:00:00 2001
From: "Fred.Chang" <chang.fredys@inventec.com>
Date: Wed, 22 Jun 2022 16:14:08 +0800
Subject: [PATCH] roll back the ipmi driver to 2.10.

---
 drivers/char/ipmi/Kconfig             |  44 --
 drivers/char/ipmi/Makefile            |   3 -
 drivers/char/ipmi/bt-bmc.c            |  74 ++-
 drivers/char/ipmi/ipmb_dev_int.c      |  24 +-
 drivers/char/ipmi/ipmi_bt_sm.c        |   0
 drivers/char/ipmi/ipmi_devintf.c      |   1 +
 drivers/char/ipmi/ipmi_dmi.c          |   0
 drivers/char/ipmi/ipmi_dmi.h          |   0
 drivers/char/ipmi/ipmi_kcs_sm.c       |   0
 drivers/char/ipmi/ipmi_msghandler.c   |  74 +--
 drivers/char/ipmi/ipmi_plat_data.c    |   2 +-
 drivers/char/ipmi/ipmi_plat_data.h    |   0
 drivers/char/ipmi/ipmi_powernv.c      |   0
 drivers/char/ipmi/ipmi_poweroff.c     |   0
 drivers/char/ipmi/ipmi_si.h           |  10 +-
 drivers/char/ipmi/ipmi_si_hardcode.c  |  73 ++-
 drivers/char/ipmi/ipmi_si_hotmod.c    |  24 +-
 drivers/char/ipmi/ipmi_si_intf.c      |  67 ++-
 drivers/char/ipmi/ipmi_si_mem_io.c    |   0
 drivers/char/ipmi/ipmi_si_parisc.c    |   4 +-
 drivers/char/ipmi/ipmi_si_pci.c       |  22 +-
 drivers/char/ipmi/ipmi_si_platform.c  |  99 ++--
 drivers/char/ipmi/ipmi_si_port_io.c   |   0
 drivers/char/ipmi/ipmi_si_sm.h        |   0
 drivers/char/ipmi/ipmi_smic_sm.c      |   0
 drivers/char/ipmi/ipmi_ssif.c         |  81 +++-
 drivers/char/ipmi/ipmi_watchdog.c     |  47 +-
 drivers/char/ipmi/kcs_bmc.c           | 505 +++++++++++++++-----
 drivers/char/ipmi/kcs_bmc.h           |  92 +++-
 drivers/char/ipmi/kcs_bmc_aspeed.c    | 635 +++++++-------------------
 drivers/char/ipmi/kcs_bmc_cdev_ipmi.c | 568 -----------------------
 drivers/char/ipmi/kcs_bmc_cdev_raw.c  | 447 ------------------
 drivers/char/ipmi/kcs_bmc_client.h    |  45 --
 drivers/char/ipmi/kcs_bmc_device.h    |  22 -
 drivers/char/ipmi/kcs_bmc_npcm7xx.c   |  92 ++--
 drivers/char/ipmi/kcs_bmc_serio.c     | 159 -------
 36 files changed, 1042 insertions(+), 2172 deletions(-)
 mode change 100644 => 100755 drivers/char/ipmi/Kconfig
 mode change 100644 => 100755 drivers/char/ipmi/Makefile
 mode change 100644 => 100755 drivers/char/ipmi/bt-bmc.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmb_dev_int.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_bt_sm.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_devintf.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_dmi.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_dmi.h
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_kcs_sm.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_msghandler.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_plat_data.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_plat_data.h
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_powernv.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_poweroff.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_si.h
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_si_hardcode.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_si_hotmod.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_si_intf.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_si_mem_io.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_si_parisc.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_si_pci.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_si_platform.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_si_port_io.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_si_sm.h
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_smic_sm.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_ssif.c
 mode change 100644 => 100755 drivers/char/ipmi/ipmi_watchdog.c
 mode change 100644 => 100755 drivers/char/ipmi/kcs_bmc.c
 mode change 100644 => 100755 drivers/char/ipmi/kcs_bmc.h
 mode change 100644 => 100755 drivers/char/ipmi/kcs_bmc_aspeed.c
 delete mode 100644 drivers/char/ipmi/kcs_bmc_cdev_ipmi.c
 delete mode 100644 drivers/char/ipmi/kcs_bmc_cdev_raw.c
 delete mode 100644 drivers/char/ipmi/kcs_bmc_client.h
 delete mode 100644 drivers/char/ipmi/kcs_bmc_device.h
 mode change 100644 => 100755 drivers/char/ipmi/kcs_bmc_npcm7xx.c
 delete mode 100644 drivers/char/ipmi/kcs_bmc_serio.c

diff --git a/drivers/char/ipmi/Kconfig b/drivers/char/ipmi/Kconfig
old mode 100644
new mode 100755
index 19f1efc0bc3d..07847d9a459a
--- a/drivers/char/ipmi/Kconfig
+++ b/drivers/char/ipmi/Kconfig
@@ -124,50 +124,6 @@ config NPCM7XX_KCS_IPMI_BMC
 	  This support is also available as a module.  If so, the module
 	  will be called kcs_bmc_npcm7xx.
 
-config IPMI_KCS_BMC_CDEV_IPMI
-	depends on IPMI_KCS_BMC
-	tristate "IPMI character device interface for BMC KCS devices"
-	help
-	  Provides a BMC-side character device implementing IPMI
-	  semantics for KCS IPMI devices.
-
-	  Say YES if you wish to expose KCS devices on the BMC for IPMI
-	  purposes.
-
-	  This support is also available as a module. The module will be
-	  called kcs_bmc_cdev_ipmi.
-
-config IPMI_KCS_BMC_SERIO
-	depends on IPMI_KCS_BMC && SERIO
-	tristate "SerIO adaptor for BMC KCS devices"
-	help
-	  Adapts the BMC KCS device for the SerIO subsystem. This allows users
-	  to take advantage of userspace interfaces provided by SerIO where
-	  appropriate.
-
-	  Say YES if you wish to expose KCS devices on the BMC via SerIO
-	  interfaces.
-
-	  This support is also available as a module. The module will be
-	  called kcs_bmc_serio.
-
-config IPMI_KCS_BMC_CDEV_RAW
-	depends on IPMI_KCS_BMC
-	tristate "Raw character device interface for BMC KCS devices"
-	help
-	  Provides a BMC-side character device directly exposing the
-	  data and status registers of a KCS device to userspace. While
-	  KCS devices are commonly used to implement IPMI message
-	  passing, they provide a general interface for exchange of
-	  interrupts, data and status information between the BMC and
-	  its host.
-
-	  Say YES if you wish to use the KCS devices to implement
-	  protocols that are not IPMI.
-
-	  This support is also available as a module. The module will be
-	  called kcs_bmc_cdev_raw.
-
 config ASPEED_BT_IPMI_BMC
 	depends on ARCH_ASPEED || COMPILE_TEST
 	depends on REGMAP && REGMAP_MMIO && MFD_SYSCON
diff --git a/drivers/char/ipmi/Makefile b/drivers/char/ipmi/Makefile
old mode 100644
new mode 100755
index 3390985b4802..0822adc2ec41
--- a/drivers/char/ipmi/Makefile
+++ b/drivers/char/ipmi/Makefile
@@ -23,9 +23,6 @@ obj-$(CONFIG_IPMI_POWERNV) += ipmi_powernv.o
 obj-$(CONFIG_IPMI_WATCHDOG) += ipmi_watchdog.o
 obj-$(CONFIG_IPMI_POWEROFF) += ipmi_poweroff.o
 obj-$(CONFIG_IPMI_KCS_BMC) += kcs_bmc.o
-obj-$(CONFIG_IPMI_KCS_BMC_SERIO) += kcs_bmc_serio.o
-obj-$(CONFIG_IPMI_KCS_BMC_CDEV_IPMI) += kcs_bmc_cdev_ipmi.o
-obj-$(CONFIG_IPMI_KCS_BMC_CDEV_RAW) += kcs_bmc_cdev_raw.o
 obj-$(CONFIG_ASPEED_BT_IPMI_BMC) += bt-bmc.o
 obj-$(CONFIG_ASPEED_KCS_IPMI_BMC) += kcs_bmc_aspeed.o
 obj-$(CONFIG_NPCM7XX_KCS_IPMI_BMC) += kcs_bmc_npcm7xx.o
diff --git a/drivers/char/ipmi/bt-bmc.c b/drivers/char/ipmi/bt-bmc.c
old mode 100644
new mode 100755
index 7450904e330a..a514f531cb34
--- a/drivers/char/ipmi/bt-bmc.c
+++ b/drivers/char/ipmi/bt-bmc.c
@@ -8,11 +8,13 @@
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
+#include <linux/mfd/syscon.h>
 #include <linux/miscdevice.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/poll.h>
+#include <linux/regmap.h>
 #include <linux/sched.h>
 #include <linux/timer.h>
 
@@ -57,7 +59,8 @@
 struct bt_bmc {
 	struct device		dev;
 	struct miscdevice	miscdev;
-	void __iomem		*base;
+	struct regmap		*map;
+	int			offset;
 	int			irq;
 	wait_queue_head_t	queue;
 	struct timer_list	poll_timer;
@@ -66,14 +69,29 @@ struct bt_bmc {
 
 static atomic_t open_count = ATOMIC_INIT(0);
 
+static const struct regmap_config bt_regmap_cfg = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+};
+
 static u8 bt_inb(struct bt_bmc *bt_bmc, int reg)
 {
-	return readb(bt_bmc->base + reg);
+	uint32_t val = 0;
+	int rc;
+
+	rc = regmap_read(bt_bmc->map, bt_bmc->offset + reg, &val);
+	WARN(rc != 0, "regmap_read() failed: %d\n", rc);
+
+	return rc == 0 ? (u8) val : 0;
 }
 
 static void bt_outb(struct bt_bmc *bt_bmc, u8 data, int reg)
 {
-	writeb(data, bt_bmc->base + reg);
+	int rc;
+
+	rc = regmap_write(bt_bmc->map, bt_bmc->offset + reg, data);
+	WARN(rc != 0, "regmap_write() failed: %d\n", rc);
 }
 
 static void clr_rd_ptr(struct bt_bmc *bt_bmc)
@@ -358,15 +376,18 @@ static irqreturn_t bt_bmc_irq(int irq, void *arg)
 {
 	struct bt_bmc *bt_bmc = arg;
 	u32 reg;
+	int rc;
 
-	reg = readl(bt_bmc->base + BT_CR2);
+	rc = regmap_read(bt_bmc->map, bt_bmc->offset + BT_CR2, &reg);
+	if (rc)
+		return IRQ_NONE;
 
 	reg &= BT_CR2_IRQ_H2B | BT_CR2_IRQ_HBUSY;
 	if (!reg)
 		return IRQ_NONE;
 
 	/* ack pending IRQs */
-	writel(reg, bt_bmc->base + BT_CR2);
+	regmap_write(bt_bmc->map, bt_bmc->offset + BT_CR2, reg);
 
 	wake_up(&bt_bmc->queue);
 	return IRQ_HANDLED;
@@ -377,7 +398,6 @@ static int bt_bmc_config_irq(struct bt_bmc *bt_bmc,
 {
 	struct device *dev = &pdev->dev;
 	int rc;
-	u32 reg;
 
 	bt_bmc->irq = platform_get_irq_optional(pdev, 0);
 	if (bt_bmc->irq < 0)
@@ -397,11 +417,11 @@ static int bt_bmc_config_irq(struct bt_bmc *bt_bmc,
 	 * will be cleared (along with B2H) when we can write the next
 	 * message to the BT buffer
 	 */
-	reg = readl(bt_bmc->base + BT_CR1);
-	reg |= BT_CR1_IRQ_H2B | BT_CR1_IRQ_HBUSY;
-	writel(reg, bt_bmc->base + BT_CR1);
+	rc = regmap_update_bits(bt_bmc->map, bt_bmc->offset + BT_CR1,
+				(BT_CR1_IRQ_H2B | BT_CR1_IRQ_HBUSY),
+				(BT_CR1_IRQ_H2B | BT_CR1_IRQ_HBUSY));
 
-	return 0;
+	return rc;
 }
 
 static int bt_bmc_probe(struct platform_device *pdev)
@@ -419,16 +439,32 @@ static int bt_bmc_probe(struct platform_device *pdev)
 
 	dev_set_drvdata(&pdev->dev, bt_bmc);
 
-	bt_bmc->base = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(bt_bmc->base))
-		return PTR_ERR(bt_bmc->base);
+	bt_bmc->map = syscon_node_to_regmap(pdev->dev.parent->of_node);
+	if (IS_ERR(bt_bmc->map)) {
+		void __iomem *base;
+
+		/*
+		 * Assume it's not the MFD-based devicetree description, in
+		 * which case generate a regmap ourselves
+		 */
+		base = devm_platform_ioremap_resource(pdev, 0);
+		if (IS_ERR(base))
+			return PTR_ERR(base);
+
+		bt_bmc->map = devm_regmap_init_mmio(dev, base, &bt_regmap_cfg);
+		bt_bmc->offset = 0;
+	} else {
+		rc = of_property_read_u32(dev->of_node, "reg", &bt_bmc->offset);
+		if (rc)
+			return rc;
+	}
 
 	mutex_init(&bt_bmc->mutex);
 	init_waitqueue_head(&bt_bmc->queue);
 
-	bt_bmc->miscdev.minor	= MISC_DYNAMIC_MINOR;
-	bt_bmc->miscdev.name	= DEVICE_NAME;
-	bt_bmc->miscdev.fops	= &bt_bmc_fops;
+	bt_bmc->miscdev.minor	= MISC_DYNAMIC_MINOR,
+	bt_bmc->miscdev.name	= DEVICE_NAME,
+	bt_bmc->miscdev.fops	= &bt_bmc_fops,
 	bt_bmc->miscdev.parent = dev;
 	rc = misc_register(&bt_bmc->miscdev);
 	if (rc) {
@@ -447,12 +483,12 @@ static int bt_bmc_probe(struct platform_device *pdev)
 		add_timer(&bt_bmc->poll_timer);
 	}
 
-	writel((BT_IO_BASE << BT_CR0_IO_BASE) |
+	regmap_write(bt_bmc->map, bt_bmc->offset + BT_CR0,
+		     (BT_IO_BASE << BT_CR0_IO_BASE) |
 		     (BT_IRQ << BT_CR0_IRQ) |
 		     BT_CR0_EN_CLR_SLV_RDP |
 		     BT_CR0_EN_CLR_SLV_WRP |
-		     BT_CR0_ENABLE_IBT,
-		bt_bmc->base + BT_CR0);
+		     BT_CR0_ENABLE_IBT);
 
 	clr_b_busy(bt_bmc);
 
diff --git a/drivers/char/ipmi/ipmb_dev_int.c b/drivers/char/ipmi/ipmb_dev_int.c
old mode 100644
new mode 100755
index 49b8f22fdcf0..382b28f1cf2f
--- a/drivers/char/ipmi/ipmb_dev_int.c
+++ b/drivers/char/ipmi/ipmb_dev_int.c
@@ -137,7 +137,7 @@ static ssize_t ipmb_write(struct file *file, const char __user *buf,
 {
 	struct ipmb_dev *ipmb_dev = to_ipmb_dev(file);
 	u8 rq_sa, netf_rq_lun, msg_len;
-	struct i2c_client *temp_client;
+	union i2c_smbus_data data;
 	u8 msg[MAX_MSG_LEN];
 	ssize_t ret;
 
@@ -160,21 +160,21 @@ static ssize_t ipmb_write(struct file *file, const char __user *buf,
 	}
 
 	/*
-	 * subtract rq_sa and netf_rq_lun from the length of the msg. Fill the
-	 * temporary client. Note that its use is an exception for IPMI.
+	 * subtract rq_sa and netf_rq_lun from the length of the msg passed to
+	 * i2c_smbus_xfer
 	 */
 	msg_len = msg[IPMB_MSG_LEN_IDX] - SMBUS_MSG_HEADER_LENGTH;
-	temp_client = kmemdup(ipmb_dev->client, sizeof(*temp_client), GFP_KERNEL);
-	if (!temp_client)
-		return -ENOMEM;
-
-	temp_client->addr = rq_sa;
+	if (msg_len > I2C_SMBUS_BLOCK_MAX)
+		msg_len = I2C_SMBUS_BLOCK_MAX;
 
-	ret = i2c_smbus_write_block_data(temp_client, netf_rq_lun, msg_len,
-					 msg + SMBUS_MSG_IDX_OFFSET);
-	kfree(temp_client);
+	data.block[0] = msg_len;
+	memcpy(&data.block[1], msg + SMBUS_MSG_IDX_OFFSET, msg_len);
+	ret = i2c_smbus_xfer(ipmb_dev->client->adapter, rq_sa,
+			     ipmb_dev->client->flags,
+			     I2C_SMBUS_WRITE, netf_rq_lun,
+			     I2C_SMBUS_BLOCK_DATA, &data);
 
-	return ret < 0 ? ret : count;
+	return ret ? : count;
 }
 
 static __poll_t ipmb_poll(struct file *file, poll_table *wait)
diff --git a/drivers/char/ipmi/ipmi_bt_sm.c b/drivers/char/ipmi/ipmi_bt_sm.c
old mode 100644
new mode 100755
diff --git a/drivers/char/ipmi/ipmi_devintf.c b/drivers/char/ipmi/ipmi_devintf.c
old mode 100644
new mode 100755
index 3dd1d5abb298..f7b1c004a12b
--- a/drivers/char/ipmi/ipmi_devintf.c
+++ b/drivers/char/ipmi/ipmi_devintf.c
@@ -490,6 +490,7 @@ static long ipmi_ioctl(struct file   *file,
 		}
 
 		return ipmi_set_my_address(priv->user, val.channel, val.value);
+		break;
 	}
 
 	case IPMICTL_GET_MY_CHANNEL_ADDRESS_CMD:
diff --git a/drivers/char/ipmi/ipmi_dmi.c b/drivers/char/ipmi/ipmi_dmi.c
old mode 100644
new mode 100755
diff --git a/drivers/char/ipmi/ipmi_dmi.h b/drivers/char/ipmi/ipmi_dmi.h
old mode 100644
new mode 100755
diff --git a/drivers/char/ipmi/ipmi_kcs_sm.c b/drivers/char/ipmi/ipmi_kcs_sm.c
old mode 100644
new mode 100755
diff --git a/drivers/char/ipmi/ipmi_msghandler.c b/drivers/char/ipmi/ipmi_msghandler.c
old mode 100644
new mode 100755
index a08f53f208bf..8774a3b8ff95
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@ -16,7 +16,6 @@
 
 #include <linux/module.h>
 #include <linux/errno.h>
-#include <linux/panic_notifier.h>
 #include <linux/poll.h>
 #include <linux/sched.h>
 #include <linux/seq_file.h>
@@ -50,17 +49,11 @@ static int handle_one_recv_msg(struct ipmi_smi *intf,
 static bool initialized;
 static bool drvregistered;
 
-/* Numbers in this enumerator should be mapped to ipmi_panic_event_str */
 enum ipmi_panic_event_op {
 	IPMI_SEND_PANIC_EVENT_NONE,
 	IPMI_SEND_PANIC_EVENT,
-	IPMI_SEND_PANIC_EVENT_STRING,
-	IPMI_SEND_PANIC_EVENT_MAX
+	IPMI_SEND_PANIC_EVENT_STRING
 };
-
-/* Indices in this array should be mapped to enum ipmi_panic_event_op */
-static const char *const ipmi_panic_event_str[] = { "none", "event", "string", NULL };
-
 #ifdef CONFIG_IPMI_PANIC_STRING
 #define IPMI_PANIC_DEFAULT IPMI_SEND_PANIC_EVENT_STRING
 #elif defined(CONFIG_IPMI_PANIC_EVENT)
@@ -75,27 +68,46 @@ static int panic_op_write_handler(const char *val,
 				  const struct kernel_param *kp)
 {
 	char valcp[16];
-	int e;
+	char *s;
+
+	strncpy(valcp, val, 15);
+	valcp[15] = '\0';
 
-	strscpy(valcp, val, sizeof(valcp));
-	e = match_string(ipmi_panic_event_str, -1, strstrip(valcp));
-	if (e < 0)
-		return e;
+	s = strstrip(valcp);
+
+	if (strcmp(s, "none") == 0)
+		ipmi_send_panic_event = IPMI_SEND_PANIC_EVENT_NONE;
+	else if (strcmp(s, "event") == 0)
+		ipmi_send_panic_event = IPMI_SEND_PANIC_EVENT;
+	else if (strcmp(s, "string") == 0)
+		ipmi_send_panic_event = IPMI_SEND_PANIC_EVENT_STRING;
+	else
+		return -EINVAL;
 
-	ipmi_send_panic_event = e;
 	return 0;
 }
 
 static int panic_op_read_handler(char *buffer, const struct kernel_param *kp)
 {
-	const char *event_str;
+	switch (ipmi_send_panic_event) {
+	case IPMI_SEND_PANIC_EVENT_NONE:
+		strcpy(buffer, "none\n");
+		break;
 
-	if (ipmi_send_panic_event >= IPMI_SEND_PANIC_EVENT_MAX)
-		event_str = "???";
-	else
-		event_str = ipmi_panic_event_str[ipmi_send_panic_event];
+	case IPMI_SEND_PANIC_EVENT:
+		strcpy(buffer, "event\n");
+		break;
+
+	case IPMI_SEND_PANIC_EVENT_STRING:
+		strcpy(buffer, "string\n");
+		break;
 
-	return sprintf(buffer, "%s\n", event_str);
+	default:
+		strcpy(buffer, "???\n");
+		break;
+	}
+
+	return strlen(buffer);
 }
 
 static const struct kernel_param_ops panic_op_ops = {
@@ -735,8 +747,7 @@ int ipmi_smi_watcher_register(struct ipmi_smi_watcher *watcher)
 	list_add(&watcher->link, &smi_watchers);
 
 	index = srcu_read_lock(&ipmi_interfaces_srcu);
-	list_for_each_entry_rcu(intf, &ipmi_interfaces, link,
-			lockdep_is_held(&smi_watchers_mutex)) {
+	list_for_each_entry_rcu(intf, &ipmi_interfaces, link) {
 		int intf_num = READ_ONCE(intf->intf_num);
 
 		if (intf_num == -1)
@@ -2435,8 +2446,10 @@ static int __get_device_id(struct ipmi_smi *intf, struct bmc_device *bmc)
 	wait_event(intf->waitq, bmc->dyn_id_set != 2);
 
 	if (!bmc->dyn_id_set) {
-		if (bmc->cc != IPMI_CC_NO_ERROR &&
-		    ++retry_count <= GET_DEVICE_ID_MAX_RETRY) {
+		if ((bmc->cc == IPMI_DEVICE_IN_FW_UPDATE_ERR
+		     || bmc->cc ==  IPMI_DEVICE_IN_INIT_ERR
+		     || bmc->cc ==  IPMI_NOT_IN_MY_STATE_ERR)
+		     && ++retry_count <= GET_DEVICE_ID_MAX_RETRY) {
 			msleep(500);
 			dev_warn(intf->si_dev,
 			    "BMC returned 0x%2.2x, retry get bmc device id\n",
@@ -4789,9 +4802,7 @@ static atomic_t recv_msg_inuse_count = ATOMIC_INIT(0);
 static void free_smi_msg(struct ipmi_smi_msg *msg)
 {
 	atomic_dec(&smi_msg_inuse_count);
-	/* Try to keep as much stuff out of the panic path as possible. */
-	if (!oops_in_progress)
-		kfree(msg);
+	kfree(msg);
 }
 
 struct ipmi_smi_msg *ipmi_alloc_smi_msg(void)
@@ -4810,9 +4821,7 @@ EXPORT_SYMBOL(ipmi_alloc_smi_msg);
 static void free_recv_msg(struct ipmi_recv_msg *msg)
 {
 	atomic_dec(&recv_msg_inuse_count);
-	/* Try to keep as much stuff out of the panic path as possible. */
-	if (!oops_in_progress)
-		kfree(msg);
+	kfree(msg);
 }
 
 static struct ipmi_recv_msg *ipmi_alloc_recv_msg(void)
@@ -4830,7 +4839,7 @@ static struct ipmi_recv_msg *ipmi_alloc_recv_msg(void)
 
 void ipmi_free_recv_msg(struct ipmi_recv_msg *msg)
 {
-	if (msg->user && !oops_in_progress)
+	if (msg->user)
 		kref_put(&msg->user->refcount, free_user);
 	msg->done(msg);
 }
@@ -5214,6 +5223,7 @@ module_exit(cleanup_ipmi);
 module_init(ipmi_init_msghandler_mod);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Corey Minyard <minyard@mvista.com>");
-MODULE_DESCRIPTION("Incoming and outgoing message routing for an IPMI interface.");
+MODULE_DESCRIPTION("Incoming and outgoing message routing for an IPMI"
+		   " interface.");
 MODULE_VERSION(IPMI_DRIVER_VERSION);
 MODULE_SOFTDEP("post: ipmi_devintf");
diff --git a/drivers/char/ipmi/ipmi_plat_data.c b/drivers/char/ipmi/ipmi_plat_data.c
old mode 100644
new mode 100755
index 747b51ae01a8..28471ff2a3a3
--- a/drivers/char/ipmi/ipmi_plat_data.c
+++ b/drivers/char/ipmi/ipmi_plat_data.c
@@ -102,7 +102,7 @@ struct platform_device *ipmi_platform_add(const char *name, unsigned int inst,
 		goto err;
 	}
  add_properties:
-	rv = device_create_managed_software_node(&pdev->dev, pr, NULL);
+	rv = platform_device_add_properties(pdev, pr);
 	if (rv) {
 		dev_err(&pdev->dev,
 			"Unable to add hard-code properties: %d\n", rv);
diff --git a/drivers/char/ipmi/ipmi_plat_data.h b/drivers/char/ipmi/ipmi_plat_data.h
old mode 100644
new mode 100755
diff --git a/drivers/char/ipmi/ipmi_powernv.c b/drivers/char/ipmi/ipmi_powernv.c
old mode 100644
new mode 100755
diff --git a/drivers/char/ipmi/ipmi_poweroff.c b/drivers/char/ipmi/ipmi_poweroff.c
old mode 100644
new mode 100755
diff --git a/drivers/char/ipmi/ipmi_si.h b/drivers/char/ipmi/ipmi_si.h
old mode 100644
new mode 100755
index a7ead2a4c753..bac0ff86e48e
--- a/drivers/char/ipmi/ipmi_si.h
+++ b/drivers/char/ipmi/ipmi_si.h
@@ -18,14 +18,10 @@
 #define DEFAULT_REGSPACING	1
 #define DEFAULT_REGSIZE		1
 
-/* Numbers in this enumerator should be mapped to si_to_str[] */
 enum si_type {
-	SI_TYPE_INVALID, SI_KCS, SI_SMIC, SI_BT, SI_TYPE_MAX
+	SI_TYPE_INVALID, SI_KCS, SI_SMIC, SI_BT
 };
 
-/* Array is defined in the ipmi_si_intf.c */
-extern const char *const si_to_str[];
-
 enum ipmi_addr_space {
 	IPMI_IO_ADDR_SPACE, IPMI_MEM_ADDR_SPACE
 };
@@ -52,6 +48,8 @@ struct si_sm_io {
 	enum ipmi_addr_space addr_space;
 	unsigned long addr_data;
 	enum ipmi_addr_src addr_source; /* ACPI, PCI, SMBIOS, hardcode, etc. */
+	void (*addr_source_cleanup)(struct si_sm_io *io);
+	void *addr_source_data;
 	union ipmi_smi_info_union addr_info;
 
 	int (*io_setup)(struct si_sm_io *info);
@@ -73,7 +71,7 @@ irqreturn_t ipmi_si_irq_handler(int irq, void *data);
 void ipmi_irq_start_cleanup(struct si_sm_io *io);
 int ipmi_std_irq_setup(struct si_sm_io *io);
 void ipmi_irq_finish_setup(struct si_sm_io *io);
-void ipmi_si_remove_by_dev(struct device *dev);
+int ipmi_si_remove_by_dev(struct device *dev);
 struct device *ipmi_si_remove_by_data(int addr_space, enum si_type si_type,
 				      unsigned long addr);
 void ipmi_hardcode_init(void);
diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
old mode 100644
new mode 100755
index ed5e91b1e040..f6ece7569504
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -32,29 +32,47 @@ static int slave_addrs[SI_MAX_PARMS] __initdata;
 static unsigned int num_slave_addrs __initdata;
 
 module_param_string(type, si_type_str, MAX_SI_TYPE_STR, 0);
-MODULE_PARM_DESC(type,
-		 "Defines the type of each interface, each interface separated by commas.  The types are 'kcs', 'smic', and 'bt'.  For example si_type=kcs,bt will set the first interface to kcs and the second to bt");
+MODULE_PARM_DESC(type, "Defines the type of each interface, each"
+		 " interface separated by commas.  The types are 'kcs',"
+		 " 'smic', and 'bt'.  For example si_type=kcs,bt will set"
+		 " the first interface to kcs and the second to bt");
 module_param_hw_array(addrs, ulong, iomem, &num_addrs, 0);
-MODULE_PARM_DESC(addrs,
-		 "Sets the memory address of each interface, the addresses separated by commas.  Only use if an interface is in memory.  Otherwise, set it to zero or leave it blank.");
+MODULE_PARM_DESC(addrs, "Sets the memory address of each interface, the"
+		 " addresses separated by commas.  Only use if an interface"
+		 " is in memory.  Otherwise, set it to zero or leave"
+		 " it blank.");
 module_param_hw_array(ports, uint, ioport, &num_ports, 0);
-MODULE_PARM_DESC(ports,
-		 "Sets the port address of each interface, the addresses separated by commas.  Only use if an interface is a port.  Otherwise, set it to zero or leave it blank.");
+MODULE_PARM_DESC(ports, "Sets the port address of each interface, the"
+		 " addresses separated by commas.  Only use if an interface"
+		 " is a port.  Otherwise, set it to zero or leave"
+		 " it blank.");
 module_param_hw_array(irqs, int, irq, &num_irqs, 0);
-MODULE_PARM_DESC(irqs,
-		 "Sets the interrupt of each interface, the addresses separated by commas.  Only use if an interface has an interrupt.  Otherwise, set it to zero or leave it blank.");
+MODULE_PARM_DESC(irqs, "Sets the interrupt of each interface, the"
+		 " addresses separated by commas.  Only use if an interface"
+		 " has an interrupt.  Otherwise, set it to zero or leave"
+		 " it blank.");
 module_param_hw_array(regspacings, int, other, &num_regspacings, 0);
-MODULE_PARM_DESC(regspacings,
-		 "The number of bytes between the start address and each successive register used by the interface.  For instance, if the start address is 0xca2 and the spacing is 2, then the second address is at 0xca4.  Defaults to 1.");
+MODULE_PARM_DESC(regspacings, "The number of bytes between the start address"
+		 " and each successive register used by the interface.  For"
+		 " instance, if the start address is 0xca2 and the spacing"
+		 " is 2, then the second address is at 0xca4.  Defaults"
+		 " to 1.");
 module_param_hw_array(regsizes, int, other, &num_regsizes, 0);
-MODULE_PARM_DESC(regsizes,
-		 "The size of the specific IPMI register in bytes. This should generally be 1, 2, 4, or 8 for an 8-bit, 16-bit, 32-bit, or 64-bit register.  Use this if you the 8-bit IPMI register has to be read from a larger register.");
+MODULE_PARM_DESC(regsizes, "The size of the specific IPMI register in bytes."
+		 " This should generally be 1, 2, 4, or 8 for an 8-bit,"
+		 " 16-bit, 32-bit, or 64-bit register.  Use this if you"
+		 " the 8-bit IPMI register has to be read from a larger"
+		 " register.");
 module_param_hw_array(regshifts, int, other, &num_regshifts, 0);
-MODULE_PARM_DESC(regshifts,
-		 "The amount to shift the data read from the. IPMI register, in bits.  For instance, if the data is read from a 32-bit word and the IPMI data is in bit 8-15, then the shift would be 8");
+MODULE_PARM_DESC(regshifts, "The amount to shift the data read from the."
+		 " IPMI register, in bits.  For instance, if the data"
+		 " is read from a 32-bit word and the IPMI data is in"
+		 " bit 8-15, then the shift would be 8");
 module_param_hw_array(slave_addrs, int, other, &num_slave_addrs, 0);
-MODULE_PARM_DESC(slave_addrs,
-		 "Set the default IPMB slave address for the controller.  Normally this is 0x20, but can be overridden by this parm.  This is an array indexed by interface number.");
+MODULE_PARM_DESC(slave_addrs, "Set the default IPMB slave address for"
+		 " the controller.  Normally this is 0x20, but can be"
+		 " overridden by this parm.  This is an array indexed"
+		 " by interface number.");
 
 static void __init ipmi_hardcode_init_one(const char *si_type_str,
 					  unsigned int i,
@@ -62,21 +80,26 @@ static void __init ipmi_hardcode_init_one(const char *si_type_str,
 					  enum ipmi_addr_space addr_space)
 {
 	struct ipmi_plat_data p;
-	int t;
 
 	memset(&p, 0, sizeof(p));
 
 	p.iftype = IPMI_PLAT_IF_SI;
-	if (!si_type_str || !*si_type_str) {
+	if (!si_type_str || !*si_type_str || strcmp(si_type_str, "kcs") == 0) {
 		p.type = SI_KCS;
+	} else if (strcmp(si_type_str, "smic") == 0) {
+		p.type = SI_SMIC;
+	} else if (strcmp(si_type_str, "bt") == 0) {
+		p.type = SI_BT;
+	} else if (strcmp(si_type_str, "invalid") == 0) {
+		/*
+		 * Allow a firmware-specified interface to be
+		 * disabled.
+		 */
+		p.type = SI_TYPE_INVALID;
 	} else {
-		t = match_string(si_to_str, -1, si_type_str);
-		if (t < 0) {
-			pr_warn("Interface type specified for interface %d, was invalid: %s\n",
-				i, si_type_str);
-			return;
-		}
-		p.type = t;
+		pr_warn("Interface type specified for interface %d, was invalid: %s\n",
+			i, si_type_str);
+		return;
 	}
 
 	p.regsize = regsizes[i];
diff --git a/drivers/char/ipmi/ipmi_si_hotmod.c b/drivers/char/ipmi/ipmi_si_hotmod.c
old mode 100644
new mode 100755
index 6b12a83ccd4c..4fbb4e18bae2
--- a/drivers/char/ipmi/ipmi_si_hotmod.c
+++ b/drivers/char/ipmi/ipmi_si_hotmod.c
@@ -17,8 +17,9 @@
 static int hotmod_handler(const char *val, const struct kernel_param *kp);
 
 module_param_call(hotmod, hotmod_handler, NULL, NULL, 0200);
-MODULE_PARM_DESC(hotmod,
-		 "Add and remove interfaces.  See Documentation/driver-api/ipmi.rst in the kernel sources for the gory details.");
+MODULE_PARM_DESC(hotmod, "Add and remove interfaces.  See"
+		 " Documentation/driver-api/ipmi.rst in the kernel sources for the"
+		 " gory details.");
 
 /*
  * Parms come in as <op1>[:op2[:op3...]].  ops are:
@@ -184,16 +185,24 @@ static atomic_t hotmod_nr;
 
 static int hotmod_handler(const char *val, const struct kernel_param *kp)
 {
+	char *str = kstrdup(val, GFP_KERNEL), *curr, *next;
 	int  rv;
 	struct ipmi_plat_data h;
-	char *str, *curr, *next;
+	unsigned int len;
+	int ival;
 
-	str = kstrdup(val, GFP_KERNEL);
 	if (!str)
 		return -ENOMEM;
 
 	/* Kill any trailing spaces, as we can get a "\n" from echo. */
-	for (curr = strstrip(str); curr; curr = next) {
+	len = strlen(str);
+	ival = len - 1;
+	while ((ival >= 0) && isspace(str[ival])) {
+		str[ival] = '\0';
+		ival--;
+	}
+
+	for (curr = str; curr; curr = next) {
 		enum hotmod_op op;
 
 		next = strchr(curr, ':');
@@ -222,10 +231,11 @@ static int hotmod_handler(const char *val, const struct kernel_param *kp)
 				if (strcmp(pdev->name, "hotmod-ipmi-si") == 0)
 					platform_device_unregister(pdev);
 			}
-			put_device(dev);
+			if (dev)
+				put_device(dev);
 		}
 	}
-	rv = strlen(val);
+	rv = len;
 out:
 	kfree(str);
 	return rv;
diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c
old mode 100644
new mode 100755
index 6f3272b58ced..5eac94cf4ff8
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@ -70,8 +70,7 @@ enum si_intf_state {
 #define IPMI_BT_INTMASK_CLEAR_IRQ_BIT	2
 #define IPMI_BT_INTMASK_ENABLE_IRQ_BIT	1
 
-/* 'invalid' to allow a firmware-specified interface to be disabled */
-const char *const si_to_str[] = { "invalid", "kcs", "smic", "bt", NULL };
+static const char * const si_to_str[] = { "invalid", "kcs", "smic", "bt" };
 
 static bool initialized;
 
@@ -591,7 +590,7 @@ static void handle_transaction_done(struct smi_info *smi_info)
 		smi_info->handlers->get_result(smi_info->si_sm, msg, 3);
 		if (msg[2] != 0) {
 			/* Error clearing flags */
-			dev_warn_ratelimited(smi_info->io.dev,
+			dev_warn(smi_info->io.dev,
 				 "Error clearing flags: %2.2x\n", msg[2]);
 		}
 		smi_info->si_state = SI_NORMAL;
@@ -683,10 +682,10 @@ static void handle_transaction_done(struct smi_info *smi_info)
 		/* We got the flags from the SMI, now handle them. */
 		smi_info->handlers->get_result(smi_info->si_sm, msg, 4);
 		if (msg[2] != 0) {
-			dev_warn_ratelimited(smi_info->io.dev,
-				"Couldn't get irq info: %x,\n"
-				"Maybe ok, but ipmi might run very slowly.\n",
-				msg[2]);
+			dev_warn(smi_info->io.dev,
+				 "Couldn't get irq info: %x.\n", msg[2]);
+			dev_warn(smi_info->io.dev,
+				 "Maybe ok, but ipmi might run very slowly.\n");
 			smi_info->si_state = SI_NORMAL;
 			break;
 		}
@@ -721,7 +720,7 @@ static void handle_transaction_done(struct smi_info *smi_info)
 
 		smi_info->handlers->get_result(smi_info->si_sm, msg, 4);
 		if (msg[2] != 0)
-			dev_warn_ratelimited(smi_info->io.dev,
+			dev_warn(smi_info->io.dev,
 				 "Could not set the global enables: 0x%x.\n",
 				 msg[2]);
 
@@ -1170,8 +1169,9 @@ static int smi_start_processing(void            *send_info,
 		new_smi->thread = kthread_run(ipmi_thread, new_smi,
 					      "kipmi%d", new_smi->si_num);
 		if (IS_ERR(new_smi->thread)) {
-			dev_notice(new_smi->io.dev,
-				   "Could not start kernel thread due to error %ld, only using timers to drive the interface\n",
+			dev_notice(new_smi->io.dev, "Could not start"
+				   " kernel thread due to error %ld, only using"
+				   " timers to drive the interface\n",
 				   PTR_ERR(new_smi->thread));
 			new_smi->thread = NULL;
 		}
@@ -1223,14 +1223,18 @@ static int smi_num; /* Used to sequence the SMIs */
 static const char * const addr_space_to_str[] = { "i/o", "mem" };
 
 module_param_array(force_kipmid, int, &num_force_kipmid, 0);
-MODULE_PARM_DESC(force_kipmid,
-		 "Force the kipmi daemon to be enabled (1) or disabled(0).  Normally the IPMI driver auto-detects this, but the value may be overridden by this parm.");
+MODULE_PARM_DESC(force_kipmid, "Force the kipmi daemon to be enabled (1) or"
+		 " disabled(0).  Normally the IPMI driver auto-detects"
+		 " this, but the value may be overridden by this parm.");
 module_param(unload_when_empty, bool, 0);
-MODULE_PARM_DESC(unload_when_empty,
-		 "Unload the module if no interfaces are specified or found, default is 1.  Setting to 0 is useful for hot add of devices using hotmod.");
+MODULE_PARM_DESC(unload_when_empty, "Unload the module if no interfaces are"
+		 " specified or found, default is 1.  Setting to 0"
+		 " is useful for hot add of devices using hotmod.");
 module_param_array(kipmid_max_busy_us, uint, &num_max_busy_us, 0644);
 MODULE_PARM_DESC(kipmid_max_busy_us,
-		 "Max time (in microseconds) to busy-wait for IPMI data before sleeping. 0 (default) means to wait forever. Set to 100-500 if kipmid is using up a lot of CPU time.");
+		 "Max time (in microseconds) to busy-wait for IPMI data before"
+		 " sleeping. 0 (default) means to wait forever. Set to 100-500"
+		 " if kipmid is using up a lot of CPU time.");
 
 void ipmi_irq_finish_setup(struct si_sm_io *io)
 {
@@ -1266,7 +1270,8 @@ int ipmi_std_irq_setup(struct si_sm_io *io)
 			 SI_DEVICE_NAME,
 			 io->irq_handler_data);
 	if (rv) {
-		dev_warn(io->dev, "%s unable to claim interrupt %d, running polled\n",
+		dev_warn(io->dev, "%s unable to claim interrupt %d,"
+			 " running polled\n",
 			 SI_DEVICE_NAME, io->irq);
 		io->irq = 0;
 	} else {
@@ -1341,9 +1346,11 @@ static int try_get_dev_id(struct smi_info *smi_info)
 		/* record completion code */
 		unsigned char cc = *(resp + 2);
 
-		if (cc != IPMI_CC_NO_ERROR &&
-		    ++retry_count <= GET_DEVICE_ID_MAX_RETRY) {
-			dev_warn_ratelimited(smi_info->io.dev,
+		if ((cc == IPMI_DEVICE_IN_FW_UPDATE_ERR
+		    || cc == IPMI_DEVICE_IN_INIT_ERR
+		    || cc == IPMI_NOT_IN_MY_STATE_ERR)
+		    && ++retry_count <= GET_DEVICE_ID_MAX_RETRY) {
+			dev_warn(smi_info->io.dev,
 			    "BMC returned 0x%2.2x, retry get bmc device id\n",
 			    cc);
 			goto retry;
@@ -1605,7 +1612,7 @@ static ssize_t name##_show(struct device *dev,			\
 									\
 	return snprintf(buf, 10, "%u\n", smi_get_stat(smi_info, name));	\
 }									\
-static DEVICE_ATTR_RO(name)
+static DEVICE_ATTR(name, 0444, name##_show, NULL)
 
 static ssize_t type_show(struct device *dev,
 			 struct device_attribute *attr,
@@ -1615,7 +1622,7 @@ static ssize_t type_show(struct device *dev,
 
 	return snprintf(buf, 10, "%s\n", si_to_str[smi_info->io.si_type]);
 }
-static DEVICE_ATTR_RO(type);
+static DEVICE_ATTR(type, 0444, type_show, NULL);
 
 static ssize_t interrupts_enabled_show(struct device *dev,
 				       struct device_attribute *attr,
@@ -1626,7 +1633,8 @@ static ssize_t interrupts_enabled_show(struct device *dev,
 
 	return snprintf(buf, 10, "%d\n", enabled);
 }
-static DEVICE_ATTR_RO(interrupts_enabled);
+static DEVICE_ATTR(interrupts_enabled, 0444,
+		   interrupts_enabled_show, NULL);
 
 IPMI_SI_ATTR(short_timeouts);
 IPMI_SI_ATTR(long_timeouts);
@@ -1657,7 +1665,7 @@ static ssize_t params_show(struct device *dev,
 			smi_info->io.irq,
 			smi_info->io.slave_addr);
 }
-static DEVICE_ATTR_RO(params);
+static DEVICE_ATTR(params, 0444, params_show, NULL);
 
 static struct attribute *ipmi_si_dev_attrs[] = {
 	&dev_attr_type.attr,
@@ -2199,6 +2207,10 @@ static void shutdown_smi(void *send_info)
 	if (smi_info->handlers)
 		smi_info->handlers->cleanup(smi_info->si_sm);
 
+	if (smi_info->io.addr_source_cleanup) {
+		smi_info->io.addr_source_cleanup(&smi_info->io);
+		smi_info->io.addr_source_cleanup = NULL;
+	}
 	if (smi_info->io.io_cleanup) {
 		smi_info->io.io_cleanup(&smi_info->io);
 		smi_info->io.io_cleanup = NULL;
@@ -2227,18 +2239,22 @@ static void cleanup_one_si(struct smi_info *smi_info)
 	kfree(smi_info);
 }
 
-void ipmi_si_remove_by_dev(struct device *dev)
+int ipmi_si_remove_by_dev(struct device *dev)
 {
 	struct smi_info *e;
+	int rv = -ENOENT;
 
 	mutex_lock(&smi_infos_lock);
 	list_for_each_entry(e, &smi_infos, link) {
 		if (e->io.dev == dev) {
 			cleanup_one_si(e);
+			rv = 0;
 			break;
 		}
 	}
 	mutex_unlock(&smi_infos_lock);
+
+	return rv;
 }
 
 struct device *ipmi_si_remove_by_data(int addr_space, enum si_type si_type,
@@ -2290,4 +2306,5 @@ module_exit(cleanup_ipmi_si);
 MODULE_ALIAS("platform:dmi-ipmi-si");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Corey Minyard <minyard@mvista.com>");
-MODULE_DESCRIPTION("Interface to the IPMI driver for the KCS, SMIC, and BT system interfaces.");
+MODULE_DESCRIPTION("Interface to the IPMI driver for the KCS, SMIC, and BT"
+		   " system interfaces.");
diff --git a/drivers/char/ipmi/ipmi_si_mem_io.c b/drivers/char/ipmi/ipmi_si_mem_io.c
old mode 100644
new mode 100755
diff --git a/drivers/char/ipmi/ipmi_si_parisc.c b/drivers/char/ipmi/ipmi_si_parisc.c
old mode 100644
new mode 100755
index 2be2967f6b5f..11c9160275df
--- a/drivers/char/ipmi/ipmi_si_parisc.c
+++ b/drivers/char/ipmi/ipmi_si_parisc.c
@@ -29,9 +29,9 @@ static int __init ipmi_parisc_probe(struct parisc_device *dev)
 	return ipmi_si_add_smi(&io);
 }
 
-static void __exit ipmi_parisc_remove(struct parisc_device *dev)
+static int __exit ipmi_parisc_remove(struct parisc_device *dev)
 {
-	ipmi_si_remove_by_dev(&dev->dev);
+	return ipmi_si_remove_by_dev(&dev->dev);
 }
 
 static const struct parisc_device_id ipmi_parisc_tbl[] __initconst = {
diff --git a/drivers/char/ipmi/ipmi_si_pci.c b/drivers/char/ipmi/ipmi_si_pci.c
old mode 100644
new mode 100755
index 74fa2055868b..95bbcfba5408
--- a/drivers/char/ipmi/ipmi_si_pci.c
+++ b/drivers/char/ipmi/ipmi_si_pci.c
@@ -16,11 +16,18 @@ static bool pci_registered;
 static bool si_trypci = true;
 
 module_param_named(trypci, si_trypci, bool, 0);
-MODULE_PARM_DESC(trypci,
-		 "Setting this to zero will disable the default scan of the interfaces identified via pci");
+MODULE_PARM_DESC(trypci, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via pci");
 
 #define PCI_DEVICE_ID_HP_MMC 0x121A
 
+static void ipmi_pci_cleanup(struct si_sm_io *io)
+{
+	struct pci_dev *pdev = io->addr_source_data;
+
+	pci_disable_device(pdev);
+}
+
 static int ipmi_pci_probe_regspacing(struct si_sm_io *io)
 {
 	if (io->si_type == SI_KCS) {
@@ -90,12 +97,15 @@ static int ipmi_pci_probe(struct pci_dev *pdev,
 		return -ENOMEM;
 	}
 
-	rv = pcim_enable_device(pdev);
+	rv = pci_enable_device(pdev);
 	if (rv) {
 		dev_err(&pdev->dev, "couldn't enable PCI device\n");
 		return rv;
 	}
 
+	io.addr_source_cleanup = ipmi_pci_cleanup;
+	io.addr_source_data = pdev;
+
 	if (pci_resource_flags(pdev, 0) & IORESOURCE_IO) {
 		io.addr_space = IPMI_IO_ADDR_SPACE;
 		io.io_setup = ipmi_si_port_setup;
@@ -118,7 +128,11 @@ static int ipmi_pci_probe(struct pci_dev *pdev,
 	dev_info(&pdev->dev, "%pR regsize %d spacing %d irq %d\n",
 		 &pdev->resource[0], io.regsize, io.regspacing, io.irq);
 
-	return ipmi_si_add_smi(&io);
+	rv = ipmi_si_add_smi(&io);
+	if (rv)
+		pci_disable_device(pdev);
+
+	return rv;
 }
 
 static void ipmi_pci_remove(struct pci_dev *pdev)
diff --git a/drivers/char/ipmi/ipmi_si_platform.c b/drivers/char/ipmi/ipmi_si_platform.c
old mode 100644
new mode 100755
index 505cc978c97a..129b5713f187
--- a/drivers/char/ipmi/ipmi_si_platform.c
+++ b/drivers/char/ipmi/ipmi_si_platform.c
@@ -34,22 +34,23 @@ static bool          si_trydmi = false;
 #endif
 
 module_param_named(tryplatform, si_tryplatform, bool, 0);
-MODULE_PARM_DESC(tryplatform,
-		 "Setting this to zero will disable the default scan of the interfaces identified via platform interfaces besides ACPI, OpenFirmware, and DMI");
+MODULE_PARM_DESC(tryplatform, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via platform"
+		 " interfaces besides ACPI, OpenFirmware, and DMI");
 #ifdef CONFIG_ACPI
 module_param_named(tryacpi, si_tryacpi, bool, 0);
-MODULE_PARM_DESC(tryacpi,
-		 "Setting this to zero will disable the default scan of the interfaces identified via ACPI");
+MODULE_PARM_DESC(tryacpi, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via ACPI");
 #endif
 #ifdef CONFIG_OF
 module_param_named(tryopenfirmware, si_tryopenfirmware, bool, 0);
-MODULE_PARM_DESC(tryopenfirmware,
-		 "Setting this to zero will disable the default scan of the interfaces identified via OpenFirmware");
+MODULE_PARM_DESC(tryopenfirmware, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via OpenFirmware");
 #endif
 #ifdef CONFIG_DMI
 module_param_named(trydmi, si_trydmi, bool, 0);
-MODULE_PARM_DESC(trydmi,
-		 "Setting this to zero will disable the default scan of the interfaces identified via DMI");
+MODULE_PARM_DESC(trydmi, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via DMI");
 #endif
 
 #ifdef CONFIG_ACPI
@@ -84,46 +85,47 @@ static int acpi_gpe_irq_setup(struct si_sm_io *io)
 					  ACPI_GPE_LEVEL_TRIGGERED,
 					  &ipmi_acpi_gpe,
 					  io);
-	if (ACPI_FAILURE(status)) {
+	if (status != AE_OK) {
 		dev_warn(io->dev,
 			 "Unable to claim ACPI GPE %d, running polled\n",
 			 io->irq);
 		io->irq = 0;
 		return -EINVAL;
+	} else {
+		io->irq_cleanup = acpi_gpe_irq_cleanup;
+		ipmi_irq_finish_setup(io);
+		dev_info(io->dev, "Using ACPI GPE %d\n", io->irq);
+		return 0;
 	}
-
-	io->irq_cleanup = acpi_gpe_irq_cleanup;
-	ipmi_irq_finish_setup(io);
-	dev_info(io->dev, "Using ACPI GPE %d\n", io->irq);
-	return 0;
 }
 #endif
 
-static void ipmi_set_addr_data_and_space(struct resource *r, struct si_sm_io *io)
-{
-	if (resource_type(r) == IORESOURCE_IO)
-		io->addr_space = IPMI_IO_ADDR_SPACE;
-	else
-		io->addr_space = IPMI_MEM_ADDR_SPACE;
-	io->addr_data = r->start;
-}
-
 static struct resource *
 ipmi_get_info_from_resources(struct platform_device *pdev,
 			     struct si_sm_io *io)
 {
 	struct resource *res, *res_second;
 
-	res = platform_get_mem_or_io(pdev, 0);
+	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+	if (res) {
+		io->addr_space = IPMI_IO_ADDR_SPACE;
+	} else {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (res)
+			io->addr_space = IPMI_MEM_ADDR_SPACE;
+	}
 	if (!res) {
 		dev_err(&pdev->dev, "no I/O or memory address\n");
 		return NULL;
 	}
-	ipmi_set_addr_data_and_space(res, io);
+	io->addr_data = res->start;
 
 	io->regspacing = DEFAULT_REGSPACING;
-	res_second = platform_get_mem_or_io(pdev, 1);
-	if (res_second && resource_type(res_second) == resource_type(res)) {
+	res_second = platform_get_resource(pdev,
+			       (io->addr_space == IPMI_IO_ADDR_SPACE) ?
+					IORESOURCE_IO : IORESOURCE_MEM,
+			       1);
+	if (res_second) {
 		if (res_second->start > io->addr_data)
 			io->regspacing = res_second->start - io->addr_data;
 	}
@@ -273,7 +275,12 @@ static int of_ipmi_probe(struct platform_device *pdev)
 	io.addr_source	= SI_DEVICETREE;
 	io.irq_setup	= ipmi_std_irq_setup;
 
-	ipmi_set_addr_data_and_space(&resource, &io);
+	if (resource.flags & IORESOURCE_IO)
+		io.addr_space = IPMI_IO_ADDR_SPACE;
+	else
+		io.addr_space = IPMI_MEM_ADDR_SPACE;
+
+	io.addr_data	= resource.start;
 
 	io.regsize	= regsize ? be32_to_cpup(regsize) : DEFAULT_REGSIZE;
 	io.regspacing	= regspacing ? be32_to_cpup(regspacing) : DEFAULT_REGSPACING;
@@ -310,31 +317,32 @@ static int find_slave_address(struct si_sm_io *io, int slave_addr)
 
 static int acpi_ipmi_probe(struct platform_device *pdev)
 {
-	struct device *dev = &pdev->dev;
 	struct si_sm_io io;
 	acpi_handle handle;
 	acpi_status status;
 	unsigned long long tmp;
 	struct resource *res;
+	int rv = -EINVAL;
 
 	if (!si_tryacpi)
 		return -ENODEV;
 
-	handle = ACPI_HANDLE(dev);
+	handle = ACPI_HANDLE(&pdev->dev);
 	if (!handle)
 		return -ENODEV;
 
 	memset(&io, 0, sizeof(io));
 	io.addr_source = SI_ACPI;
-	dev_info(dev, "probing via ACPI\n");
+	dev_info(&pdev->dev, "probing via ACPI\n");
 
 	io.addr_info.acpi_info.acpi_handle = handle;
 
 	/* _IFT tells us the interface type: KCS, BT, etc */
 	status = acpi_evaluate_integer(handle, "_IFT", NULL, &tmp);
 	if (ACPI_FAILURE(status)) {
-		dev_err(dev, "Could not find ACPI IPMI interface type\n");
-		return -EINVAL;
+		dev_err(&pdev->dev,
+			"Could not find ACPI IPMI interface type\n");
+		goto err_free;
 	}
 
 	switch (tmp) {
@@ -348,19 +356,21 @@ static int acpi_ipmi_probe(struct platform_device *pdev)
 		io.si_type = SI_BT;
 		break;
 	case 4: /* SSIF, just ignore */
-		return -ENODEV;
+		rv = -ENODEV;
+		goto err_free;
 	default:
-		dev_info(dev, "unknown IPMI type %lld\n", tmp);
-		return -EINVAL;
+		dev_info(&pdev->dev, "unknown IPMI type %lld\n", tmp);
+		goto err_free;
 	}
 
-	io.dev = dev;
 	io.regsize = DEFAULT_REGSIZE;
 	io.regshift = 0;
 
 	res = ipmi_get_info_from_resources(pdev, &io);
-	if (!res)
-		return -EINVAL;
+	if (!res) {
+		rv = -EINVAL;
+		goto err_free;
+	}
 
 	/* If _GPE exists, use it; otherwise use standard interrupts */
 	status = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);
@@ -378,12 +388,17 @@ static int acpi_ipmi_probe(struct platform_device *pdev)
 
 	io.slave_addr = find_slave_address(&io, io.slave_addr);
 
-	dev_info(dev, "%pR regsize %d spacing %d irq %d\n",
+	io.dev = &pdev->dev;
+
+	dev_info(io.dev, "%pR regsize %d spacing %d irq %d\n",
 		 res, io.regsize, io.regspacing, io.irq);
 
 	request_module("acpi_ipmi");
 
 	return ipmi_si_add_smi(&io);
+
+err_free:
+	return rv;
 }
 
 static const struct acpi_device_id acpi_ipmi_match[] = {
@@ -411,9 +426,7 @@ static int ipmi_probe(struct platform_device *pdev)
 
 static int ipmi_remove(struct platform_device *pdev)
 {
-	ipmi_si_remove_by_dev(&pdev->dev);
-
-	return 0;
+	return ipmi_si_remove_by_dev(&pdev->dev);
 }
 
 static int pdev_match_name(struct device *dev, const void *data)
diff --git a/drivers/char/ipmi/ipmi_si_port_io.c b/drivers/char/ipmi/ipmi_si_port_io.c
old mode 100644
new mode 100755
diff --git a/drivers/char/ipmi/ipmi_si_sm.h b/drivers/char/ipmi/ipmi_si_sm.h
old mode 100644
new mode 100755
diff --git a/drivers/char/ipmi/ipmi_smic_sm.c b/drivers/char/ipmi/ipmi_smic_sm.c
old mode 100644
new mode 100755
diff --git a/drivers/char/ipmi/ipmi_ssif.c b/drivers/char/ipmi/ipmi_ssif.c
old mode 100644
new mode 100755
index 20d5af92966d..0416b9c9d410
--- a/drivers/char/ipmi/ipmi_ssif.c
+++ b/drivers/char/ipmi/ipmi_ssif.c
@@ -510,7 +510,7 @@ static int ipmi_ssif_thread(void *data)
 	return 0;
 }
 
-static void ssif_i2c_send(struct ssif_info *ssif_info,
+static int ssif_i2c_send(struct ssif_info *ssif_info,
 			ssif_i2c_done handler,
 			int read_write, int command,
 			unsigned char *data, unsigned int size)
@@ -522,6 +522,7 @@ static void ssif_i2c_send(struct ssif_info *ssif_info,
 	ssif_info->i2c_data = data;
 	ssif_info->i2c_size = size;
 	complete(&ssif_info->wake_thread);
+	return 0;
 }
 
 
@@ -530,12 +531,22 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 
 static void start_get(struct ssif_info *ssif_info)
 {
+	int rv;
+
 	ssif_info->rtc_us_timer = 0;
 	ssif_info->multi_pos = 0;
 
-	ssif_i2c_send(ssif_info, msg_done_handler, I2C_SMBUS_READ,
-		  SSIF_IPMI_RESPONSE,
-		  ssif_info->recv, I2C_SMBUS_BLOCK_DATA);
+	rv = ssif_i2c_send(ssif_info, msg_done_handler, I2C_SMBUS_READ,
+			  SSIF_IPMI_RESPONSE,
+			  ssif_info->recv, I2C_SMBUS_BLOCK_DATA);
+	if (rv < 0) {
+		/* request failed, just return the error. */
+		if (ssif_info->ssif_debug & SSIF_DEBUG_MSG)
+			dev_dbg(&ssif_info->client->dev,
+				"Error from i2c_non_blocking_op(5)\n");
+
+		msg_done_handler(ssif_info, -EIO, NULL, 0);
+	}
 }
 
 static void retry_timeout(struct timer_list *t)
@@ -609,6 +620,7 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 {
 	struct ipmi_smi_msg *msg;
 	unsigned long oflags, *flags;
+	int rv;
 
 	/*
 	 * We are single-threaded here, so no need for a lock until we
@@ -654,10 +666,17 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 		ssif_info->multi_len = len;
 		ssif_info->multi_pos = 1;
 
-		ssif_i2c_send(ssif_info, msg_done_handler, I2C_SMBUS_READ,
-			 SSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE,
-			 ssif_info->recv, I2C_SMBUS_BLOCK_DATA);
-		return;
+		rv = ssif_i2c_send(ssif_info, msg_done_handler, I2C_SMBUS_READ,
+				  SSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE,
+				  ssif_info->recv, I2C_SMBUS_BLOCK_DATA);
+		if (rv < 0) {
+			if (ssif_info->ssif_debug & SSIF_DEBUG_MSG)
+				dev_dbg(&ssif_info->client->dev,
+					"Error from i2c_non_blocking_op(1)\n");
+
+			result = -EIO;
+		} else
+			return;
 	} else if (ssif_info->multi_pos) {
 		/* Middle of multi-part read.  Start the next transaction. */
 		int i;
@@ -719,12 +738,19 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 
 			ssif_info->multi_pos++;
 
-			ssif_i2c_send(ssif_info, msg_done_handler,
-				  I2C_SMBUS_READ,
-				  SSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE,
-				  ssif_info->recv,
-				  I2C_SMBUS_BLOCK_DATA);
-			return;
+			rv = ssif_i2c_send(ssif_info, msg_done_handler,
+					   I2C_SMBUS_READ,
+					   SSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE,
+					   ssif_info->recv,
+					   I2C_SMBUS_BLOCK_DATA);
+			if (rv < 0) {
+				if (ssif_info->ssif_debug & SSIF_DEBUG_MSG)
+					dev_dbg(&ssif_info->client->dev,
+						"Error from ssif_i2c_send\n");
+
+				result = -EIO;
+			} else
+				return;
 		}
 	}
 
@@ -882,6 +908,8 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 static void msg_written_handler(struct ssif_info *ssif_info, int result,
 				unsigned char *data, unsigned int len)
 {
+	int rv;
+
 	/* We are single-threaded here, so no need for a lock. */
 	if (result < 0) {
 		ssif_info->retries_left--;
@@ -944,9 +972,18 @@ static void msg_written_handler(struct ssif_info *ssif_info, int result,
 			ssif_info->multi_data = NULL;
 		}
 
-		ssif_i2c_send(ssif_info, msg_written_handler,
-			  I2C_SMBUS_WRITE, cmd,
-			  data_to_send, I2C_SMBUS_BLOCK_DATA);
+		rv = ssif_i2c_send(ssif_info, msg_written_handler,
+				   I2C_SMBUS_WRITE, cmd,
+				   data_to_send, I2C_SMBUS_BLOCK_DATA);
+		if (rv < 0) {
+			/* request failed, just return the error. */
+			ssif_inc_stat(ssif_info, send_errors);
+
+			if (ssif_info->ssif_debug & SSIF_DEBUG_MSG)
+				dev_dbg(&ssif_info->client->dev,
+					"Error from i2c_non_blocking_op(3)\n");
+			msg_done_handler(ssif_info, -EIO, NULL, 0);
+		}
 	} else {
 		/* Ready to request the result. */
 		unsigned long oflags, *flags;
@@ -975,6 +1012,7 @@ static void msg_written_handler(struct ssif_info *ssif_info, int result,
 
 static int start_resend(struct ssif_info *ssif_info)
 {
+	int rv;
 	int command;
 
 	ssif_info->got_alert = false;
@@ -996,9 +1034,12 @@ static int start_resend(struct ssif_info *ssif_info)
 		ssif_info->data[0] = ssif_info->data_len;
 	}
 
-	ssif_i2c_send(ssif_info, msg_written_handler, I2C_SMBUS_WRITE,
-		   command, ssif_info->data, I2C_SMBUS_BLOCK_DATA);
-	return 0;
+	rv = ssif_i2c_send(ssif_info, msg_written_handler, I2C_SMBUS_WRITE,
+			  command, ssif_info->data, I2C_SMBUS_BLOCK_DATA);
+	if (rv && (ssif_info->ssif_debug & SSIF_DEBUG_MSG))
+		dev_dbg(&ssif_info->client->dev,
+			"Error from i2c_non_blocking_op(4)\n");
+	return rv;
 }
 
 static int start_send(struct ssif_info *ssif_info,
diff --git a/drivers/char/ipmi/ipmi_watchdog.c b/drivers/char/ipmi/ipmi_watchdog.c
old mode 100644
new mode 100755
index 883b4a341012..f78156d93c3f
--- a/drivers/char/ipmi/ipmi_watchdog.c
+++ b/drivers/char/ipmi/ipmi_watchdog.c
@@ -342,17 +342,13 @@ static atomic_t msg_tofree = ATOMIC_INIT(0);
 static DECLARE_COMPLETION(msg_wait);
 static void msg_free_smi(struct ipmi_smi_msg *msg)
 {
-	if (atomic_dec_and_test(&msg_tofree)) {
-		if (!oops_in_progress)
-			complete(&msg_wait);
-	}
+	if (atomic_dec_and_test(&msg_tofree))
+		complete(&msg_wait);
 }
 static void msg_free_recv(struct ipmi_recv_msg *msg)
 {
-	if (atomic_dec_and_test(&msg_tofree)) {
-		if (!oops_in_progress)
-			complete(&msg_wait);
-	}
+	if (atomic_dec_and_test(&msg_tofree))
+		complete(&msg_wait);
 }
 static struct ipmi_smi_msg smi_msg = {
 	.done = msg_free_smi
@@ -375,18 +371,16 @@ static int __ipmi_set_timeout(struct ipmi_smi_msg  *smi_msg,
 	data[0] = 0;
 	WDOG_SET_TIMER_USE(data[0], WDOG_TIMER_USE_SMS_OS);
 
-	if (ipmi_watchdog_state != WDOG_TIMEOUT_NONE) {
-		if ((ipmi_version_major > 1) ||
-		    ((ipmi_version_major == 1) && (ipmi_version_minor >= 5))) {
-			/* This is an IPMI 1.5-only feature. */
-			data[0] |= WDOG_DONT_STOP_ON_SET;
-		} else {
-			/*
-			 * In ipmi 1.0, setting the timer stops the watchdog, we
-			 * need to start it back up again.
-			 */
-			hbnow = 1;
-		}
+	if ((ipmi_version_major > 1)
+	    || ((ipmi_version_major == 1) && (ipmi_version_minor >= 5))) {
+		/* This is an IPMI 1.5-only feature. */
+		data[0] |= WDOG_DONT_STOP_ON_SET;
+	} else if (ipmi_watchdog_state != WDOG_TIMEOUT_NONE) {
+		/*
+		 * In ipmi 1.0, setting the timer stops the watchdog, we
+		 * need to start it back up again.
+		 */
+		hbnow = 1;
 	}
 
 	data[1] = 0;
@@ -438,10 +432,8 @@ static int _ipmi_set_timeout(int do_heartbeat)
 	rv = __ipmi_set_timeout(&smi_msg,
 				&recv_msg,
 				&send_heartbeat_now);
-	if (rv) {
-		atomic_set(&msg_tofree, 0);
+	if (rv)
 		return rv;
-	}
 
 	wait_for_completion(&msg_wait);
 
@@ -503,7 +495,7 @@ static void panic_halt_ipmi_heartbeat(void)
 	msg.cmd = IPMI_WDOG_RESET_TIMER;
 	msg.data = NULL;
 	msg.data_len = 0;
-	atomic_add(2, &panic_done_count);
+	atomic_add(1, &panic_done_count);
 	rv = ipmi_request_supply_msgs(watchdog_user,
 				      (struct ipmi_addr *) &addr,
 				      0,
@@ -513,7 +505,7 @@ static void panic_halt_ipmi_heartbeat(void)
 				      &panic_halt_heartbeat_recv_msg,
 				      1);
 	if (rv)
-		atomic_sub(2, &panic_done_count);
+		atomic_sub(1, &panic_done_count);
 }
 
 static struct ipmi_smi_msg panic_halt_smi_msg = {
@@ -537,12 +529,12 @@ static void panic_halt_ipmi_set_timeout(void)
 	/* Wait for the messages to be free. */
 	while (atomic_read(&panic_done_count) != 0)
 		ipmi_poll_interface(watchdog_user);
-	atomic_add(2, &panic_done_count);
+	atomic_add(1, &panic_done_count);
 	rv = __ipmi_set_timeout(&panic_halt_smi_msg,
 				&panic_halt_recv_msg,
 				&send_heartbeat_now);
 	if (rv) {
-		atomic_sub(2, &panic_done_count);
+		atomic_sub(1, &panic_done_count);
 		pr_warn("Unable to extend the watchdog timeout\n");
 	} else {
 		if (send_heartbeat_now)
@@ -586,7 +578,6 @@ static int __ipmi_heartbeat(void)
 				      &recv_msg,
 				      1);
 	if (rv) {
-		atomic_set(&msg_tofree, 0);
 		pr_warn("heartbeat send failure: %d\n", rv);
 		return rv;
 	}
diff --git a/drivers/char/ipmi/kcs_bmc.c b/drivers/char/ipmi/kcs_bmc.c
old mode 100644
new mode 100755
index 03d02a848f3a..f292e74bd4a5
--- a/drivers/char/ipmi/kcs_bmc.c
+++ b/drivers/char/ipmi/kcs_bmc.c
@@ -1,189 +1,458 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (c) 2015-2018, Intel Corporation.
- * Copyright (c) 2021, IBM Corp.
  */
 
-#include <linux/device.h>
-#include <linux/list.h>
+#define pr_fmt(fmt) "kcs-bmc: " fmt
+
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/ipmi_bmc.h>
 #include <linux/module.h>
-#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
 
 #include "kcs_bmc.h"
 
-/* Implement both the device and client interfaces here */
-#include "kcs_bmc_device.h"
-#include "kcs_bmc_client.h"
+#define DEVICE_NAME "ipmi-kcs"
+
+#define KCS_MSG_BUFSIZ    1000
+
+#define KCS_ZERO_DATA     0
 
-/* Record registered devices and drivers */
-static DEFINE_MUTEX(kcs_bmc_lock);
-static LIST_HEAD(kcs_bmc_devices);
-static LIST_HEAD(kcs_bmc_drivers);
 
-/* Consumer data access */
+/* IPMI 2.0 - Table 9-1, KCS Interface Status Register Bits */
+#define KCS_STATUS_STATE(state) (state << 6)
+#define KCS_STATUS_STATE_MASK   GENMASK(7, 6)
+#define KCS_STATUS_CMD_DAT      BIT(3)
+#define KCS_STATUS_SMS_ATN      BIT(2)
+#define KCS_STATUS_IBF          BIT(1)
+#define KCS_STATUS_OBF          BIT(0)
 
-u8 kcs_bmc_read_data(struct kcs_bmc_device *kcs_bmc)
+/* IPMI 2.0 - Table 9-2, KCS Interface State Bits */
+enum kcs_states {
+	IDLE_STATE  = 0,
+	READ_STATE  = 1,
+	WRITE_STATE = 2,
+	ERROR_STATE = 3,
+};
+
+/* IPMI 2.0 - Table 9-3, KCS Interface Control Codes */
+#define KCS_CMD_GET_STATUS_ABORT  0x60
+#define KCS_CMD_WRITE_START       0x61
+#define KCS_CMD_WRITE_END         0x62
+#define KCS_CMD_READ_BYTE         0x68
+
+static inline u8 read_data(struct kcs_bmc *kcs_bmc)
 {
-	return kcs_bmc->ops->io_inputb(kcs_bmc, kcs_bmc->ioreg.idr);
+	return kcs_bmc->io_inputb(kcs_bmc, kcs_bmc->ioreg.idr);
 }
-EXPORT_SYMBOL(kcs_bmc_read_data);
 
-void kcs_bmc_write_data(struct kcs_bmc_device *kcs_bmc, u8 data)
+static inline void write_data(struct kcs_bmc *kcs_bmc, u8 data)
 {
-	kcs_bmc->ops->io_outputb(kcs_bmc, kcs_bmc->ioreg.odr, data);
+	kcs_bmc->io_outputb(kcs_bmc, kcs_bmc->ioreg.odr, data);
 }
-EXPORT_SYMBOL(kcs_bmc_write_data);
 
-u8 kcs_bmc_read_status(struct kcs_bmc_device *kcs_bmc)
+static inline u8 read_status(struct kcs_bmc *kcs_bmc)
 {
-	return kcs_bmc->ops->io_inputb(kcs_bmc, kcs_bmc->ioreg.str);
+	return kcs_bmc->io_inputb(kcs_bmc, kcs_bmc->ioreg.str);
 }
-EXPORT_SYMBOL(kcs_bmc_read_status);
 
-void kcs_bmc_write_status(struct kcs_bmc_device *kcs_bmc, u8 data)
+static inline void write_status(struct kcs_bmc *kcs_bmc, u8 data)
 {
-	kcs_bmc->ops->io_outputb(kcs_bmc, kcs_bmc->ioreg.str, data);
+	kcs_bmc->io_outputb(kcs_bmc, kcs_bmc->ioreg.str, data);
 }
-EXPORT_SYMBOL(kcs_bmc_write_status);
 
-void kcs_bmc_update_status(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 val)
+static void update_status_bits(struct kcs_bmc *kcs_bmc, u8 mask, u8 val)
 {
-	kcs_bmc->ops->io_updateb(kcs_bmc, kcs_bmc->ioreg.str, mask, val);
+	u8 tmp = read_status(kcs_bmc);
+
+	tmp &= ~mask;
+	tmp |= val & mask;
+
+	write_status(kcs_bmc, tmp);
 }
-EXPORT_SYMBOL(kcs_bmc_update_status);
 
-irqreturn_t kcs_bmc_handle_event(struct kcs_bmc_device *kcs_bmc)
+static inline void set_state(struct kcs_bmc *kcs_bmc, u8 state)
 {
-	struct kcs_bmc_client *client;
-	irqreturn_t rc = IRQ_NONE;
+	update_status_bits(kcs_bmc, KCS_STATUS_STATE_MASK,
+					KCS_STATUS_STATE(state));
+}
 
-	spin_lock(&kcs_bmc->lock);
-	client = kcs_bmc->client;
-	if (client)
-		rc = client->ops->event(client);
-	spin_unlock(&kcs_bmc->lock);
+static void kcs_force_abort(struct kcs_bmc *kcs_bmc)
+{
+	set_state(kcs_bmc, ERROR_STATE);
+	read_data(kcs_bmc);
+	write_data(kcs_bmc, KCS_ZERO_DATA);
 
-	return rc;
+	kcs_bmc->phase = KCS_PHASE_ERROR;
+	kcs_bmc->data_in_avail = false;
+	kcs_bmc->data_in_idx = 0;
 }
-EXPORT_SYMBOL(kcs_bmc_handle_event);
 
-int kcs_bmc_enable_device(struct kcs_bmc_device *kcs_bmc, struct kcs_bmc_client *client)
+static void kcs_bmc_handle_data(struct kcs_bmc *kcs_bmc)
 {
-	int rc;
+	u8 data;
+
+	switch (kcs_bmc->phase) {
+	case KCS_PHASE_WRITE_START:
+		kcs_bmc->phase = KCS_PHASE_WRITE_DATA;
+		fallthrough;
+
+	case KCS_PHASE_WRITE_DATA:
+		if (kcs_bmc->data_in_idx < KCS_MSG_BUFSIZ) {
+			set_state(kcs_bmc, WRITE_STATE);
+			write_data(kcs_bmc, KCS_ZERO_DATA);
+			kcs_bmc->data_in[kcs_bmc->data_in_idx++] =
+						read_data(kcs_bmc);
+		} else {
+			kcs_force_abort(kcs_bmc);
+			kcs_bmc->error = KCS_LENGTH_ERROR;
+		}
+		break;
+
+	case KCS_PHASE_WRITE_END_CMD:
+		if (kcs_bmc->data_in_idx < KCS_MSG_BUFSIZ) {
+			set_state(kcs_bmc, READ_STATE);
+			kcs_bmc->data_in[kcs_bmc->data_in_idx++] =
+						read_data(kcs_bmc);
+			kcs_bmc->phase = KCS_PHASE_WRITE_DONE;
+			kcs_bmc->data_in_avail = true;
+			wake_up_interruptible(&kcs_bmc->queue);
+		} else {
+			kcs_force_abort(kcs_bmc);
+			kcs_bmc->error = KCS_LENGTH_ERROR;
+		}
+		break;
+
+	case KCS_PHASE_READ:
+		if (kcs_bmc->data_out_idx == kcs_bmc->data_out_len)
+			set_state(kcs_bmc, IDLE_STATE);
+
+		data = read_data(kcs_bmc);
+		if (data != KCS_CMD_READ_BYTE) {
+			set_state(kcs_bmc, ERROR_STATE);
+			write_data(kcs_bmc, KCS_ZERO_DATA);
+			break;
+		}
+
+		if (kcs_bmc->data_out_idx == kcs_bmc->data_out_len) {
+			write_data(kcs_bmc, KCS_ZERO_DATA);
+			kcs_bmc->phase = KCS_PHASE_IDLE;
+			break;
+		}
+
+		write_data(kcs_bmc,
+			kcs_bmc->data_out[kcs_bmc->data_out_idx++]);
+		break;
+
+	case KCS_PHASE_ABORT_ERROR1:
+		set_state(kcs_bmc, READ_STATE);
+		read_data(kcs_bmc);
+		write_data(kcs_bmc, kcs_bmc->error);
+		kcs_bmc->phase = KCS_PHASE_ABORT_ERROR2;
+		break;
+
+	case KCS_PHASE_ABORT_ERROR2:
+		set_state(kcs_bmc, IDLE_STATE);
+		read_data(kcs_bmc);
+		write_data(kcs_bmc, KCS_ZERO_DATA);
+		kcs_bmc->phase = KCS_PHASE_IDLE;
+		break;
+
+	default:
+		kcs_force_abort(kcs_bmc);
+		break;
+	}
+}
 
-	spin_lock_irq(&kcs_bmc->lock);
-	if (kcs_bmc->client) {
-		rc = -EBUSY;
-	} else {
-		u8 mask = KCS_BMC_EVENT_TYPE_IBF;
+static void kcs_bmc_handle_cmd(struct kcs_bmc *kcs_bmc)
+{
+	u8 cmd;
+
+	set_state(kcs_bmc, WRITE_STATE);
+	write_data(kcs_bmc, KCS_ZERO_DATA);
+
+	cmd = read_data(kcs_bmc);
+	switch (cmd) {
+	case KCS_CMD_WRITE_START:
+		kcs_bmc->phase = KCS_PHASE_WRITE_START;
+		kcs_bmc->error = KCS_NO_ERROR;
+		kcs_bmc->data_in_avail = false;
+		kcs_bmc->data_in_idx = 0;
+		break;
+
+	case KCS_CMD_WRITE_END:
+		if (kcs_bmc->phase != KCS_PHASE_WRITE_DATA) {
+			kcs_force_abort(kcs_bmc);
+			break;
+		}
+
+		kcs_bmc->phase = KCS_PHASE_WRITE_END_CMD;
+		break;
+
+	case KCS_CMD_GET_STATUS_ABORT:
+		if (kcs_bmc->error == KCS_NO_ERROR)
+			kcs_bmc->error = KCS_ABORTED_BY_COMMAND;
+
+		kcs_bmc->phase = KCS_PHASE_ABORT_ERROR1;
+		kcs_bmc->data_in_avail = false;
+		kcs_bmc->data_in_idx = 0;
+		break;
+
+	default:
+		kcs_force_abort(kcs_bmc);
+		kcs_bmc->error = KCS_ILLEGAL_CONTROL_CODE;
+		break;
+	}
+}
 
-		kcs_bmc->client = client;
-		kcs_bmc_update_event_mask(kcs_bmc, mask, mask);
-		rc = 0;
+int kcs_bmc_handle_event(struct kcs_bmc *kcs_bmc)
+{
+	unsigned long flags;
+	int ret = -ENODATA;
+	u8 status;
+
+	spin_lock_irqsave(&kcs_bmc->lock, flags);
+
+	status = read_status(kcs_bmc);
+	if (status & KCS_STATUS_IBF) {
+		if (!kcs_bmc->running)
+			kcs_force_abort(kcs_bmc);
+		else if (status & KCS_STATUS_CMD_DAT)
+			kcs_bmc_handle_cmd(kcs_bmc);
+		else
+			kcs_bmc_handle_data(kcs_bmc);
+
+		ret = 0;
 	}
-	spin_unlock_irq(&kcs_bmc->lock);
 
-	return rc;
+	spin_unlock_irqrestore(&kcs_bmc->lock, flags);
+
+	return ret;
 }
-EXPORT_SYMBOL(kcs_bmc_enable_device);
+EXPORT_SYMBOL(kcs_bmc_handle_event);
 
-void kcs_bmc_disable_device(struct kcs_bmc_device *kcs_bmc, struct kcs_bmc_client *client)
+static inline struct kcs_bmc *to_kcs_bmc(struct file *filp)
 {
+	return container_of(filp->private_data, struct kcs_bmc, miscdev);
+}
+
+static int kcs_bmc_open(struct inode *inode, struct file *filp)
+{
+	struct kcs_bmc *kcs_bmc = to_kcs_bmc(filp);
+	int ret = 0;
+
 	spin_lock_irq(&kcs_bmc->lock);
-	if (client == kcs_bmc->client) {
-		u8 mask = KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE;
+	if (!kcs_bmc->running)
+		kcs_bmc->running = 1;
+	else
+		ret = -EBUSY;
+	spin_unlock_irq(&kcs_bmc->lock);
 
-		kcs_bmc_update_event_mask(kcs_bmc, mask, 0);
-		kcs_bmc->client = NULL;
-	}
+	return ret;
+}
+
+static __poll_t kcs_bmc_poll(struct file *filp, poll_table *wait)
+{
+	struct kcs_bmc *kcs_bmc = to_kcs_bmc(filp);
+	__poll_t mask = 0;
+
+	poll_wait(filp, &kcs_bmc->queue, wait);
+
+	spin_lock_irq(&kcs_bmc->lock);
+	if (kcs_bmc->data_in_avail)
+		mask |= EPOLLIN;
 	spin_unlock_irq(&kcs_bmc->lock);
+
+	return mask;
 }
-EXPORT_SYMBOL(kcs_bmc_disable_device);
 
-int kcs_bmc_add_device(struct kcs_bmc_device *kcs_bmc)
+static ssize_t kcs_bmc_read(struct file *filp, char __user *buf,
+			    size_t count, loff_t *ppos)
 {
-	struct kcs_bmc_driver *drv;
-	int error = 0;
-	int rc;
+	struct kcs_bmc *kcs_bmc = to_kcs_bmc(filp);
+	bool data_avail;
+	size_t data_len;
+	ssize_t ret;
 
-	spin_lock_init(&kcs_bmc->lock);
-	kcs_bmc->client = NULL;
-
-	mutex_lock(&kcs_bmc_lock);
-	list_add(&kcs_bmc->entry, &kcs_bmc_devices);
-	list_for_each_entry(drv, &kcs_bmc_drivers, entry) {
-		rc = drv->ops->add_device(kcs_bmc);
-		if (!rc)
-			continue;
-
-		dev_err(kcs_bmc->dev, "Failed to add chardev for KCS channel %d: %d",
-			kcs_bmc->channel, rc);
-		error = rc;
+	if (!(filp->f_flags & O_NONBLOCK))
+		wait_event_interruptible(kcs_bmc->queue,
+					 kcs_bmc->data_in_avail);
+
+	mutex_lock(&kcs_bmc->mutex);
+
+	spin_lock_irq(&kcs_bmc->lock);
+	data_avail = kcs_bmc->data_in_avail;
+	if (data_avail) {
+		data_len = kcs_bmc->data_in_idx;
+		memcpy(kcs_bmc->kbuffer, kcs_bmc->data_in, data_len);
+	}
+	spin_unlock_irq(&kcs_bmc->lock);
+
+	if (!data_avail) {
+		ret = -EAGAIN;
+		goto out_unlock;
 	}
-	mutex_unlock(&kcs_bmc_lock);
 
-	return error;
+	if (count < data_len) {
+		pr_err("channel=%u with too large data : %zu\n",
+			kcs_bmc->channel, data_len);
+
+		spin_lock_irq(&kcs_bmc->lock);
+		kcs_force_abort(kcs_bmc);
+		spin_unlock_irq(&kcs_bmc->lock);
+
+		ret = -EOVERFLOW;
+		goto out_unlock;
+	}
+
+	if (copy_to_user(buf, kcs_bmc->kbuffer, data_len)) {
+		ret = -EFAULT;
+		goto out_unlock;
+	}
+
+	ret = data_len;
+
+	spin_lock_irq(&kcs_bmc->lock);
+	if (kcs_bmc->phase == KCS_PHASE_WRITE_DONE) {
+		kcs_bmc->phase = KCS_PHASE_WAIT_READ;
+		kcs_bmc->data_in_avail = false;
+		kcs_bmc->data_in_idx = 0;
+	} else {
+		ret = -EAGAIN;
+	}
+	spin_unlock_irq(&kcs_bmc->lock);
+
+out_unlock:
+	mutex_unlock(&kcs_bmc->mutex);
+
+	return ret;
 }
-EXPORT_SYMBOL(kcs_bmc_add_device);
 
-void kcs_bmc_remove_device(struct kcs_bmc_device *kcs_bmc)
+static ssize_t kcs_bmc_write(struct file *filp, const char __user *buf,
+			     size_t count, loff_t *ppos)
 {
-	struct kcs_bmc_driver *drv;
-	int rc;
+	struct kcs_bmc *kcs_bmc = to_kcs_bmc(filp);
+	ssize_t ret;
+
+	/* a minimum response size '3' : netfn + cmd + ccode */
+	if (count < 3 || count > KCS_MSG_BUFSIZ)
+		return -EINVAL;
+
+	mutex_lock(&kcs_bmc->mutex);
+
+	if (copy_from_user(kcs_bmc->kbuffer, buf, count)) {
+		ret = -EFAULT;
+		goto out_unlock;
+	}
 
-	mutex_lock(&kcs_bmc_lock);
-	list_del(&kcs_bmc->entry);
-	list_for_each_entry(drv, &kcs_bmc_drivers, entry) {
-		rc = drv->ops->remove_device(kcs_bmc);
-		if (rc)
-			dev_err(kcs_bmc->dev, "Failed to remove chardev for KCS channel %d: %d",
-				kcs_bmc->channel, rc);
+	spin_lock_irq(&kcs_bmc->lock);
+	if (kcs_bmc->phase == KCS_PHASE_WAIT_READ) {
+		kcs_bmc->phase = KCS_PHASE_READ;
+		kcs_bmc->data_out_idx = 1;
+		kcs_bmc->data_out_len = count;
+		memcpy(kcs_bmc->data_out, kcs_bmc->kbuffer, count);
+		write_data(kcs_bmc, kcs_bmc->data_out[0]);
+		ret = count;
+	} else {
+		ret = -EINVAL;
 	}
-	mutex_unlock(&kcs_bmc_lock);
+	spin_unlock_irq(&kcs_bmc->lock);
+
+out_unlock:
+	mutex_unlock(&kcs_bmc->mutex);
+
+	return ret;
 }
-EXPORT_SYMBOL(kcs_bmc_remove_device);
 
-void kcs_bmc_register_driver(struct kcs_bmc_driver *drv)
+static long kcs_bmc_ioctl(struct file *filp, unsigned int cmd,
+			  unsigned long arg)
 {
-	struct kcs_bmc_device *kcs_bmc;
-	int rc;
+	struct kcs_bmc *kcs_bmc = to_kcs_bmc(filp);
+	long ret = 0;
+
+	spin_lock_irq(&kcs_bmc->lock);
+
+	switch (cmd) {
+	case IPMI_BMC_IOCTL_SET_SMS_ATN:
+		update_status_bits(kcs_bmc, KCS_STATUS_SMS_ATN,
+				   KCS_STATUS_SMS_ATN);
+		break;
+
+	case IPMI_BMC_IOCTL_CLEAR_SMS_ATN:
+		update_status_bits(kcs_bmc, KCS_STATUS_SMS_ATN,
+				   0);
+		break;
 
-	mutex_lock(&kcs_bmc_lock);
-	list_add(&drv->entry, &kcs_bmc_drivers);
-	list_for_each_entry(kcs_bmc, &kcs_bmc_devices, entry) {
-		rc = drv->ops->add_device(kcs_bmc);
-		if (rc)
-			dev_err(kcs_bmc->dev, "Failed to add driver for KCS channel %d: %d",
-				kcs_bmc->channel, rc);
+	case IPMI_BMC_IOCTL_FORCE_ABORT:
+		kcs_force_abort(kcs_bmc);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
 	}
-	mutex_unlock(&kcs_bmc_lock);
+
+	spin_unlock_irq(&kcs_bmc->lock);
+
+	return ret;
 }
-EXPORT_SYMBOL(kcs_bmc_register_driver);
 
-void kcs_bmc_unregister_driver(struct kcs_bmc_driver *drv)
+static int kcs_bmc_release(struct inode *inode, struct file *filp)
 {
-	struct kcs_bmc_device *kcs_bmc;
-	int rc;
+	struct kcs_bmc *kcs_bmc = to_kcs_bmc(filp);
 
-	mutex_lock(&kcs_bmc_lock);
-	list_del(&drv->entry);
-	list_for_each_entry(kcs_bmc, &kcs_bmc_devices, entry) {
-		rc = drv->ops->remove_device(kcs_bmc);
-		if (rc)
-			dev_err(kcs_bmc->dev, "Failed to remove driver for KCS channel %d: %d",
-				kcs_bmc->channel, rc);
-	}
-	mutex_unlock(&kcs_bmc_lock);
+	spin_lock_irq(&kcs_bmc->lock);
+	kcs_bmc->running = 0;
+	kcs_force_abort(kcs_bmc);
+	spin_unlock_irq(&kcs_bmc->lock);
+
+	return 0;
 }
-EXPORT_SYMBOL(kcs_bmc_unregister_driver);
 
-void kcs_bmc_update_event_mask(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 events)
+static const struct file_operations kcs_bmc_fops = {
+	.owner          = THIS_MODULE,
+	.open           = kcs_bmc_open,
+	.read           = kcs_bmc_read,
+	.write          = kcs_bmc_write,
+	.release        = kcs_bmc_release,
+	.poll           = kcs_bmc_poll,
+	.unlocked_ioctl = kcs_bmc_ioctl,
+};
+
+struct kcs_bmc *kcs_bmc_alloc(struct device *dev, int sizeof_priv, u32 channel)
 {
-	kcs_bmc->ops->irq_mask_update(kcs_bmc, mask, events);
+	struct kcs_bmc *kcs_bmc;
+
+	kcs_bmc = devm_kzalloc(dev, sizeof(*kcs_bmc) + sizeof_priv, GFP_KERNEL);
+	if (!kcs_bmc)
+		return NULL;
+
+	spin_lock_init(&kcs_bmc->lock);
+	kcs_bmc->channel = channel;
+
+	mutex_init(&kcs_bmc->mutex);
+	init_waitqueue_head(&kcs_bmc->queue);
+
+	kcs_bmc->data_in = devm_kmalloc(dev, KCS_MSG_BUFSIZ, GFP_KERNEL);
+	kcs_bmc->data_out = devm_kmalloc(dev, KCS_MSG_BUFSIZ, GFP_KERNEL);
+	kcs_bmc->kbuffer = devm_kmalloc(dev, KCS_MSG_BUFSIZ, GFP_KERNEL);
+
+	kcs_bmc->miscdev.minor = MISC_DYNAMIC_MINOR;
+	kcs_bmc->miscdev.name = devm_kasprintf(dev, GFP_KERNEL, "%s%u",
+					       DEVICE_NAME, channel);
+	if (!kcs_bmc->data_in || !kcs_bmc->data_out || !kcs_bmc->kbuffer ||
+	    !kcs_bmc->miscdev.name)
+		return NULL;
+	kcs_bmc->miscdev.fops = &kcs_bmc_fops;
+
+	return kcs_bmc;
 }
-EXPORT_SYMBOL(kcs_bmc_update_event_mask);
+EXPORT_SYMBOL(kcs_bmc_alloc);
 
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Haiyue Wang <haiyue.wang@linux.intel.com>");
-MODULE_AUTHOR("Andrew Jeffery <andrew@aj.id.au>");
 MODULE_DESCRIPTION("KCS BMC to handle the IPMI request from system software");
diff --git a/drivers/char/ipmi/kcs_bmc.h b/drivers/char/ipmi/kcs_bmc.h
old mode 100644
new mode 100755
index fa408b802c79..eb9ea4ce78b8
--- a/drivers/char/ipmi/kcs_bmc.h
+++ b/drivers/char/ipmi/kcs_bmc.h
@@ -6,14 +6,54 @@
 #ifndef __KCS_BMC_H__
 #define __KCS_BMC_H__
 
-#include <linux/list.h>
+#include <linux/miscdevice.h>
 
-#define KCS_BMC_EVENT_TYPE_OBE	BIT(0)
-#define KCS_BMC_EVENT_TYPE_IBF	BIT(1)
+/* Different phases of the KCS BMC module.
+ *  KCS_PHASE_IDLE:
+ *            BMC should not be expecting nor sending any data.
+ *  KCS_PHASE_WRITE_START:
+ *            BMC is receiving a WRITE_START command from system software.
+ *  KCS_PHASE_WRITE_DATA:
+ *            BMC is receiving a data byte from system software.
+ *  KCS_PHASE_WRITE_END_CMD:
+ *            BMC is waiting a last data byte from system software.
+ *  KCS_PHASE_WRITE_DONE:
+ *            BMC has received the whole request from system software.
+ *  KCS_PHASE_WAIT_READ:
+ *            BMC is waiting the response from the upper IPMI service.
+ *  KCS_PHASE_READ:
+ *            BMC is transferring the response to system software.
+ *  KCS_PHASE_ABORT_ERROR1:
+ *            BMC is waiting error status request from system software.
+ *  KCS_PHASE_ABORT_ERROR2:
+ *            BMC is waiting for idle status afer error from system software.
+ *  KCS_PHASE_ERROR:
+ *            BMC has detected a protocol violation at the interface level.
+ */
+enum kcs_phases {
+	KCS_PHASE_IDLE,
+
+	KCS_PHASE_WRITE_START,
+	KCS_PHASE_WRITE_DATA,
+	KCS_PHASE_WRITE_END_CMD,
+	KCS_PHASE_WRITE_DONE,
 
-#define KCS_BMC_STR_OBF		BIT(0)
-#define KCS_BMC_STR_IBF		BIT(1)
-#define KCS_BMC_STR_CMD_DAT	BIT(3)
+	KCS_PHASE_WAIT_READ,
+	KCS_PHASE_READ,
+
+	KCS_PHASE_ABORT_ERROR1,
+	KCS_PHASE_ABORT_ERROR2,
+	KCS_PHASE_ERROR
+};
+
+/* IPMI 2.0 - Table 9-4, KCS Interface Status Codes */
+enum kcs_errors {
+	KCS_NO_ERROR                = 0x00,
+	KCS_ABORTED_BY_COMMAND      = 0x01,
+	KCS_ILLEGAL_CONTROL_CODE    = 0x02,
+	KCS_LENGTH_ERROR            = 0x06,
+	KCS_UNSPECIFIED_ERROR       = 0xFF
+};
 
 /* IPMI 2.0 - 9.5, KCS Interface Registers
  * @idr: Input Data Register
@@ -26,21 +66,43 @@ struct kcs_ioreg {
 	u32 str;
 };
 
-struct kcs_bmc_device_ops;
-struct kcs_bmc_client;
-
-struct kcs_bmc_device {
-	struct list_head entry;
+struct kcs_bmc {
+	spinlock_t lock;
 
-	struct device *dev;
 	u32 channel;
+	int running;
 
+	/* Setup by BMC KCS controller driver */
 	struct kcs_ioreg ioreg;
+	u8 (*io_inputb)(struct kcs_bmc *kcs_bmc, u32 reg);
+	void (*io_outputb)(struct kcs_bmc *kcs_bmc, u32 reg, u8 b);
 
-	const struct kcs_bmc_device_ops *ops;
+	enum kcs_phases phase;
+	enum kcs_errors error;
 
-	spinlock_t lock;
-	struct kcs_bmc_client *client;
+	wait_queue_head_t queue;
+	bool data_in_avail;
+	int  data_in_idx;
+	u8  *data_in;
+
+	int  data_out_idx;
+	int  data_out_len;
+	u8  *data_out;
+
+	struct mutex mutex;
+	u8 *kbuffer;
+
+	struct miscdevice miscdev;
+
+	unsigned long priv[];
 };
 
+static inline void *kcs_bmc_priv(struct kcs_bmc *kcs_bmc)
+{
+	return kcs_bmc->priv;
+}
+
+int kcs_bmc_handle_event(struct kcs_bmc *kcs_bmc);
+struct kcs_bmc *kcs_bmc_alloc(struct device *dev, int sizeof_priv,
+					u32 channel);
 #endif /* __KCS_BMC_H__ */
diff --git a/drivers/char/ipmi/kcs_bmc_aspeed.c b/drivers/char/ipmi/kcs_bmc_aspeed.c
old mode 100644
new mode 100755
index b555286016b1..5cc46c35de6f
--- a/drivers/char/ipmi/kcs_bmc_aspeed.c
+++ b/drivers/char/ipmi/kcs_bmc_aspeed.c
@@ -9,12 +9,10 @@
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
-#include <linux/irq.h>
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
-#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/poll.h>
 #include <linux/regmap.h>
@@ -22,53 +20,24 @@
 #include <linux/slab.h>
 #include <linux/timer.h>
 
-#include "kcs_bmc_device.h"
+#include "kcs_bmc.h"
 
 
 #define DEVICE_NAME     "ast-kcs-bmc"
 
 #define KCS_CHANNEL_MAX     4
 
-/*
- * Field class descriptions
- *
- * LPCyE	Enable LPC channel y
- * IBFIEy	Input Buffer Full IRQ Enable for LPC channel y
- * IRQxEy	Assert SerIRQ x for LPC channel y (Deprecated, use IDyIRQX, IRQXEy)
- * IDyIRQX	Use the specified 4-bit SerIRQ for LPC channel y
- * SELyIRQX	SerIRQ polarity for LPC channel y (low: 0, high: 1)
- * IRQXEy	Assert the SerIRQ specified in IDyIRQX for LPC channel y
- */
-
-#define LPC_TYIRQX_LOW       0b00
-#define LPC_TYIRQX_HIGH      0b01
-#define LPC_TYIRQX_RSVD      0b10
-#define LPC_TYIRQX_RISING    0b11
-
 #define LPC_HICR0            0x000
 #define     LPC_HICR0_LPC3E          BIT(7)
 #define     LPC_HICR0_LPC2E          BIT(6)
 #define     LPC_HICR0_LPC1E          BIT(5)
 #define LPC_HICR2            0x008
-#define     LPC_HICR2_IBFIE3         BIT(3)
-#define     LPC_HICR2_IBFIE2         BIT(2)
-#define     LPC_HICR2_IBFIE1         BIT(1)
+#define     LPC_HICR2_IBFIF3         BIT(3)
+#define     LPC_HICR2_IBFIF2         BIT(2)
+#define     LPC_HICR2_IBFIF1         BIT(1)
 #define LPC_HICR4            0x010
 #define     LPC_HICR4_LADR12AS       BIT(7)
 #define     LPC_HICR4_KCSENBL        BIT(2)
-#define LPC_SIRQCR0	     0x070
-/* IRQ{12,1}E1 are deprecated as of AST2600 A3 but necessary for prior chips */
-#define     LPC_SIRQCR0_IRQ12E1	     BIT(1)
-#define     LPC_SIRQCR0_IRQ1E1	     BIT(0)
-#define LPC_HICR5	     0x080
-#define     LPC_HICR5_ID3IRQX_MASK   GENMASK(23, 20)
-#define     LPC_HICR5_ID3IRQX_SHIFT  20
-#define     LPC_HICR5_ID2IRQX_MASK   GENMASK(19, 16)
-#define     LPC_HICR5_ID2IRQX_SHIFT  16
-#define     LPC_HICR5_SEL3IRQX       BIT(15)
-#define     LPC_HICR5_IRQXE3         BIT(14)
-#define     LPC_HICR5_SEL2IRQX       BIT(13)
-#define     LPC_HICR5_IRQXE2         BIT(12)
 #define LPC_LADR3H           0x014
 #define LPC_LADR3L           0x018
 #define LPC_LADR12H          0x01C
@@ -83,64 +52,21 @@
 #define LPC_STR2             0x040
 #define LPC_STR3             0x044
 #define LPC_HICRB            0x100
-#define     LPC_HICRB_EN16LADR2      BIT(5)
-#define     LPC_HICRB_EN16LADR1      BIT(4)
-#define     LPC_HICRB_IBFIE4         BIT(1)
+#define     LPC_HICRB_IBFIF4         BIT(1)
 #define     LPC_HICRB_LPC4E          BIT(0)
-#define LPC_HICRC            0x104
-#define     LPC_HICRC_ID4IRQX_MASK   GENMASK(7, 4)
-#define     LPC_HICRC_ID4IRQX_SHIFT  4
-#define     LPC_HICRC_TY4IRQX_MASK   GENMASK(3, 2)
-#define     LPC_HICRC_TY4IRQX_SHIFT  2
-#define     LPC_HICRC_OBF4_AUTO_CLR  BIT(1)
-#define     LPC_HICRC_IRQXE4         BIT(0)
 #define LPC_LADR4            0x110
 #define LPC_IDR4             0x114
 #define LPC_ODR4             0x118
 #define LPC_STR4             0x11C
-#define LPC_LSADR12	     0x120
-#define     LPC_LSADR12_LSADR2_MASK  GENMASK(31, 16)
-#define     LPC_LSADR12_LSADR2_SHIFT 16
-#define     LPC_LSADR12_LSADR1_MASK  GENMASK(15, 0)
-#define     LPC_LSADR12_LSADR1_SHIFT 0
-
-#define OBE_POLL_PERIOD	     (HZ / 2)
-
-enum aspeed_kcs_irq_mode {
-	aspeed_kcs_irq_none,
-	aspeed_kcs_irq_serirq,
-};
 
 struct aspeed_kcs_bmc {
-	struct kcs_bmc_device kcs_bmc;
-
 	struct regmap *map;
-
-	struct {
-		enum aspeed_kcs_irq_mode mode;
-		int id;
-	} upstream_irq;
-
-	struct {
-		spinlock_t lock;
-		bool remove;
-		struct timer_list timer;
-	} obe;
 };
 
-struct aspeed_kcs_of_ops {
-	int (*get_channel)(struct platform_device *pdev);
-	int (*get_io_address)(struct platform_device *pdev, u32 addrs[2]);
-};
 
-static inline struct aspeed_kcs_bmc *to_aspeed_kcs_bmc(struct kcs_bmc_device *kcs_bmc)
+static u8 aspeed_kcs_inb(struct kcs_bmc *kcs_bmc, u32 reg)
 {
-	return container_of(kcs_bmc, struct aspeed_kcs_bmc, kcs_bmc);
-}
-
-static u8 aspeed_kcs_inb(struct kcs_bmc_device *kcs_bmc, u32 reg)
-{
-	struct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);
+	struct aspeed_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 	u32 val = 0;
 	int rc;
 
@@ -150,66 +76,15 @@ static u8 aspeed_kcs_inb(struct kcs_bmc_device *kcs_bmc, u32 reg)
 	return rc == 0 ? (u8) val : 0;
 }
 
-static void aspeed_kcs_outb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 data)
+static void aspeed_kcs_outb(struct kcs_bmc *kcs_bmc, u32 reg, u8 data)
 {
-	struct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);
+	struct aspeed_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 	int rc;
 
 	rc = regmap_write(priv->map, reg, data);
 	WARN(rc != 0, "regmap_write() failed: %d\n", rc);
-
-	/* Trigger the upstream IRQ on ODR writes, if enabled */
-
-	switch (reg) {
-	case LPC_ODR1:
-	case LPC_ODR2:
-	case LPC_ODR3:
-	case LPC_ODR4:
-		break;
-	default:
-		return;
-	}
-
-	if (priv->upstream_irq.mode != aspeed_kcs_irq_serirq)
-		return;
-
-	switch (kcs_bmc->channel) {
-	case 1:
-		switch (priv->upstream_irq.id) {
-		case 12:
-			regmap_update_bits(priv->map, LPC_SIRQCR0, LPC_SIRQCR0_IRQ12E1,
-					   LPC_SIRQCR0_IRQ12E1);
-			break;
-		case 1:
-			regmap_update_bits(priv->map, LPC_SIRQCR0, LPC_SIRQCR0_IRQ1E1,
-					   LPC_SIRQCR0_IRQ1E1);
-			break;
-		default:
-			break;
-		}
-		break;
-	case 2:
-		regmap_update_bits(priv->map, LPC_HICR5, LPC_HICR5_IRQXE2, LPC_HICR5_IRQXE2);
-		break;
-	case 3:
-		regmap_update_bits(priv->map, LPC_HICR5, LPC_HICR5_IRQXE3, LPC_HICR5_IRQXE3);
-		break;
-	case 4:
-		regmap_update_bits(priv->map, LPC_HICRC, LPC_HICRC_IRQXE4, LPC_HICRC_IRQXE4);
-		break;
-	default:
-		break;
-	}
 }
 
-static void aspeed_kcs_updateb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 mask, u8 val)
-{
-	struct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);
-	int rc;
-
-	rc = regmap_update_bits(priv->map, reg, mask, val);
-	WARN(rc != 0, "regmap_update_bits() failed: %d\n", rc);
-}
 
 /*
  * AST_usrGuide_KCS.pdf
@@ -224,237 +99,118 @@ static void aspeed_kcs_updateb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 mask,
  *     C. KCS4
  *        D / C : CA4h / CA5h
  */
-static int aspeed_kcs_set_address(struct kcs_bmc_device *kcs_bmc, u32 addrs[2], int nr_addrs)
+static void aspeed_kcs_set_address(struct kcs_bmc *kcs_bmc, u16 addr)
 {
-	struct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);
-
-	if (WARN_ON(nr_addrs < 1 || nr_addrs > 2))
-		return -EINVAL;
+	struct aspeed_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 
-	switch (priv->kcs_bmc.channel) {
+	switch (kcs_bmc->channel) {
 	case 1:
-		regmap_update_bits(priv->map, LPC_HICR4, LPC_HICR4_LADR12AS, 0);
-		regmap_write(priv->map, LPC_LADR12H, addrs[0] >> 8);
-		regmap_write(priv->map, LPC_LADR12L, addrs[0] & 0xFF);
-		if (nr_addrs == 2) {
-			regmap_update_bits(priv->map, LPC_LSADR12, LPC_LSADR12_LSADR1_MASK,
-					   addrs[1] << LPC_LSADR12_LSADR1_SHIFT);
-
-			regmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_EN16LADR1,
-					   LPC_HICRB_EN16LADR1);
-		}
+		regmap_update_bits(priv->map, LPC_HICR4,
+				LPC_HICR4_LADR12AS, 0);
+		regmap_write(priv->map, LPC_LADR12H, addr >> 8);
+		regmap_write(priv->map, LPC_LADR12L, addr & 0xFF);
 		break;
 
 	case 2:
-		regmap_update_bits(priv->map, LPC_HICR4, LPC_HICR4_LADR12AS, LPC_HICR4_LADR12AS);
-		regmap_write(priv->map, LPC_LADR12H, addrs[0] >> 8);
-		regmap_write(priv->map, LPC_LADR12L, addrs[0] & 0xFF);
-		if (nr_addrs == 2) {
-			regmap_update_bits(priv->map, LPC_LSADR12, LPC_LSADR12_LSADR2_MASK,
-					   addrs[1] << LPC_LSADR12_LSADR2_SHIFT);
-
-			regmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_EN16LADR2,
-					   LPC_HICRB_EN16LADR2);
-		}
+		regmap_update_bits(priv->map, LPC_HICR4,
+				LPC_HICR4_LADR12AS, LPC_HICR4_LADR12AS);
+		regmap_write(priv->map, LPC_LADR12H, addr >> 8);
+		regmap_write(priv->map, LPC_LADR12L, addr & 0xFF);
 		break;
 
 	case 3:
-		if (nr_addrs == 2) {
-			dev_err(priv->kcs_bmc.dev,
-				"Channel 3 only supports inferred status IO address\n");
-			return -EINVAL;
-		}
-
-		regmap_write(priv->map, LPC_LADR3H, addrs[0] >> 8);
-		regmap_write(priv->map, LPC_LADR3L, addrs[0] & 0xFF);
+		regmap_write(priv->map, LPC_LADR3H, addr >> 8);
+		regmap_write(priv->map, LPC_LADR3L, addr & 0xFF);
 		break;
 
 	case 4:
-		if (nr_addrs == 1)
-			regmap_write(priv->map, LPC_LADR4, ((addrs[0] + 1) << 16) | addrs[0]);
-		else
-			regmap_write(priv->map, LPC_LADR4, (addrs[1] << 16) | addrs[0]);
-
+		regmap_write(priv->map, LPC_LADR4, ((addr + 1) << 16) |
+			addr);
 		break;
 
 	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static inline int aspeed_kcs_map_serirq_type(u32 dt_type)
-{
-	switch (dt_type) {
-	case IRQ_TYPE_EDGE_RISING:
-		return LPC_TYIRQX_RISING;
-	case IRQ_TYPE_LEVEL_HIGH:
-		return LPC_TYIRQX_HIGH;
-	case IRQ_TYPE_LEVEL_LOW:
-		return LPC_TYIRQX_LOW;
-	default:
-		return -EINVAL;
+		break;
 	}
 }
 
-static int aspeed_kcs_config_upstream_irq(struct aspeed_kcs_bmc *priv, u32 id, u32 dt_type)
+static void aspeed_kcs_enable_channel(struct kcs_bmc *kcs_bmc, bool enable)
 {
-	unsigned int mask, val, hw_type;
-	int ret;
-
-	if (id > 15)
-		return -EINVAL;
-
-	ret = aspeed_kcs_map_serirq_type(dt_type);
-	if (ret < 0)
-		return ret;
-	hw_type = ret;
-
-	priv->upstream_irq.mode = aspeed_kcs_irq_serirq;
-	priv->upstream_irq.id = id;
+	struct aspeed_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 
-	switch (priv->kcs_bmc.channel) {
+	switch (kcs_bmc->channel) {
 	case 1:
-		/* Needs IRQxE1 rather than (ID1IRQX, SEL1IRQX, IRQXE1) before AST2600 A3 */
+		if (enable) {
+			regmap_update_bits(priv->map, LPC_HICR2,
+					LPC_HICR2_IBFIF1, LPC_HICR2_IBFIF1);
+			regmap_update_bits(priv->map, LPC_HICR0,
+					LPC_HICR0_LPC1E, LPC_HICR0_LPC1E);
+		} else {
+			regmap_update_bits(priv->map, LPC_HICR0,
+					LPC_HICR0_LPC1E, 0);
+			regmap_update_bits(priv->map, LPC_HICR2,
+					LPC_HICR2_IBFIF1, 0);
+		}
 		break;
-	case 2:
-		if (!(hw_type == LPC_TYIRQX_LOW || hw_type == LPC_TYIRQX_HIGH))
-			return -EINVAL;
-
-		mask = LPC_HICR5_SEL2IRQX | LPC_HICR5_ID2IRQX_MASK;
-		val = (id << LPC_HICR5_ID2IRQX_SHIFT);
-		val |= (hw_type == LPC_TYIRQX_HIGH) ? LPC_HICR5_SEL2IRQX : 0;
-		regmap_update_bits(priv->map, LPC_HICR5, mask, val);
 
+	case 2:
+		if (enable) {
+			regmap_update_bits(priv->map, LPC_HICR2,
+					LPC_HICR2_IBFIF2, LPC_HICR2_IBFIF2);
+			regmap_update_bits(priv->map, LPC_HICR0,
+					LPC_HICR0_LPC2E, LPC_HICR0_LPC2E);
+		} else {
+			regmap_update_bits(priv->map, LPC_HICR0,
+					LPC_HICR0_LPC2E, 0);
+			regmap_update_bits(priv->map, LPC_HICR2,
+					LPC_HICR2_IBFIF2, 0);
+		}
 		break;
-	case 3:
-		if (!(hw_type == LPC_TYIRQX_LOW || hw_type == LPC_TYIRQX_HIGH))
-			return -EINVAL;
-
-		mask = LPC_HICR5_SEL3IRQX | LPC_HICR5_ID3IRQX_MASK;
-		val = (id << LPC_HICR5_ID3IRQX_SHIFT);
-		val |= (hw_type == LPC_TYIRQX_HIGH) ? LPC_HICR5_SEL3IRQX : 0;
-		regmap_update_bits(priv->map, LPC_HICR5, mask, val);
 
+	case 3:
+		if (enable) {
+			regmap_update_bits(priv->map, LPC_HICR2,
+					LPC_HICR2_IBFIF3, LPC_HICR2_IBFIF3);
+			regmap_update_bits(priv->map, LPC_HICR0,
+					LPC_HICR0_LPC3E, LPC_HICR0_LPC3E);
+			regmap_update_bits(priv->map, LPC_HICR4,
+					LPC_HICR4_KCSENBL, LPC_HICR4_KCSENBL);
+		} else {
+			regmap_update_bits(priv->map, LPC_HICR0,
+					LPC_HICR0_LPC3E, 0);
+			regmap_update_bits(priv->map, LPC_HICR4,
+					LPC_HICR4_KCSENBL, 0);
+			regmap_update_bits(priv->map, LPC_HICR2,
+					LPC_HICR2_IBFIF3, 0);
+		}
 		break;
-	case 4:
-		mask = LPC_HICRC_ID4IRQX_MASK | LPC_HICRC_TY4IRQX_MASK | LPC_HICRC_OBF4_AUTO_CLR;
-		val = (id << LPC_HICRC_ID4IRQX_SHIFT) | (hw_type << LPC_HICRC_TY4IRQX_SHIFT);
-		regmap_update_bits(priv->map, LPC_HICRC, mask, val);
-		break;
-	default:
-		dev_warn(priv->kcs_bmc.dev,
-			 "SerIRQ configuration not supported on KCS channel %d\n",
-			 priv->kcs_bmc.channel);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static void aspeed_kcs_enable_channel(struct kcs_bmc_device *kcs_bmc, bool enable)
-{
-	struct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);
 
-	switch (kcs_bmc->channel) {
-	case 1:
-		regmap_update_bits(priv->map, LPC_HICR0, LPC_HICR0_LPC1E, enable * LPC_HICR0_LPC1E);
-		return;
-	case 2:
-		regmap_update_bits(priv->map, LPC_HICR0, LPC_HICR0_LPC2E, enable * LPC_HICR0_LPC2E);
-		return;
-	case 3:
-		regmap_update_bits(priv->map, LPC_HICR0, LPC_HICR0_LPC3E, enable * LPC_HICR0_LPC3E);
-		regmap_update_bits(priv->map, LPC_HICR4,
-				   LPC_HICR4_KCSENBL, enable * LPC_HICR4_KCSENBL);
-		return;
 	case 4:
-		regmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_LPC4E, enable * LPC_HICRB_LPC4E);
-		return;
-	default:
-		pr_warn("%s: Unsupported channel: %d", __func__, kcs_bmc->channel);
-		return;
-	}
-}
-
-static void aspeed_kcs_check_obe(struct timer_list *timer)
-{
-	struct aspeed_kcs_bmc *priv = container_of(timer, struct aspeed_kcs_bmc, obe.timer);
-	unsigned long flags;
-	u8 str;
-
-	spin_lock_irqsave(&priv->obe.lock, flags);
-	if (priv->obe.remove) {
-		spin_unlock_irqrestore(&priv->obe.lock, flags);
-		return;
-	}
-
-	str = aspeed_kcs_inb(&priv->kcs_bmc, priv->kcs_bmc.ioreg.str);
-	if (str & KCS_BMC_STR_OBF) {
-		mod_timer(timer, jiffies + OBE_POLL_PERIOD);
-		spin_unlock_irqrestore(&priv->obe.lock, flags);
-		return;
-	}
-	spin_unlock_irqrestore(&priv->obe.lock, flags);
-
-	kcs_bmc_handle_event(&priv->kcs_bmc);
-}
-
-static void aspeed_kcs_irq_mask_update(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 state)
-{
-	struct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);
-
-	/* We don't have an OBE IRQ, emulate it */
-	if (mask & KCS_BMC_EVENT_TYPE_OBE) {
-		if (KCS_BMC_EVENT_TYPE_OBE & state)
-			mod_timer(&priv->obe.timer, jiffies + OBE_POLL_PERIOD);
+		if (enable)
+			regmap_update_bits(priv->map, LPC_HICRB,
+					LPC_HICRB_IBFIF4 | LPC_HICRB_LPC4E,
+					LPC_HICRB_IBFIF4 | LPC_HICRB_LPC4E);
 		else
-			del_timer(&priv->obe.timer);
-	}
+			regmap_update_bits(priv->map, LPC_HICRB,
+					LPC_HICRB_IBFIF4 | LPC_HICRB_LPC4E,
+					0);
+		break;
 
-	if (mask & KCS_BMC_EVENT_TYPE_IBF) {
-		const bool enable = !!(state & KCS_BMC_EVENT_TYPE_IBF);
-
-		switch (kcs_bmc->channel) {
-		case 1:
-			regmap_update_bits(priv->map, LPC_HICR2, LPC_HICR2_IBFIE1,
-					   enable * LPC_HICR2_IBFIE1);
-			return;
-		case 2:
-			regmap_update_bits(priv->map, LPC_HICR2, LPC_HICR2_IBFIE2,
-					   enable * LPC_HICR2_IBFIE2);
-			return;
-		case 3:
-			regmap_update_bits(priv->map, LPC_HICR2, LPC_HICR2_IBFIE3,
-					   enable * LPC_HICR2_IBFIE3);
-			return;
-		case 4:
-			regmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_IBFIE4,
-					   enable * LPC_HICRB_IBFIE4);
-			return;
-		default:
-			pr_warn("%s: Unsupported channel: %d", __func__, kcs_bmc->channel);
-			return;
-		}
+	default:
+		break;
 	}
 }
 
-static const struct kcs_bmc_device_ops aspeed_kcs_ops = {
-	.irq_mask_update = aspeed_kcs_irq_mask_update,
-	.io_inputb = aspeed_kcs_inb,
-	.io_outputb = aspeed_kcs_outb,
-	.io_updateb = aspeed_kcs_updateb,
-};
-
 static irqreturn_t aspeed_kcs_irq(int irq, void *arg)
 {
-	struct kcs_bmc_device *kcs_bmc = arg;
+	struct kcs_bmc *kcs_bmc = arg;
 
-	return kcs_bmc_handle_event(kcs_bmc);
+	if (!kcs_bmc_handle_event(kcs_bmc))
+		return IRQ_HANDLED;
+
+	return IRQ_NONE;
 }
 
-static int aspeed_kcs_config_downstream_irq(struct kcs_bmc_device *kcs_bmc,
+static int aspeed_kcs_config_irq(struct kcs_bmc *kcs_bmc,
 			struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -475,10 +231,13 @@ static const struct kcs_ioreg ast_kcs_bmc_ioregs[KCS_CHANNEL_MAX] = {
 	{ .idr = LPC_IDR4, .odr = LPC_ODR4, .str = LPC_STR4 },
 };
 
-static int aspeed_kcs_of_v1_get_channel(struct platform_device *pdev)
+static struct kcs_bmc *aspeed_kcs_probe_of_v1(struct platform_device *pdev)
 {
+	struct aspeed_kcs_bmc *priv;
 	struct device_node *np;
+	struct kcs_bmc *kcs;
 	u32 channel;
+	u32 slave;
 	int rc;
 
 	np = pdev->dev.of_node;
@@ -486,214 +245,167 @@ static int aspeed_kcs_of_v1_get_channel(struct platform_device *pdev)
 	rc = of_property_read_u32(np, "kcs_chan", &channel);
 	if ((rc != 0) || (channel == 0 || channel > KCS_CHANNEL_MAX)) {
 		dev_err(&pdev->dev, "no valid 'kcs_chan' configured\n");
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	}
 
-	return channel;
+	kcs = kcs_bmc_alloc(&pdev->dev, sizeof(struct aspeed_kcs_bmc), channel);
+	if (!kcs)
+		return ERR_PTR(-ENOMEM);
+
+	priv = kcs_bmc_priv(kcs);
+	priv->map = syscon_node_to_regmap(pdev->dev.parent->of_node);
+	if (IS_ERR(priv->map)) {
+		dev_err(&pdev->dev, "Couldn't get regmap\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	rc = of_property_read_u32(np, "kcs_addr", &slave);
+	if (rc) {
+		dev_err(&pdev->dev, "no valid 'kcs_addr' configured\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	kcs->ioreg = ast_kcs_bmc_ioregs[channel - 1];
+	aspeed_kcs_set_address(kcs, slave);
+
+	return kcs;
 }
 
-static int
-aspeed_kcs_of_v1_get_io_address(struct platform_device *pdev, u32 addrs[2])
+static int aspeed_kcs_calculate_channel(const struct kcs_ioreg *regs)
 {
-	int rc;
+	int i;
 
-	rc = of_property_read_u32(pdev->dev.of_node, "kcs_addr", addrs);
-	if (rc || addrs[0] > 0xffff) {
-		dev_err(&pdev->dev, "no valid 'kcs_addr' configured\n");
-		return -EINVAL;
+	for (i = 0; i < ARRAY_SIZE(ast_kcs_bmc_ioregs); i++) {
+		if (!memcmp(&ast_kcs_bmc_ioregs[i], regs, sizeof(*regs)))
+			return i + 1;
 	}
 
-	return 1;
+	return -EINVAL;
 }
 
-static int aspeed_kcs_of_v2_get_channel(struct platform_device *pdev)
+static struct kcs_bmc *aspeed_kcs_probe_of_v2(struct platform_device *pdev)
 {
+	struct aspeed_kcs_bmc *priv;
 	struct device_node *np;
 	struct kcs_ioreg ioreg;
+	struct kcs_bmc *kcs;
 	const __be32 *reg;
-	int i;
+	int channel;
+	u32 slave;
+	int rc;
 
 	np = pdev->dev.of_node;
 
 	/* Don't translate addresses, we want offsets for the regmaps */
 	reg = of_get_address(np, 0, NULL, NULL);
 	if (!reg)
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	ioreg.idr = be32_to_cpup(reg);
 
 	reg = of_get_address(np, 1, NULL, NULL);
 	if (!reg)
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	ioreg.odr = be32_to_cpup(reg);
 
 	reg = of_get_address(np, 2, NULL, NULL);
 	if (!reg)
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	ioreg.str = be32_to_cpup(reg);
 
-	for (i = 0; i < ARRAY_SIZE(ast_kcs_bmc_ioregs); i++) {
-		if (!memcmp(&ast_kcs_bmc_ioregs[i], &ioreg, sizeof(ioreg)))
-			return i + 1;
-	}
+	channel = aspeed_kcs_calculate_channel(&ioreg);
+	if (channel < 0)
+		return ERR_PTR(channel);
 
-	return -EINVAL;
-}
+	kcs = kcs_bmc_alloc(&pdev->dev, sizeof(struct aspeed_kcs_bmc), channel);
+	if (!kcs)
+		return ERR_PTR(-ENOMEM);
 
-static int
-aspeed_kcs_of_v2_get_io_address(struct platform_device *pdev, u32 addrs[2])
-{
-	int rc;
+	kcs->ioreg = ioreg;
 
-	rc = of_property_read_variable_u32_array(pdev->dev.of_node,
-						 "aspeed,lpc-io-reg",
-						 addrs, 1, 2);
-	if (rc < 0) {
-		dev_err(&pdev->dev, "No valid 'aspeed,lpc-io-reg' configured\n");
-		return rc;
+	priv = kcs_bmc_priv(kcs);
+	priv->map = syscon_node_to_regmap(pdev->dev.parent->of_node);
+	if (IS_ERR(priv->map)) {
+		dev_err(&pdev->dev, "Couldn't get regmap\n");
+		return ERR_PTR(-ENODEV);
 	}
 
-	if (addrs[0] > 0xffff) {
-		dev_err(&pdev->dev, "Invalid data address in 'aspeed,lpc-io-reg'\n");
-		return -EINVAL;
-	}
+	rc = of_property_read_u32(np, "aspeed,lpc-io-reg", &slave);
+	if (rc)
+		return ERR_PTR(rc);
 
-	if (rc == 2 && addrs[1] > 0xffff) {
-		dev_err(&pdev->dev, "Invalid status address in 'aspeed,lpc-io-reg'\n");
-		return -EINVAL;
-	}
+	aspeed_kcs_set_address(kcs, slave);
 
-	return rc;
+	return kcs;
 }
 
 static int aspeed_kcs_probe(struct platform_device *pdev)
 {
-	const struct aspeed_kcs_of_ops *ops;
-	struct kcs_bmc_device *kcs_bmc;
-	struct aspeed_kcs_bmc *priv;
+	struct device *dev = &pdev->dev;
+	struct kcs_bmc *kcs_bmc;
 	struct device_node *np;
-	bool have_upstream_irq;
-	u32 upstream_irq[2];
-	int rc, channel;
-	int nr_addrs;
-	u32 addrs[2];
+	int rc;
 
-	np = pdev->dev.of_node->parent;
+	np = dev->of_node->parent;
 	if (!of_device_is_compatible(np, "aspeed,ast2400-lpc-v2") &&
 	    !of_device_is_compatible(np, "aspeed,ast2500-lpc-v2") &&
 	    !of_device_is_compatible(np, "aspeed,ast2600-lpc-v2")) {
-		dev_err(&pdev->dev, "unsupported LPC device binding\n");
+		dev_err(dev, "unsupported LPC device binding\n");
 		return -ENODEV;
 	}
 
-	ops = of_device_get_match_data(&pdev->dev);
-	if (!ops)
+	np = dev->of_node;
+	if (of_device_is_compatible(np, "aspeed,ast2400-kcs-bmc") ||
+	    of_device_is_compatible(np, "aspeed,ast2500-kcs-bmc"))
+		kcs_bmc = aspeed_kcs_probe_of_v1(pdev);
+	else if (of_device_is_compatible(np, "aspeed,ast2400-kcs-bmc-v2") ||
+		 of_device_is_compatible(np, "aspeed,ast2500-kcs-bmc-v2"))
+		kcs_bmc = aspeed_kcs_probe_of_v2(pdev);
+	else
 		return -EINVAL;
 
-	channel = ops->get_channel(pdev);
-	if (channel < 0)
-		return channel;
+	if (IS_ERR(kcs_bmc))
+		return PTR_ERR(kcs_bmc);
 
-	nr_addrs = ops->get_io_address(pdev, addrs);
-	if (nr_addrs < 0)
-		return nr_addrs;
+	kcs_bmc->io_inputb = aspeed_kcs_inb;
+	kcs_bmc->io_outputb = aspeed_kcs_outb;
 
-	np = pdev->dev.of_node;
-	rc = of_property_read_u32_array(np, "aspeed,lpc-interrupts", upstream_irq, 2);
-	if (rc && rc != -EINVAL)
-		return -EINVAL;
-
-	have_upstream_irq = !rc;
-
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	kcs_bmc = &priv->kcs_bmc;
-	kcs_bmc->dev = &pdev->dev;
-	kcs_bmc->channel = channel;
-	kcs_bmc->ioreg = ast_kcs_bmc_ioregs[channel - 1];
-	kcs_bmc->ops = &aspeed_kcs_ops;
-
-	priv->map = syscon_node_to_regmap(pdev->dev.parent->of_node);
-	if (IS_ERR(priv->map)) {
-		dev_err(&pdev->dev, "Couldn't get regmap\n");
-		return -ENODEV;
-	}
-
-	spin_lock_init(&priv->obe.lock);
-	priv->obe.remove = false;
-	timer_setup(&priv->obe.timer, aspeed_kcs_check_obe, 0);
-
-	rc = aspeed_kcs_set_address(kcs_bmc, addrs, nr_addrs);
+	rc = aspeed_kcs_config_irq(kcs_bmc, pdev);
 	if (rc)
 		return rc;
 
-	/* Host to BMC IRQ */
-	rc = aspeed_kcs_config_downstream_irq(kcs_bmc, pdev);
-	if (rc)
-		return rc;
-
-	/* BMC to Host IRQ */
-	if (have_upstream_irq) {
-		rc = aspeed_kcs_config_upstream_irq(priv, upstream_irq[0], upstream_irq[1]);
-		if (rc < 0)
-			return rc;
-	} else {
-		priv->upstream_irq.mode = aspeed_kcs_irq_none;
-	}
-
-	platform_set_drvdata(pdev, priv);
+	dev_set_drvdata(dev, kcs_bmc);
 
-	aspeed_kcs_irq_mask_update(kcs_bmc, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);
 	aspeed_kcs_enable_channel(kcs_bmc, true);
 
-	rc = kcs_bmc_add_device(&priv->kcs_bmc);
+	rc = misc_register(&kcs_bmc->miscdev);
 	if (rc) {
-		dev_warn(&pdev->dev, "Failed to register channel %d: %d\n", kcs_bmc->channel, rc);
+		dev_err(dev, "Unable to register device\n");
 		return rc;
 	}
 
-	dev_info(&pdev->dev, "Initialised channel %d at 0x%x\n",
-			kcs_bmc->channel, addrs[0]);
+	dev_dbg(&pdev->dev,
+		"Probed KCS device %d (IDR=0x%x, ODR=0x%x, STR=0x%x)\n",
+		kcs_bmc->channel, kcs_bmc->ioreg.idr, kcs_bmc->ioreg.odr,
+		kcs_bmc->ioreg.str);
 
 	return 0;
 }
 
 static int aspeed_kcs_remove(struct platform_device *pdev)
 {
-	struct aspeed_kcs_bmc *priv = platform_get_drvdata(pdev);
-	struct kcs_bmc_device *kcs_bmc = &priv->kcs_bmc;
-
-	kcs_bmc_remove_device(kcs_bmc);
+	struct kcs_bmc *kcs_bmc = dev_get_drvdata(&pdev->dev);
 
-	aspeed_kcs_enable_channel(kcs_bmc, false);
-	aspeed_kcs_irq_mask_update(kcs_bmc, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);
-
-	/* Make sure it's proper dead */
-	spin_lock_irq(&priv->obe.lock);
-	priv->obe.remove = true;
-	spin_unlock_irq(&priv->obe.lock);
-	del_timer_sync(&priv->obe.timer);
+	misc_deregister(&kcs_bmc->miscdev);
 
 	return 0;
 }
 
-static const struct aspeed_kcs_of_ops of_v1_ops = {
-	.get_channel = aspeed_kcs_of_v1_get_channel,
-	.get_io_address = aspeed_kcs_of_v1_get_io_address,
-};
-
-static const struct aspeed_kcs_of_ops of_v2_ops = {
-	.get_channel = aspeed_kcs_of_v2_get_channel,
-	.get_io_address = aspeed_kcs_of_v2_get_io_address,
-};
-
 static const struct of_device_id ast_kcs_bmc_match[] = {
-	{ .compatible = "aspeed,ast2400-kcs-bmc", .data = &of_v1_ops },
-	{ .compatible = "aspeed,ast2500-kcs-bmc", .data = &of_v1_ops },
-	{ .compatible = "aspeed,ast2400-kcs-bmc-v2", .data = &of_v2_ops },
-	{ .compatible = "aspeed,ast2500-kcs-bmc-v2", .data = &of_v2_ops },
-	{ .compatible = "aspeed,ast2600-kcs-bmc", .data = &of_v2_ops },
+	{ .compatible = "aspeed,ast2400-kcs-bmc" },
+	{ .compatible = "aspeed,ast2500-kcs-bmc" },
+	{ .compatible = "aspeed,ast2400-kcs-bmc-v2" },
+	{ .compatible = "aspeed,ast2500-kcs-bmc-v2" },
+	{ .compatible = "aspeed,ast2600-kcs-bmc" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, ast_kcs_bmc_match);
@@ -710,5 +422,4 @@ module_platform_driver(ast_kcs_bmc_driver);
 
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Haiyue Wang <haiyue.wang@linux.intel.com>");
-MODULE_AUTHOR("Andrew Jeffery <andrew@aj.id.au>");
 MODULE_DESCRIPTION("Aspeed device interface to the KCS BMC device");
diff --git a/drivers/char/ipmi/kcs_bmc_cdev_ipmi.c b/drivers/char/ipmi/kcs_bmc_cdev_ipmi.c
deleted file mode 100644
index 486834a962c3..000000000000
--- a/drivers/char/ipmi/kcs_bmc_cdev_ipmi.c
+++ /dev/null
@@ -1,568 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2015-2018, Intel Corporation.
- */
-
-#define pr_fmt(fmt) "kcs-bmc: " fmt
-
-#include <linux/errno.h>
-#include <linux/io.h>
-#include <linux/ipmi_bmc.h>
-#include <linux/list.h>
-#include <linux/miscdevice.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/poll.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-
-#include "kcs_bmc_client.h"
-
-/* Different phases of the KCS BMC module.
- *  KCS_PHASE_IDLE:
- *            BMC should not be expecting nor sending any data.
- *  KCS_PHASE_WRITE_START:
- *            BMC is receiving a WRITE_START command from system software.
- *  KCS_PHASE_WRITE_DATA:
- *            BMC is receiving a data byte from system software.
- *  KCS_PHASE_WRITE_END_CMD:
- *            BMC is waiting a last data byte from system software.
- *  KCS_PHASE_WRITE_DONE:
- *            BMC has received the whole request from system software.
- *  KCS_PHASE_WAIT_READ:
- *            BMC is waiting the response from the upper IPMI service.
- *  KCS_PHASE_READ:
- *            BMC is transferring the response to system software.
- *  KCS_PHASE_ABORT_ERROR1:
- *            BMC is waiting error status request from system software.
- *  KCS_PHASE_ABORT_ERROR2:
- *            BMC is waiting for idle status afer error from system software.
- *  KCS_PHASE_ERROR:
- *            BMC has detected a protocol violation at the interface level.
- */
-enum kcs_ipmi_phases {
-	KCS_PHASE_IDLE,
-
-	KCS_PHASE_WRITE_START,
-	KCS_PHASE_WRITE_DATA,
-	KCS_PHASE_WRITE_END_CMD,
-	KCS_PHASE_WRITE_DONE,
-
-	KCS_PHASE_WAIT_READ,
-	KCS_PHASE_READ,
-
-	KCS_PHASE_ABORT_ERROR1,
-	KCS_PHASE_ABORT_ERROR2,
-	KCS_PHASE_ERROR
-};
-
-/* IPMI 2.0 - Table 9-4, KCS Interface Status Codes */
-enum kcs_ipmi_errors {
-	KCS_NO_ERROR                = 0x00,
-	KCS_ABORTED_BY_COMMAND      = 0x01,
-	KCS_ILLEGAL_CONTROL_CODE    = 0x02,
-	KCS_LENGTH_ERROR            = 0x06,
-	KCS_UNSPECIFIED_ERROR       = 0xFF
-};
-
-struct kcs_bmc_ipmi {
-	struct list_head entry;
-
-	struct kcs_bmc_client client;
-
-	spinlock_t lock;
-
-	enum kcs_ipmi_phases phase;
-	enum kcs_ipmi_errors error;
-
-	wait_queue_head_t queue;
-	bool data_in_avail;
-	int  data_in_idx;
-	u8  *data_in;
-
-	int  data_out_idx;
-	int  data_out_len;
-	u8  *data_out;
-
-	struct mutex mutex;
-	u8 *kbuffer;
-
-	struct miscdevice miscdev;
-};
-
-#define DEVICE_NAME "ipmi-kcs"
-
-#define KCS_MSG_BUFSIZ    1000
-
-#define KCS_ZERO_DATA     0
-
-/* IPMI 2.0 - Table 9-1, KCS Interface Status Register Bits */
-#define KCS_STATUS_STATE(state) (state << 6)
-#define KCS_STATUS_STATE_MASK   GENMASK(7, 6)
-#define KCS_STATUS_CMD_DAT      BIT(3)
-#define KCS_STATUS_SMS_ATN      BIT(2)
-#define KCS_STATUS_IBF          BIT(1)
-#define KCS_STATUS_OBF          BIT(0)
-
-/* IPMI 2.0 - Table 9-2, KCS Interface State Bits */
-enum kcs_states {
-	IDLE_STATE  = 0,
-	READ_STATE  = 1,
-	WRITE_STATE = 2,
-	ERROR_STATE = 3,
-};
-
-/* IPMI 2.0 - Table 9-3, KCS Interface Control Codes */
-#define KCS_CMD_GET_STATUS_ABORT  0x60
-#define KCS_CMD_WRITE_START       0x61
-#define KCS_CMD_WRITE_END         0x62
-#define KCS_CMD_READ_BYTE         0x68
-
-static inline void set_state(struct kcs_bmc_ipmi *priv, u8 state)
-{
-	kcs_bmc_update_status(priv->client.dev, KCS_STATUS_STATE_MASK, KCS_STATUS_STATE(state));
-}
-
-static void kcs_bmc_ipmi_force_abort(struct kcs_bmc_ipmi *priv)
-{
-	set_state(priv, ERROR_STATE);
-	kcs_bmc_read_data(priv->client.dev);
-	kcs_bmc_write_data(priv->client.dev, KCS_ZERO_DATA);
-
-	priv->phase = KCS_PHASE_ERROR;
-	priv->data_in_avail = false;
-	priv->data_in_idx = 0;
-}
-
-static void kcs_bmc_ipmi_handle_data(struct kcs_bmc_ipmi *priv)
-{
-	struct kcs_bmc_device *dev;
-	u8 data;
-
-	dev = priv->client.dev;
-
-	switch (priv->phase) {
-	case KCS_PHASE_WRITE_START:
-		priv->phase = KCS_PHASE_WRITE_DATA;
-		fallthrough;
-
-	case KCS_PHASE_WRITE_DATA:
-		if (priv->data_in_idx < KCS_MSG_BUFSIZ) {
-			set_state(priv, WRITE_STATE);
-			kcs_bmc_write_data(dev, KCS_ZERO_DATA);
-			priv->data_in[priv->data_in_idx++] = kcs_bmc_read_data(dev);
-		} else {
-			kcs_bmc_ipmi_force_abort(priv);
-			priv->error = KCS_LENGTH_ERROR;
-		}
-		break;
-
-	case KCS_PHASE_WRITE_END_CMD:
-		if (priv->data_in_idx < KCS_MSG_BUFSIZ) {
-			set_state(priv, READ_STATE);
-			priv->data_in[priv->data_in_idx++] = kcs_bmc_read_data(dev);
-			priv->phase = KCS_PHASE_WRITE_DONE;
-			priv->data_in_avail = true;
-			wake_up_interruptible(&priv->queue);
-		} else {
-			kcs_bmc_ipmi_force_abort(priv);
-			priv->error = KCS_LENGTH_ERROR;
-		}
-		break;
-
-	case KCS_PHASE_READ:
-		if (priv->data_out_idx == priv->data_out_len)
-			set_state(priv, IDLE_STATE);
-
-		data = kcs_bmc_read_data(dev);
-		if (data != KCS_CMD_READ_BYTE) {
-			set_state(priv, ERROR_STATE);
-			kcs_bmc_write_data(dev, KCS_ZERO_DATA);
-			break;
-		}
-
-		if (priv->data_out_idx == priv->data_out_len) {
-			kcs_bmc_write_data(dev, KCS_ZERO_DATA);
-			priv->phase = KCS_PHASE_IDLE;
-			break;
-		}
-
-		kcs_bmc_write_data(dev, priv->data_out[priv->data_out_idx++]);
-		break;
-
-	case KCS_PHASE_ABORT_ERROR1:
-		set_state(priv, READ_STATE);
-		kcs_bmc_read_data(dev);
-		kcs_bmc_write_data(dev, priv->error);
-		priv->phase = KCS_PHASE_ABORT_ERROR2;
-		break;
-
-	case KCS_PHASE_ABORT_ERROR2:
-		set_state(priv, IDLE_STATE);
-		kcs_bmc_read_data(dev);
-		kcs_bmc_write_data(dev, KCS_ZERO_DATA);
-		priv->phase = KCS_PHASE_IDLE;
-		break;
-
-	default:
-		kcs_bmc_ipmi_force_abort(priv);
-		break;
-	}
-}
-
-static void kcs_bmc_ipmi_handle_cmd(struct kcs_bmc_ipmi *priv)
-{
-	u8 cmd;
-
-	set_state(priv, WRITE_STATE);
-	kcs_bmc_write_data(priv->client.dev, KCS_ZERO_DATA);
-
-	cmd = kcs_bmc_read_data(priv->client.dev);
-	switch (cmd) {
-	case KCS_CMD_WRITE_START:
-		priv->phase = KCS_PHASE_WRITE_START;
-		priv->error = KCS_NO_ERROR;
-		priv->data_in_avail = false;
-		priv->data_in_idx = 0;
-		break;
-
-	case KCS_CMD_WRITE_END:
-		if (priv->phase != KCS_PHASE_WRITE_DATA) {
-			kcs_bmc_ipmi_force_abort(priv);
-			break;
-		}
-
-		priv->phase = KCS_PHASE_WRITE_END_CMD;
-		break;
-
-	case KCS_CMD_GET_STATUS_ABORT:
-		if (priv->error == KCS_NO_ERROR)
-			priv->error = KCS_ABORTED_BY_COMMAND;
-
-		priv->phase = KCS_PHASE_ABORT_ERROR1;
-		priv->data_in_avail = false;
-		priv->data_in_idx = 0;
-		break;
-
-	default:
-		kcs_bmc_ipmi_force_abort(priv);
-		priv->error = KCS_ILLEGAL_CONTROL_CODE;
-		break;
-	}
-}
-
-static inline struct kcs_bmc_ipmi *client_to_kcs_bmc_ipmi(struct kcs_bmc_client *client)
-{
-	return container_of(client, struct kcs_bmc_ipmi, client);
-}
-
-static irqreturn_t kcs_bmc_ipmi_event(struct kcs_bmc_client *client)
-{
-	struct kcs_bmc_ipmi *priv;
-	u8 status;
-	int ret;
-
-	priv = client_to_kcs_bmc_ipmi(client);
-	if (!priv)
-		return IRQ_NONE;
-
-	spin_lock(&priv->lock);
-
-	status = kcs_bmc_read_status(client->dev);
-	if (status & KCS_STATUS_IBF) {
-		if (status & KCS_STATUS_CMD_DAT)
-			kcs_bmc_ipmi_handle_cmd(priv);
-		else
-			kcs_bmc_ipmi_handle_data(priv);
-
-		ret = IRQ_HANDLED;
-	} else {
-		ret = IRQ_NONE;
-	}
-
-	spin_unlock(&priv->lock);
-
-	return ret;
-}
-
-static const struct kcs_bmc_client_ops kcs_bmc_ipmi_client_ops = {
-	.event = kcs_bmc_ipmi_event,
-};
-
-static inline struct kcs_bmc_ipmi *to_kcs_bmc(struct file *filp)
-{
-	return container_of(filp->private_data, struct kcs_bmc_ipmi, miscdev);
-}
-
-static int kcs_bmc_ipmi_open(struct inode *inode, struct file *filp)
-{
-	struct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);
-
-	return kcs_bmc_enable_device(priv->client.dev, &priv->client);
-}
-
-static __poll_t kcs_bmc_ipmi_poll(struct file *filp, poll_table *wait)
-{
-	struct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);
-	__poll_t mask = 0;
-
-	poll_wait(filp, &priv->queue, wait);
-
-	spin_lock_irq(&priv->lock);
-	if (priv->data_in_avail)
-		mask |= EPOLLIN;
-	spin_unlock_irq(&priv->lock);
-
-	return mask;
-}
-
-static ssize_t kcs_bmc_ipmi_read(struct file *filp, char __user *buf,
-			    size_t count, loff_t *ppos)
-{
-	struct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);
-	bool data_avail;
-	size_t data_len;
-	ssize_t ret;
-
-	if (!(filp->f_flags & O_NONBLOCK))
-		wait_event_interruptible(priv->queue,
-					 priv->data_in_avail);
-
-	mutex_lock(&priv->mutex);
-
-	spin_lock_irq(&priv->lock);
-	data_avail = priv->data_in_avail;
-	if (data_avail) {
-		data_len = priv->data_in_idx;
-		memcpy(priv->kbuffer, priv->data_in, data_len);
-	}
-	spin_unlock_irq(&priv->lock);
-
-	if (!data_avail) {
-		ret = -EAGAIN;
-		goto out_unlock;
-	}
-
-	if (count < data_len) {
-		pr_err("channel=%u with too large data : %zu\n",
-			priv->client.dev->channel, data_len);
-
-		spin_lock_irq(&priv->lock);
-		kcs_bmc_ipmi_force_abort(priv);
-		spin_unlock_irq(&priv->lock);
-
-		ret = -EOVERFLOW;
-		goto out_unlock;
-	}
-
-	if (copy_to_user(buf, priv->kbuffer, data_len)) {
-		ret = -EFAULT;
-		goto out_unlock;
-	}
-
-	ret = data_len;
-
-	spin_lock_irq(&priv->lock);
-	if (priv->phase == KCS_PHASE_WRITE_DONE) {
-		priv->phase = KCS_PHASE_WAIT_READ;
-		priv->data_in_avail = false;
-		priv->data_in_idx = 0;
-	} else {
-		ret = -EAGAIN;
-	}
-	spin_unlock_irq(&priv->lock);
-
-out_unlock:
-	mutex_unlock(&priv->mutex);
-
-	return ret;
-}
-
-static ssize_t kcs_bmc_ipmi_write(struct file *filp, const char __user *buf,
-			     size_t count, loff_t *ppos)
-{
-	struct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);
-	ssize_t ret;
-
-	/* a minimum response size '3' : netfn + cmd + ccode */
-	if (count < 3 || count > KCS_MSG_BUFSIZ)
-		return -EINVAL;
-
-	mutex_lock(&priv->mutex);
-
-	if (copy_from_user(priv->kbuffer, buf, count)) {
-		ret = -EFAULT;
-		goto out_unlock;
-	}
-
-	spin_lock_irq(&priv->lock);
-	if (priv->phase == KCS_PHASE_WAIT_READ) {
-		priv->phase = KCS_PHASE_READ;
-		priv->data_out_idx = 1;
-		priv->data_out_len = count;
-		memcpy(priv->data_out, priv->kbuffer, count);
-		kcs_bmc_write_data(priv->client.dev, priv->data_out[0]);
-		ret = count;
-	} else {
-		ret = -EINVAL;
-	}
-	spin_unlock_irq(&priv->lock);
-
-out_unlock:
-	mutex_unlock(&priv->mutex);
-
-	return ret;
-}
-
-static long kcs_bmc_ipmi_ioctl(struct file *filp, unsigned int cmd,
-			  unsigned long arg)
-{
-	struct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);
-	long ret = 0;
-
-	spin_lock_irq(&priv->lock);
-
-	switch (cmd) {
-	case IPMI_BMC_IOCTL_SET_SMS_ATN:
-		kcs_bmc_update_status(priv->client.dev, KCS_STATUS_SMS_ATN, KCS_STATUS_SMS_ATN);
-		break;
-
-	case IPMI_BMC_IOCTL_CLEAR_SMS_ATN:
-		kcs_bmc_update_status(priv->client.dev, KCS_STATUS_SMS_ATN, 0);
-		break;
-
-	case IPMI_BMC_IOCTL_FORCE_ABORT:
-		kcs_bmc_ipmi_force_abort(priv);
-		break;
-
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	spin_unlock_irq(&priv->lock);
-
-	return ret;
-}
-
-static int kcs_bmc_ipmi_release(struct inode *inode, struct file *filp)
-{
-	struct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);
-
-	kcs_bmc_ipmi_force_abort(priv);
-	kcs_bmc_disable_device(priv->client.dev, &priv->client);
-
-	return 0;
-}
-
-static const struct file_operations kcs_bmc_ipmi_fops = {
-	.owner          = THIS_MODULE,
-	.open           = kcs_bmc_ipmi_open,
-	.read           = kcs_bmc_ipmi_read,
-	.write          = kcs_bmc_ipmi_write,
-	.release        = kcs_bmc_ipmi_release,
-	.poll           = kcs_bmc_ipmi_poll,
-	.unlocked_ioctl = kcs_bmc_ipmi_ioctl,
-};
-
-static DEFINE_SPINLOCK(kcs_bmc_ipmi_instances_lock);
-static LIST_HEAD(kcs_bmc_ipmi_instances);
-
-static int kcs_bmc_ipmi_add_device(struct kcs_bmc_device *kcs_bmc)
-{
-	struct kcs_bmc_ipmi *priv;
-	int rc;
-
-	priv = devm_kzalloc(kcs_bmc->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	spin_lock_init(&priv->lock);
-	mutex_init(&priv->mutex);
-
-	init_waitqueue_head(&priv->queue);
-
-	priv->client.dev = kcs_bmc;
-	priv->client.ops = &kcs_bmc_ipmi_client_ops;
-	priv->data_in = devm_kmalloc(kcs_bmc->dev, KCS_MSG_BUFSIZ, GFP_KERNEL);
-	priv->data_out = devm_kmalloc(kcs_bmc->dev, KCS_MSG_BUFSIZ, GFP_KERNEL);
-	priv->kbuffer = devm_kmalloc(kcs_bmc->dev, KCS_MSG_BUFSIZ, GFP_KERNEL);
-
-	priv->miscdev.minor = MISC_DYNAMIC_MINOR;
-	priv->miscdev.name = devm_kasprintf(kcs_bmc->dev, GFP_KERNEL, "%s%u", DEVICE_NAME,
-					   kcs_bmc->channel);
-	if (!priv->data_in || !priv->data_out || !priv->kbuffer || !priv->miscdev.name)
-		return -EINVAL;
-
-	priv->miscdev.fops = &kcs_bmc_ipmi_fops;
-
-	rc = misc_register(&priv->miscdev);
-	if (rc) {
-		dev_err(kcs_bmc->dev, "Unable to register device: %d\n", rc);
-		return rc;
-	}
-
-	spin_lock_irq(&kcs_bmc_ipmi_instances_lock);
-	list_add(&priv->entry, &kcs_bmc_ipmi_instances);
-	spin_unlock_irq(&kcs_bmc_ipmi_instances_lock);
-
-	dev_info(kcs_bmc->dev, "Initialised IPMI client for channel %d", kcs_bmc->channel);
-
-	return 0;
-}
-
-static int kcs_bmc_ipmi_remove_device(struct kcs_bmc_device *kcs_bmc)
-{
-	struct kcs_bmc_ipmi *priv = NULL, *pos;
-
-	spin_lock_irq(&kcs_bmc_ipmi_instances_lock);
-	list_for_each_entry(pos, &kcs_bmc_ipmi_instances, entry) {
-		if (pos->client.dev == kcs_bmc) {
-			priv = pos;
-			list_del(&pos->entry);
-			break;
-		}
-	}
-	spin_unlock_irq(&kcs_bmc_ipmi_instances_lock);
-
-	if (!priv)
-		return -ENODEV;
-
-	misc_deregister(&priv->miscdev);
-	kcs_bmc_disable_device(priv->client.dev, &priv->client);
-	devm_kfree(kcs_bmc->dev, priv->kbuffer);
-	devm_kfree(kcs_bmc->dev, priv->data_out);
-	devm_kfree(kcs_bmc->dev, priv->data_in);
-	devm_kfree(kcs_bmc->dev, priv);
-
-	return 0;
-}
-
-static const struct kcs_bmc_driver_ops kcs_bmc_ipmi_driver_ops = {
-	.add_device = kcs_bmc_ipmi_add_device,
-	.remove_device = kcs_bmc_ipmi_remove_device,
-};
-
-static struct kcs_bmc_driver kcs_bmc_ipmi_driver = {
-	.ops = &kcs_bmc_ipmi_driver_ops,
-};
-
-static int kcs_bmc_ipmi_init(void)
-{
-	kcs_bmc_register_driver(&kcs_bmc_ipmi_driver);
-
-	return 0;
-}
-module_init(kcs_bmc_ipmi_init);
-
-static void kcs_bmc_ipmi_exit(void)
-{
-	kcs_bmc_unregister_driver(&kcs_bmc_ipmi_driver);
-}
-module_exit(kcs_bmc_ipmi_exit);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Haiyue Wang <haiyue.wang@linux.intel.com>");
-MODULE_AUTHOR("Andrew Jeffery <andrew@aj.id.au>");
-MODULE_DESCRIPTION("KCS BMC to handle the IPMI request from system software");
diff --git a/drivers/char/ipmi/kcs_bmc_cdev_raw.c b/drivers/char/ipmi/kcs_bmc_cdev_raw.c
deleted file mode 100644
index 6865628476e1..000000000000
--- a/drivers/char/ipmi/kcs_bmc_cdev_raw.c
+++ /dev/null
@@ -1,447 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/* Copyright (c) 2021 IBM Corp. */
-
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/errno.h>
-#include <linux/fs.h>
-#include <linux/list.h>
-#include <linux/miscdevice.h>
-#include <linux/module.h>
-#include <linux/poll.h>
-
-#include "kcs_bmc_client.h"
-
-#define DEVICE_NAME "raw-kcs"
-
-struct kcs_bmc_raw {
-	struct list_head entry;
-
-	struct kcs_bmc_client client;
-
-	wait_queue_head_t queue;
-	u8 events;
-	bool writable;
-	bool readable;
-	u8 idr;
-
-	struct miscdevice miscdev;
-};
-
-static inline struct kcs_bmc_raw *client_to_kcs_bmc_raw(struct kcs_bmc_client *client)
-{
-	return container_of(client, struct kcs_bmc_raw, client);
-}
-
-/* Call under priv->queue.lock */
-static void kcs_bmc_raw_update_event_mask(struct kcs_bmc_raw *priv, u8 mask, u8 state)
-{
-	kcs_bmc_update_event_mask(priv->client.dev, mask, state);
-	priv->events &= ~mask;
-	priv->events |= state & mask;
-}
-
-static irqreturn_t kcs_bmc_raw_event(struct kcs_bmc_client *client)
-{
-	struct kcs_bmc_raw *priv;
-	struct device *dev;
-	u8 status, handled;
-
-	priv = client_to_kcs_bmc_raw(client);
-	dev = priv->miscdev.this_device;
-
-	spin_lock(&priv->queue.lock);
-
-	status = kcs_bmc_read_status(client->dev);
-	handled = 0;
-
-	if ((priv->events & KCS_BMC_EVENT_TYPE_IBF) && (status & KCS_BMC_STR_IBF)) {
-		if (priv->readable)
-			dev_err(dev, "Unexpected IBF IRQ, dropping data");
-
-		dev_dbg(dev, "Disabling IDR events for back-pressure\n");
-		kcs_bmc_raw_update_event_mask(priv, KCS_BMC_EVENT_TYPE_IBF, 0);
-		priv->idr = kcs_bmc_read_data(client->dev);
-		priv->readable = true;
-
-		dev_dbg(dev, "IDR read, waking waiters\n");
-		wake_up_locked(&priv->queue);
-
-		handled |= KCS_BMC_EVENT_TYPE_IBF;
-	}
-
-	if ((priv->events & KCS_BMC_EVENT_TYPE_OBE) && !(status & KCS_BMC_STR_OBF)) {
-		kcs_bmc_raw_update_event_mask(priv, KCS_BMC_EVENT_TYPE_OBE, 0);
-		priv->writable = true;
-
-		dev_dbg(dev, "ODR writable, waking waiters\n");
-		wake_up_locked(&priv->queue);
-
-		handled |= KCS_BMC_EVENT_TYPE_OBE;
-	}
-
-	spin_unlock(&priv->queue.lock);
-
-	return handled ? IRQ_HANDLED : IRQ_NONE;
-}
-
-static const struct kcs_bmc_client_ops kcs_bmc_raw_client_ops = {
-	.event = kcs_bmc_raw_event,
-};
-
-static inline struct kcs_bmc_raw *file_to_kcs_bmc_raw(struct file *filp)
-{
-	return container_of(filp->private_data, struct kcs_bmc_raw, miscdev);
-}
-
-static int kcs_bmc_raw_open(struct inode *inode, struct file *filp)
-{
-	struct kcs_bmc_raw *priv = file_to_kcs_bmc_raw(filp);
-	int rc;
-
-	priv->events = KCS_BMC_EVENT_TYPE_IBF;
-	rc = kcs_bmc_enable_device(priv->client.dev, &priv->client);
-	if (rc)
-		priv->events = 0;
-
-	return rc;
-}
-
-static bool kcs_bmc_raw_prepare_obe(struct kcs_bmc_raw *priv)
-{
-	bool writable;
-
-	/* Enable the OBE event so we can catch the host clearing OBF */
-	kcs_bmc_raw_update_event_mask(priv, KCS_BMC_EVENT_TYPE_OBE, KCS_BMC_EVENT_TYPE_OBE);
-
-	/* Now that we'll catch an OBE event, check if it's already occurred */
-	writable = !(kcs_bmc_read_status(priv->client.dev) & KCS_BMC_STR_OBF);
-
-	/* If OBF is clear we've missed the OBE event, so disable it */
-	if (writable)
-		kcs_bmc_raw_update_event_mask(priv, KCS_BMC_EVENT_TYPE_OBE, 0);
-
-	return writable;
-}
-
-static __poll_t kcs_bmc_raw_poll(struct file *filp, poll_table *wait)
-{
-	struct kcs_bmc_raw *priv;
-	__poll_t events = 0;
-
-	priv = file_to_kcs_bmc_raw(filp);
-
-	poll_wait(filp, &priv->queue, wait);
-
-	spin_lock_irq(&priv->queue.lock);
-	if (kcs_bmc_raw_prepare_obe(priv))
-		events |= (EPOLLOUT | EPOLLWRNORM);
-
-	if (priv->readable || (kcs_bmc_read_status(priv->client.dev) & KCS_BMC_STR_IBF))
-		events |= (EPOLLIN | EPOLLRDNORM);
-	spin_unlock_irq(&priv->queue.lock);
-
-	return events;
-}
-
-static ssize_t kcs_bmc_raw_read(struct file *filp, char __user *buf,
-			     size_t count, loff_t *ppos)
-{
-	struct kcs_bmc_device *kcs_bmc;
-	struct kcs_bmc_raw *priv;
-	bool read_idr, read_str;
-	struct device *dev;
-	u8 idr, str;
-	ssize_t rc;
-
-	priv = file_to_kcs_bmc_raw(filp);
-	kcs_bmc = priv->client.dev;
-	dev = priv->miscdev.this_device;
-
-	if (!count)
-		return 0;
-
-	if (count > 2 || *ppos > 1)
-		return -EINVAL;
-
-	if (*ppos + count > 2)
-		return -EINVAL;
-
-	read_idr = (*ppos == 0);
-	read_str = (*ppos == 1) || (count == 2);
-
-	spin_lock_irq(&priv->queue.lock);
-	if (read_idr) {
-		dev_dbg(dev, "Waiting for IBF\n");
-		str = kcs_bmc_read_status(kcs_bmc);
-		if ((filp->f_flags & O_NONBLOCK) && (str & KCS_BMC_STR_IBF)) {
-			rc = -EWOULDBLOCK;
-			goto out;
-		}
-
-		rc = wait_event_interruptible_locked(priv->queue,
-						     priv->readable || (str & KCS_BMC_STR_IBF));
-		if (rc < 0)
-			goto out;
-
-		if (signal_pending(current)) {
-			dev_dbg(dev, "Interrupted waiting for IBF\n");
-			rc = -EINTR;
-			goto out;
-		}
-
-		/*
-		 * Re-enable events prior to possible read of IDR (which clears
-		 * IBF) to ensure we receive interrupts for subsequent writes
-		 * to IDR. Writes to IDR by the host should not occur while IBF
-		 * is set.
-		 */
-		dev_dbg(dev, "Woken by IBF, enabling IRQ\n");
-		kcs_bmc_raw_update_event_mask(priv, KCS_BMC_EVENT_TYPE_IBF,
-					      KCS_BMC_EVENT_TYPE_IBF);
-
-		/* Read data out of IDR into internal storage if necessary */
-		if (!priv->readable) {
-			WARN(!(str & KCS_BMC_STR_IBF), "Unknown reason for wakeup!");
-
-			priv->idr = kcs_bmc_read_data(kcs_bmc);
-		}
-
-		/* Copy data from internal storage to userspace */
-		idr = priv->idr;
-
-		/* We're done consuming the internally stored value */
-		priv->readable = false;
-	}
-
-	if (read_str) {
-		str = kcs_bmc_read_status(kcs_bmc);
-		if (*ppos == 0 || priv->readable)
-			/*
-			 * If we got this far with `*ppos == 0` then we've read
-			 * data out of IDR, so set IBF when reporting back to
-			 * userspace so userspace knows the IDR value is valid.
-			 */
-			str |= KCS_BMC_STR_IBF;
-
-		dev_dbg(dev, "Read status 0x%x\n", str);
-
-	}
-
-	rc = count;
-out:
-	spin_unlock_irq(&priv->queue.lock);
-
-	if (rc < 0)
-		return rc;
-
-	/* Now copy the data in to the userspace buffer */
-
-	if (read_idr)
-		if (copy_to_user(buf++, &idr, sizeof(idr)))
-			return -EFAULT;
-
-	if (read_str)
-		if (copy_to_user(buf, &str, sizeof(str)))
-			return -EFAULT;
-
-	return count;
-}
-
-static ssize_t kcs_bmc_raw_write(struct file *filp, const char __user *buf,
-			      size_t count, loff_t *ppos)
-{
-	struct kcs_bmc_device *kcs_bmc;
-	bool write_odr, write_str;
-	struct kcs_bmc_raw *priv;
-	struct device *dev;
-	ssize_t result;
-	u8 data[2];
-	u8 str;
-
-	priv = file_to_kcs_bmc_raw(filp);
-	kcs_bmc = priv->client.dev;
-	dev = priv->miscdev.this_device;
-
-	if (!count)
-		return count;
-
-	if (count > 2)
-		return -EINVAL;
-
-	if (*ppos >= 2)
-		return -EINVAL;
-
-	if (*ppos + count > 2)
-		return -EINVAL;
-
-	if (copy_from_user(data, buf, count))
-		return -EFAULT;
-
-	write_odr = (*ppos == 0);
-	write_str = (*ppos == 1) || (count == 2);
-
-	spin_lock_irq(&priv->queue.lock);
-
-	/* Always write status before data, we generate the SerIRQ by writing ODR */
-	if (write_str) {
-		/* The index of STR in the userspace buffer depends on whether ODR is written */
-		str = data[*ppos == 0];
-		if (!(str & KCS_BMC_STR_OBF))
-			dev_warn(dev, "Clearing OBF with status write: 0x%x\n", str);
-		dev_dbg(dev, "Writing status 0x%x\n", str);
-		kcs_bmc_write_status(kcs_bmc, str);
-	}
-
-	if (write_odr) {
-		/* If we're writing ODR it's always the first byte in the buffer */
-		u8 odr = data[0];
-
-		str = kcs_bmc_read_status(kcs_bmc);
-		if (str & KCS_BMC_STR_OBF) {
-			if (filp->f_flags & O_NONBLOCK) {
-				result = -EWOULDBLOCK;
-				goto out;
-			}
-
-			priv->writable = kcs_bmc_raw_prepare_obe(priv);
-
-			/* Now either OBF is already clear, or we'll get an OBE event to wake us */
-			dev_dbg(dev, "Waiting for OBF to clear\n");
-			wait_event_interruptible_locked(priv->queue, priv->writable);
-
-			if (signal_pending(current)) {
-				kcs_bmc_raw_update_event_mask(priv, KCS_BMC_EVENT_TYPE_OBE, 0);
-				result = -EINTR;
-				goto out;
-			}
-
-			WARN_ON(kcs_bmc_read_status(kcs_bmc) & KCS_BMC_STR_OBF);
-		}
-
-		dev_dbg(dev, "Writing 0x%x to ODR\n", odr);
-		kcs_bmc_write_data(kcs_bmc, odr);
-	}
-
-	result = count;
-out:
-	spin_unlock_irq(&priv->queue.lock);
-
-	return result;
-}
-
-static int kcs_bmc_raw_release(struct inode *inode, struct file *filp)
-{
-	struct kcs_bmc_raw *priv = file_to_kcs_bmc_raw(filp);
-
-	kcs_bmc_disable_device(priv->client.dev, &priv->client);
-	priv->events = 0;
-
-	return 0;
-}
-
-static const struct file_operations kcs_bmc_raw_fops = {
-	.owner          = THIS_MODULE,
-	.open		= kcs_bmc_raw_open,
-	.llseek		= no_seek_end_llseek,
-	.read           = kcs_bmc_raw_read,
-	.write          = kcs_bmc_raw_write,
-	.poll		= kcs_bmc_raw_poll,
-	.release	= kcs_bmc_raw_release,
-};
-
-static DEFINE_SPINLOCK(kcs_bmc_raw_instances_lock);
-static LIST_HEAD(kcs_bmc_raw_instances);
-
-static int kcs_bmc_raw_add_device(struct kcs_bmc_device *kcs_bmc)
-{
-	struct kcs_bmc_raw *priv;
-	int rc;
-
-	priv = devm_kzalloc(kcs_bmc->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	priv->client.dev = kcs_bmc;
-	priv->client.ops = &kcs_bmc_raw_client_ops;
-
-	init_waitqueue_head(&priv->queue);
-	priv->writable = false;
-	priv->readable = false;
-
-	priv->miscdev.minor = MISC_DYNAMIC_MINOR;
-	priv->miscdev.name = devm_kasprintf(kcs_bmc->dev, GFP_KERNEL, "%s%u", DEVICE_NAME,
-					   kcs_bmc->channel);
-	if (!priv->miscdev.name)
-		return -EINVAL;
-
-	priv->miscdev.fops = &kcs_bmc_raw_fops;
-
-	/* Disable interrupts until userspace opens the the chardev */
-	kcs_bmc_raw_update_event_mask(priv, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);
-
-	rc = misc_register(&priv->miscdev);
-	if (rc) {
-		dev_err(kcs_bmc->dev, "Unable to register device\n");
-		return rc;
-	}
-
-	spin_lock_irq(&kcs_bmc_raw_instances_lock);
-	list_add(&priv->entry, &kcs_bmc_raw_instances);
-	spin_unlock_irq(&kcs_bmc_raw_instances_lock);
-
-	dev_info(kcs_bmc->dev, "Initialised raw client for channel %d", kcs_bmc->channel);
-
-	return 0;
-}
-
-static int kcs_bmc_raw_remove_device(struct kcs_bmc_device *kcs_bmc)
-{
-	struct kcs_bmc_raw *priv = NULL, *pos;
-
-	spin_lock_irq(&kcs_bmc_raw_instances_lock);
-	list_for_each_entry(pos, &kcs_bmc_raw_instances, entry) {
-		if (pos->client.dev == kcs_bmc) {
-			priv = pos;
-			list_del(&pos->entry);
-			break;
-		}
-	}
-	spin_unlock_irq(&kcs_bmc_raw_instances_lock);
-
-	if (!priv)
-		return -ENODEV;
-
-	misc_deregister(&priv->miscdev);
-	kcs_bmc_disable_device(kcs_bmc, &priv->client);
-	devm_kfree(priv->client.dev->dev, priv);
-
-	return 0;
-}
-
-static const struct kcs_bmc_driver_ops kcs_bmc_raw_driver_ops = {
-	.add_device = kcs_bmc_raw_add_device,
-	.remove_device = kcs_bmc_raw_remove_device,
-};
-
-static struct kcs_bmc_driver kcs_bmc_raw_driver = {
-	.ops = &kcs_bmc_raw_driver_ops,
-};
-
-static int kcs_bmc_raw_init(void)
-{
-	kcs_bmc_register_driver(&kcs_bmc_raw_driver);
-
-	return 0;
-}
-module_init(kcs_bmc_raw_init);
-
-static void kcs_bmc_raw_exit(void)
-{
-	kcs_bmc_unregister_driver(&kcs_bmc_raw_driver);
-}
-module_exit(kcs_bmc_raw_exit);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Andrew Jeffery <andrew@aj.id.au>");
-MODULE_DESCRIPTION("Character device for raw access to a KCS device");
diff --git a/drivers/char/ipmi/kcs_bmc_client.h b/drivers/char/ipmi/kcs_bmc_client.h
deleted file mode 100644
index 6fdcde0a7169..000000000000
--- a/drivers/char/ipmi/kcs_bmc_client.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright (c) 2021, IBM Corp. */
-
-#ifndef __KCS_BMC_CONSUMER_H__
-#define __KCS_BMC_CONSUMER_H__
-
-#include <linux/irqreturn.h>
-
-#include "kcs_bmc.h"
-
-struct kcs_bmc_driver_ops {
-	int (*add_device)(struct kcs_bmc_device *kcs_bmc);
-	int (*remove_device)(struct kcs_bmc_device *kcs_bmc);
-};
-
-struct kcs_bmc_driver {
-	struct list_head entry;
-
-	const struct kcs_bmc_driver_ops *ops;
-};
-
-struct kcs_bmc_client_ops {
-	irqreturn_t (*event)(struct kcs_bmc_client *client);
-};
-
-struct kcs_bmc_client {
-	const struct kcs_bmc_client_ops *ops;
-
-	struct kcs_bmc_device *dev;
-};
-
-void kcs_bmc_register_driver(struct kcs_bmc_driver *drv);
-void kcs_bmc_unregister_driver(struct kcs_bmc_driver *drv);
-
-int kcs_bmc_enable_device(struct kcs_bmc_device *kcs_bmc, struct kcs_bmc_client *client);
-void kcs_bmc_disable_device(struct kcs_bmc_device *kcs_bmc, struct kcs_bmc_client *client);
-
-void kcs_bmc_update_event_mask(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 events);
-
-u8 kcs_bmc_read_data(struct kcs_bmc_device *kcs_bmc);
-void kcs_bmc_write_data(struct kcs_bmc_device *kcs_bmc, u8 data);
-u8 kcs_bmc_read_status(struct kcs_bmc_device *kcs_bmc);
-void kcs_bmc_write_status(struct kcs_bmc_device *kcs_bmc, u8 data);
-void kcs_bmc_update_status(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 val);
-#endif
diff --git a/drivers/char/ipmi/kcs_bmc_device.h b/drivers/char/ipmi/kcs_bmc_device.h
deleted file mode 100644
index 17c572f25c54..000000000000
--- a/drivers/char/ipmi/kcs_bmc_device.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright (c) 2021, IBM Corp. */
-
-#ifndef __KCS_BMC_DEVICE_H__
-#define __KCS_BMC_DEVICE_H__
-
-#include <linux/irqreturn.h>
-
-#include "kcs_bmc.h"
-
-struct kcs_bmc_device_ops {
-	void (*irq_mask_update)(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 enable);
-	u8 (*io_inputb)(struct kcs_bmc_device *kcs_bmc, u32 reg);
-	void (*io_outputb)(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 b);
-	void (*io_updateb)(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 mask, u8 b);
-};
-
-irqreturn_t kcs_bmc_handle_event(struct kcs_bmc_device *kcs_bmc);
-int kcs_bmc_add_device(struct kcs_bmc_device *kcs_bmc);
-void kcs_bmc_remove_device(struct kcs_bmc_device *kcs_bmc);
-
-#endif
diff --git a/drivers/char/ipmi/kcs_bmc_npcm7xx.c b/drivers/char/ipmi/kcs_bmc_npcm7xx.c
old mode 100644
new mode 100755
index 7961fec56476..722f7391fe1f
--- a/drivers/char/ipmi/kcs_bmc_npcm7xx.c
+++ b/drivers/char/ipmi/kcs_bmc_npcm7xx.c
@@ -17,7 +17,7 @@
 #include <linux/regmap.h>
 #include <linux/slab.h>
 
-#include "kcs_bmc_device.h"
+#include "kcs_bmc.h"
 
 #define DEVICE_NAME	"npcm-kcs-bmc"
 #define KCS_CHANNEL_MAX	3
@@ -38,7 +38,6 @@
 #define KCS2CTL		0x2A
 #define KCS3CTL		0x3C
 #define    KCS_CTL_IBFIE	BIT(0)
-#define    KCS_CTL_OBEIE	BIT(1)
 
 #define KCS1IE		0x1C
 #define KCS2IE		0x2E
@@ -66,8 +65,6 @@ struct npcm7xx_kcs_reg {
 };
 
 struct npcm7xx_kcs_bmc {
-	struct kcs_bmc_device kcs_bmc;
-
 	struct regmap *map;
 
 	const struct npcm7xx_kcs_reg *reg;
@@ -79,14 +76,9 @@ static const struct npcm7xx_kcs_reg npcm7xx_kcs_reg_tbl[KCS_CHANNEL_MAX] = {
 	{ .sts = KCS3ST, .dob = KCS3DO, .dib = KCS3DI, .ctl = KCS3CTL, .ie = KCS3IE },
 };
 
-static inline struct npcm7xx_kcs_bmc *to_npcm7xx_kcs_bmc(struct kcs_bmc_device *kcs_bmc)
+static u8 npcm7xx_kcs_inb(struct kcs_bmc *kcs_bmc, u32 reg)
 {
-	return container_of(kcs_bmc, struct npcm7xx_kcs_bmc, kcs_bmc);
-}
-
-static u8 npcm7xx_kcs_inb(struct kcs_bmc_device *kcs_bmc, u32 reg)
-{
-	struct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);
+	struct npcm7xx_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 	u32 val = 0;
 	int rc;
 
@@ -96,53 +88,37 @@ static u8 npcm7xx_kcs_inb(struct kcs_bmc_device *kcs_bmc, u32 reg)
 	return rc == 0 ? (u8)val : 0;
 }
 
-static void npcm7xx_kcs_outb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 data)
+static void npcm7xx_kcs_outb(struct kcs_bmc *kcs_bmc, u32 reg, u8 data)
 {
-	struct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);
+	struct npcm7xx_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 	int rc;
 
 	rc = regmap_write(priv->map, reg, data);
 	WARN(rc != 0, "regmap_write() failed: %d\n", rc);
 }
 
-static void npcm7xx_kcs_updateb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 mask, u8 data)
+static void npcm7xx_kcs_enable_channel(struct kcs_bmc *kcs_bmc, bool enable)
 {
-	struct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);
-	int rc;
+	struct npcm7xx_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 
-	rc = regmap_update_bits(priv->map, reg, mask, data);
-	WARN(rc != 0, "regmap_update_bits() failed: %d\n", rc);
-}
-
-static void npcm7xx_kcs_enable_channel(struct kcs_bmc_device *kcs_bmc, bool enable)
-{
-	struct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);
+	regmap_update_bits(priv->map, priv->reg->ctl, KCS_CTL_IBFIE,
+			   enable ? KCS_CTL_IBFIE : 0);
 
 	regmap_update_bits(priv->map, priv->reg->ie, KCS_IE_IRQE | KCS_IE_HIRQE,
 			   enable ? KCS_IE_IRQE | KCS_IE_HIRQE : 0);
 }
 
-static void npcm7xx_kcs_irq_mask_update(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 state)
-{
-	struct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);
-
-	if (mask & KCS_BMC_EVENT_TYPE_OBE)
-		regmap_update_bits(priv->map, priv->reg->ctl, KCS_CTL_OBEIE,
-				   !!(state & KCS_BMC_EVENT_TYPE_OBE) * KCS_CTL_OBEIE);
-
-	if (mask & KCS_BMC_EVENT_TYPE_IBF)
-		regmap_update_bits(priv->map, priv->reg->ctl, KCS_CTL_IBFIE,
-				   !!(state & KCS_BMC_EVENT_TYPE_IBF) * KCS_CTL_IBFIE);
-}
-
 static irqreturn_t npcm7xx_kcs_irq(int irq, void *arg)
 {
-	struct kcs_bmc_device *kcs_bmc = arg;
+	struct kcs_bmc *kcs_bmc = arg;
 
-	return kcs_bmc_handle_event(kcs_bmc);
+	if (!kcs_bmc_handle_event(kcs_bmc))
+		return IRQ_HANDLED;
+
+	return IRQ_NONE;
 }
 
-static int npcm7xx_kcs_config_irq(struct kcs_bmc_device *kcs_bmc,
+static int npcm7xx_kcs_config_irq(struct kcs_bmc *kcs_bmc,
 				  struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -156,18 +132,11 @@ static int npcm7xx_kcs_config_irq(struct kcs_bmc_device *kcs_bmc,
 				dev_name(dev), kcs_bmc);
 }
 
-static const struct kcs_bmc_device_ops npcm7xx_kcs_ops = {
-	.irq_mask_update = npcm7xx_kcs_irq_mask_update,
-	.io_inputb = npcm7xx_kcs_inb,
-	.io_outputb = npcm7xx_kcs_outb,
-	.io_updateb = npcm7xx_kcs_updateb,
-};
-
 static int npcm7xx_kcs_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct npcm7xx_kcs_bmc *priv;
-	struct kcs_bmc_device *kcs_bmc;
+	struct kcs_bmc *kcs_bmc;
 	u32 chan;
 	int rc;
 
@@ -177,10 +146,11 @@ static int npcm7xx_kcs_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
+	kcs_bmc = kcs_bmc_alloc(dev, sizeof(*priv), chan);
+	if (!kcs_bmc)
 		return -ENOMEM;
 
+	priv = kcs_bmc_priv(kcs_bmc);
 	priv->map = syscon_node_to_regmap(dev->parent->of_node);
 	if (IS_ERR(priv->map)) {
 		dev_err(dev, "Couldn't get regmap\n");
@@ -188,26 +158,22 @@ static int npcm7xx_kcs_probe(struct platform_device *pdev)
 	}
 	priv->reg = &npcm7xx_kcs_reg_tbl[chan - 1];
 
-	kcs_bmc = &priv->kcs_bmc;
-	kcs_bmc->dev = &pdev->dev;
-	kcs_bmc->channel = chan;
 	kcs_bmc->ioreg.idr = priv->reg->dib;
 	kcs_bmc->ioreg.odr = priv->reg->dob;
 	kcs_bmc->ioreg.str = priv->reg->sts;
-	kcs_bmc->ops = &npcm7xx_kcs_ops;
+	kcs_bmc->io_inputb = npcm7xx_kcs_inb;
+	kcs_bmc->io_outputb = npcm7xx_kcs_outb;
 
-	platform_set_drvdata(pdev, priv);
+	dev_set_drvdata(dev, kcs_bmc);
 
+	npcm7xx_kcs_enable_channel(kcs_bmc, true);
 	rc = npcm7xx_kcs_config_irq(kcs_bmc, pdev);
 	if (rc)
 		return rc;
 
-	npcm7xx_kcs_irq_mask_update(kcs_bmc, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);
-	npcm7xx_kcs_enable_channel(kcs_bmc, true);
-
-	rc = kcs_bmc_add_device(kcs_bmc);
+	rc = misc_register(&kcs_bmc->miscdev);
 	if (rc) {
-		dev_warn(&pdev->dev, "Failed to register channel %d: %d\n", kcs_bmc->channel, rc);
+		dev_err(dev, "Unable to register device\n");
 		return rc;
 	}
 
@@ -220,13 +186,9 @@ static int npcm7xx_kcs_probe(struct platform_device *pdev)
 
 static int npcm7xx_kcs_remove(struct platform_device *pdev)
 {
-	struct npcm7xx_kcs_bmc *priv = platform_get_drvdata(pdev);
-	struct kcs_bmc_device *kcs_bmc = &priv->kcs_bmc;
-
-	kcs_bmc_remove_device(kcs_bmc);
+	struct kcs_bmc *kcs_bmc = dev_get_drvdata(&pdev->dev);
 
-	npcm7xx_kcs_enable_channel(kcs_bmc, false);
-	npcm7xx_kcs_irq_mask_update(kcs_bmc, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);
+	misc_deregister(&kcs_bmc->miscdev);
 
 	return 0;
 }
diff --git a/drivers/char/ipmi/kcs_bmc_serio.c b/drivers/char/ipmi/kcs_bmc_serio.c
deleted file mode 100644
index 7e2067628a6c..000000000000
--- a/drivers/char/ipmi/kcs_bmc_serio.c
+++ /dev/null
@@ -1,159 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/* Copyright (c) 2021 IBM Corp. */
-
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/errno.h>
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/sched/signal.h>
-#include <linux/serio.h>
-#include <linux/slab.h>
-
-#include "kcs_bmc_client.h"
-
-struct kcs_bmc_serio {
-	struct list_head entry;
-
-	struct kcs_bmc_client client;
-	struct serio *port;
-
-	spinlock_t lock;
-};
-
-static inline struct kcs_bmc_serio *client_to_kcs_bmc_serio(struct kcs_bmc_client *client)
-{
-	return container_of(client, struct kcs_bmc_serio, client);
-}
-
-static irqreturn_t kcs_bmc_serio_event(struct kcs_bmc_client *client)
-{
-	struct kcs_bmc_serio *priv;
-	u8 handled = IRQ_NONE;
-	u8 status;
-
-	priv = client_to_kcs_bmc_serio(client);
-
-	spin_lock(&priv->lock);
-
-	status = kcs_bmc_read_status(client->dev);
-
-	if (status & KCS_BMC_STR_IBF)
-		handled = serio_interrupt(priv->port, kcs_bmc_read_data(client->dev), 0);
-
-	spin_unlock(&priv->lock);
-
-	return handled;
-}
-
-static const struct kcs_bmc_client_ops kcs_bmc_serio_client_ops = {
-	.event = kcs_bmc_serio_event,
-};
-
-static int kcs_bmc_serio_open(struct serio *port)
-{
-	struct kcs_bmc_serio *priv = port->port_data;
-
-	return kcs_bmc_enable_device(priv->client.dev, &priv->client);
-}
-
-static void kcs_bmc_serio_close(struct serio *port)
-{
-	struct kcs_bmc_serio *priv = port->port_data;
-
-	kcs_bmc_disable_device(priv->client.dev, &priv->client);
-}
-
-static DEFINE_SPINLOCK(kcs_bmc_serio_instances_lock);
-static LIST_HEAD(kcs_bmc_serio_instances);
-
-static int kcs_bmc_serio_add_device(struct kcs_bmc_device *kcs_bmc)
-{
-	struct kcs_bmc_serio *priv;
-	struct serio *port;
-
-	priv = devm_kzalloc(kcs_bmc->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	/* Use kzalloc() as the allocation is cleaned up with kfree() via serio_unregister_port() */
-	port = kzalloc(sizeof(*port), GFP_KERNEL);
-	if (!port)
-		return -ENOMEM;
-
-	port->id.type = SERIO_8042;
-	port->open = kcs_bmc_serio_open;
-	port->close = kcs_bmc_serio_close;
-	port->port_data = priv;
-	port->dev.parent = kcs_bmc->dev;
-
-	spin_lock_init(&priv->lock);
-	priv->port = port;
-	priv->client.dev = kcs_bmc;
-	priv->client.ops = &kcs_bmc_serio_client_ops;
-
-	spin_lock_irq(&kcs_bmc_serio_instances_lock);
-	list_add(&priv->entry, &kcs_bmc_serio_instances);
-	spin_unlock_irq(&kcs_bmc_serio_instances_lock);
-
-	serio_register_port(port);
-
-	dev_info(kcs_bmc->dev, "Initialised serio client for channel %d", kcs_bmc->channel);
-
-	return 0;
-}
-
-static int kcs_bmc_serio_remove_device(struct kcs_bmc_device *kcs_bmc)
-{
-	struct kcs_bmc_serio *priv = NULL, *pos;
-
-	spin_lock_irq(&kcs_bmc_serio_instances_lock);
-	list_for_each_entry(pos, &kcs_bmc_serio_instances, entry) {
-		if (pos->client.dev == kcs_bmc) {
-			priv = pos;
-			list_del(&pos->entry);
-			break;
-		}
-	}
-	spin_unlock_irq(&kcs_bmc_serio_instances_lock);
-
-	if (!priv)
-		return -ENODEV;
-
-	/* kfree()s priv->port via put_device() */
-	serio_unregister_port(priv->port);
-
-	/* Ensure the IBF IRQ is disabled if we were the active client */
-	kcs_bmc_disable_device(kcs_bmc, &priv->client);
-
-	devm_kfree(priv->client.dev->dev, priv);
-
-	return 0;
-}
-
-static const struct kcs_bmc_driver_ops kcs_bmc_serio_driver_ops = {
-	.add_device = kcs_bmc_serio_add_device,
-	.remove_device = kcs_bmc_serio_remove_device,
-};
-
-static struct kcs_bmc_driver kcs_bmc_serio_driver = {
-	.ops = &kcs_bmc_serio_driver_ops,
-};
-
-static int kcs_bmc_serio_init(void)
-{
-	kcs_bmc_register_driver(&kcs_bmc_serio_driver);
-
-	return 0;
-}
-module_init(kcs_bmc_serio_init);
-
-static void kcs_bmc_serio_exit(void)
-{
-	kcs_bmc_unregister_driver(&kcs_bmc_serio_driver);
-}
-module_exit(kcs_bmc_serio_exit);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Andrew Jeffery <andrew@aj.id.au>");
-MODULE_DESCRIPTION("Adapter driver for serio access to BMC KCS devices");
