From 13f441458aad55846d2033488ceabafeb4e67ec3 Mon Sep 17 00:00:00 2001
From: Tommy Lin <lin.tommysc@inventec.com>
Date: Fri, 7 Jan 2022 02:32:51 +0000
Subject: [PATCH] Add ETag support for Redfish

Symptom/Reason:
    - Implement ETag for Redfish

Root Cause:
    - N/A

Solution/Change:
    [bmcweb]
      - Implement ETag for Redfish
      - Add BMCWEB_ENABLE_REDFISH_ETAG macro for ETag enablement

Entry Test:
    - Get NetworkProtocol configuration
    curl -X GET https://${bmc}/redfish/v1/Managers/bmc/NetworkProtocol
---
 http/http_connection.hpp |   3 +-
 http/routing.hpp         | 171 ++++++++++++++++++++++++++++++++++++++-
 http/utility.hpp         |  81 +++++++++++++++++++
 meson.build              |   1 +
 meson_options.txt        |   8 ++
 5 files changed, 261 insertions(+), 3 deletions(-)

diff --git a/http/http_connection.hpp b/http/http_connection.hpp
index feea8158..d923d59f 100644
--- a/http/http_connection.hpp
+++ b/http/http_connection.hpp
@@ -470,7 +470,8 @@ class Connection :
             res.body() = std::string(res.reason());
         }
 
-        if (res.result() == boost::beast::http::status::no_content)
+        if (res.result() == boost::beast::http::status::no_content
+            || res.result() == boost::beast::http::status::not_modified)
         {
             // Boost beast throws if content is provided on a no-content
             // response.  Ideally, this would never happen, but in the case that
diff --git a/http/routing.hpp b/http/routing.hpp
index 3c0917f8..4e363f00 100644
--- a/http/routing.hpp
+++ b/http/routing.hpp
@@ -23,6 +23,10 @@
 #include <tuple>
 #include <utility>
 #include <vector>
+#ifdef BMCWEB_ENABLE_REDFISH_ETAG
+#include <random>
+#endif
+
 
 namespace crow
 {
@@ -1087,6 +1091,11 @@ class Router
         std::unique_ptr<RuleT> ruleObject = std::make_unique<RuleT>(rule);
         RuleT* ptr = ruleObject.get();
         allRules.emplace_back(std::move(ruleObject));
+        #ifdef BMCWEB_ENABLE_REDFISH_ETAG
+        srand(static_cast<unsigned>(time(NULL)));
+        // Init hash value and random offset
+        eTags[ptr->rule] = std::make_pair(0, rand());
+        #endif
 
         return *ptr;
     }
@@ -1289,15 +1298,28 @@ class Router
                          << static_cast<uint32_t>(req.method()) << " / "
                          << rules[ruleIndex]->getMethods();
 
+        #ifdef BMCWEB_ENABLE_REDFISH_ETAG
+        std::pair<std::size_t, uint32_t>& etag = eTags[rules[ruleIndex]->rule]; // <ETag, rand_offset>
+        #endif
+
         if (req.session == nullptr)
         {
+            #ifdef BMCWEB_ENABLE_REDFISH_ETAG
+            Router::internalHandle(req, asyncResp, rules[ruleIndex], found.second, etag);
+            #else
             rules[ruleIndex]->handle(req, asyncResp, found.second);
+            #endif
+
             return;
         }
 
         crow::connections::systemBus->async_method_call(
-            [&req, asyncResp, &rules, ruleIndex,
-             found](const boost::system::error_code ec,
+            #ifdef BMCWEB_ENABLE_REDFISH_ETAG
+            [&req, asyncResp, &rules, ruleIndex, found, &etag](
+            #else
+            [&req, asyncResp, &rules, ruleIndex, found](
+            #endif
+                const boost::system::error_code ec,
                     const dbus::utility::DBusPropertiesMap& userInfoMap) {
             if (ec)
             {
@@ -1394,7 +1416,12 @@ class Router
             }
 
             req.userRole = userRole;
+
+            #ifdef BMCWEB_ENABLE_REDFISH_ETAG
+            Router::internalHandle(req, asyncResp, rules[ruleIndex], found.second, etag);
+            #else
             rules[ruleIndex]->handle(req, asyncResp, found.second);
+            #endif
             },
             "xyz.openbmc_project.User.Manager", "/xyz/openbmc_project/user",
             "xyz.openbmc_project.User.Manager", "GetUserInfo",
@@ -1443,5 +1470,145 @@ class Router
 
     std::array<PerMethod, maxHttpVerbCount> perMethods;
     std::vector<std::unique_ptr<BaseRule>> allRules;
+
+    #ifdef BMCWEB_ENABLE_REDFISH_ETAG
+    std::map<std::string, std::pair<std::size_t, uint32_t>> eTags;
+
+    static void internalHandle(
+                Request& req,
+                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                BaseRule* rule,
+                const RoutingParams& params,
+                std::pair<std::size_t, uint32_t>& etag)
+    {
+        // ETag check update pre-condition
+        std::size_t in_etag = 0;
+        std::string etag_str_in;
+        std::vector<std::size_t> in_etags;
+        bool precondition = false;
+
+        if (req.method() == boost::beast::http::verb::get)
+        {
+            etag_str_in = req.getHeaderValue("If-None-Match");
+            precondition = !etag_str_in.empty();
+
+            // parse If-None-Match header
+            if (precondition)
+            {
+                std::size_t offset = etag_str_in.find_first_not_of(' ');
+                while (offset != std::string::npos)
+                {
+                    etag_str_in = etag_str_in.substr(offset);
+                    in_etag = crow::utility::strv2Uint(crow::utility::extractETag(etag_str_in, true));
+
+                    if (in_etag != 0)
+                    {
+                        in_etags.push_back(in_etag);
+                    }
+
+                    offset = etag_str_in.find_first_of(' ');
+
+                    if ((offset == std::string::npos))
+                    {
+                        // no more ETag value to parse
+                        break;
+                    }
+
+                    etag_str_in = etag_str_in.substr(offset);
+                    offset = etag_str_in.find_first_not_of(' ');
+                }
+            }
+        }
+        else if (crow::utility::isUpdateMethod(req.method()))
+        {
+            etag_str_in = req.getHeaderValue("If-Match");
+            precondition = !etag_str_in.empty();
+
+            // parse If-Match header
+            if (precondition)
+            {
+                bool match = false;
+                std::size_t offset = etag_str_in.find_first_not_of(' ');
+
+                while (offset != std::string::npos)
+                {
+                    etag_str_in = etag_str_in.substr(offset);
+                    in_etag = crow::utility::strv2Uint(crow::utility::extractETag(etag_str_in, false));
+
+                    if (in_etag != 0 && etag.first == in_etag)
+                    {
+                        // match found, no need for further parsing
+                        match = true;
+                        break;
+                    }
+
+                    offset = etag_str_in.find_first_of(' ');
+
+                    if ((offset == std::string::npos))
+                    {
+                        // no more ETag value to parse
+                        break;
+                    }
+
+                    etag_str_in = etag_str_in.substr(offset);
+                    offset = etag_str_in.find_first_not_of(' ');
+                }
+
+                if (!match)
+                {
+                    // Return precondition_failed when If-Match precondition is provided and no match
+                    asyncResp->res.result(boost::beast::http::status::precondition_failed);
+                    return;
+                }
+            }
+        }
+
+        rule->handle(req, asyncResp, params);
+
+        std::size_t out_etag = 0;
+
+        // Check ETag and see if client update is required
+        if (req.method() == boost::beast::http::verb::get
+            && asyncResp->res.result() == boost::beast::http::status::ok)
+        {
+            // compare etag value
+            out_etag = std::hash<nlohmann::json>{}(asyncResp->res.jsonValue);
+            out_etag += etag.second;
+
+            if (precondition)
+            {
+                for(auto e_tag : in_etags)
+                {
+                    if (e_tag != 0 && e_tag == out_etag)
+                    {
+                        asyncResp->res.result(boost::beast::http::status::not_modified);
+                        return;
+                    }
+                }
+            }
+
+            etag.first = out_etag;
+        }
+        else if (crow::utility::isUpdateMethod(req.method())
+            && (asyncResp->res.result() == boost::beast::http::status::ok
+            || asyncResp->res.result() == boost::beast::http::status::no_content))
+        {
+            // Force change random offset after update
+            srand(static_cast<unsigned>(time(NULL)));
+            // Re-calculate ETag value
+            etag.first -= etag.second;
+            etag.second = static_cast<uint32_t>(rand());
+            etag.first += etag.second;
+            out_etag = etag.first;
+        }
+
+        if (out_etag)
+        {
+            std::string etag_str_out = std::to_string(out_etag);
+            asyncResp->res.addHeader("ETag", etag_str_out);
+            asyncResp->res.jsonValue["@odata.etag"] = etag_str_out;
+        }
+    }
+    #endif
 };
 } // namespace crow
diff --git a/http/utility.hpp b/http/utility.hpp
index d6f31d07..06dae0db 100644
--- a/http/utility.hpp
+++ b/http/utility.hpp
@@ -9,6 +9,7 @@
 #include <nlohmann/json.hpp>
 
 #include <array>
+#include <charconv>
 #include <chrono>
 #include <cstddef>
 #include <cstdint>
@@ -808,6 +809,86 @@ inline bool validateAndSplitUrl(std::string_view destUrl, std::string& urlProto,
     return true;
 }
 
+inline std::size_t strv2Uint(const std::string_view input)
+{
+    std::size_t out = 0;
+    if (input.empty())
+    {
+        return 0;
+    }
+
+    const std::from_chars_result result = std::from_chars(input.data(), input.data() + input.size(), out);
+    if(result.ec == std::errc::invalid_argument || result.ec == std::errc::result_out_of_range)
+    {
+        out = 0;
+    }
+
+    return out;
+}
+
+inline std::string extractETag(const std::string& input, bool allow_weak)
+{
+    std::string ret = input;
+    std::size_t offset = ret.find_first_of("W/");
+
+    try
+    {
+        if (offset != std::string::npos)
+        {
+            if (!allow_weak)
+            {
+                // return directly since weak comparison is not allowed
+                return "";
+            }
+            // rip off "W/" prefix
+            ret = ret.substr(offset + 2);
+        }
+
+        // trim left space
+        ret = ret.substr(ret.find_first_not_of(' '));
+
+        if (isdigit(ret[0]))
+        {
+            // extract number string directly
+            ret = ret.substr(0, ret.find_first_of(' '));
+        }
+        else if (ret[0] == '"')
+        {
+            // rip off first double quote
+            ret = ret.substr(ret.find_first_not_of('"'));
+            // rip off second double quote
+            ret = ret.substr(0, ret.find_first_of('"'));
+        }
+        else
+        {
+            ret = "";
+        }
+    }
+    catch (const std::out_of_range& oor)
+    {
+        BMCWEB_LOG_ERROR << "out_of_range : " << oor.what();
+        ret = "";
+    }
+
+    return ret;
+}
+
+inline bool isUpdateMethod(const boost::beast::http::verb method)
+{
+    using namespace boost::beast::http;
+    bool ret = false;
+
+    if (method == verb::delete_
+        || method == verb::post
+        || method == verb::put
+        || method == verb::patch)
+    {
+        ret = true;
+    }
+
+    return ret;
+}
+
 } // namespace utility
 } // namespace crow
 
diff --git a/meson.build b/meson.build
index ad1f4018..325a546c 100644
--- a/meson.build
+++ b/meson.build
@@ -89,6 +89,7 @@ feature_map = {
   'vm-websocket'                                : '-DBMCWEB_ENABLE_VM_WEBSOCKET',
   'xtoken-auth'                                 : '-DBMCWEB_ENABLE_XTOKEN_AUTHENTICATION',
   #'vm-nbdproxy'                                : '-DBMCWEB_ENABLE_VM_NBDPROXY',
+  'redfish-enable-etag'                         : '-DBMCWEB_ENABLE_REDFISH_ETAG',
 }
 
 # Get the options status and build a project summary to show which flags are
diff --git a/meson_options.txt b/meson_options.txt
index a32a4a4f..a849fb64 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -35,6 +35,7 @@ option(
 # this interface, so for the moment this appears to be dead code;  In leiu of
 # removing it, it has been disabled to try to give those that use it the
 # opportunity to upstream their backend implementation
+
 #option(
 #    'vm-nbdproxy',
 #    type: 'feature', value: 'disabled',
@@ -239,6 +240,13 @@ option(
     description: 'Allows this BMC to aggregate resources from satellite BMCs'
 )
 
+option(
+    'redfish-enable-etag', 
+    type : 'feature', 
+    value : 'disabled', 
+    description : 'Enable ETag feature support for Redfish.'
+)
+
 # Insecure options. Every option that starts with a `insecure` flag should
 # not be enabled by default for any platform, unless the author fully comprehends
 # the implications of doing so.In general, enabling these options will cause security
-- 
2.33.0

