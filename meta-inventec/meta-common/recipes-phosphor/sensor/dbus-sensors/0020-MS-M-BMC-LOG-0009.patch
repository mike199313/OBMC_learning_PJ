From 248af6642a7fd18799f37f992153ea3d420e2fd0 Mon Sep 17 00:00:00 2001
From: "sun.cwsun" <sun.cwsun@inventec.com>
Date: Fri, 6 May 2022 15:24:53 +0800
Subject: [PATCH 20/27] Bug 962 - [SW][Transformers][IPMI] M_BMC_log0009 The
 BMC generate an Intel Management Engine Health SEL

    Symptom/Reason :
		- The BMC generate an Intel Management Engine Health SEL if the management engine stops responding or has internal errors.

	Root Cause:
        - None

    Solution/Change:
        [dbus-sensors]
            - Checking the Intel ME regularly, if failed, generate Intel ME health SEL.

		[entity-manager]
			- Add event sensor for Fast-throttling

    Entry Test:
	- by running in testing mode
		/usr/bin/ms_subsystem_check  -t

	- check sel
		-- ipmitool sel elist
		   181 | 05/06/22 | 07:16:28 UTC | reserved IntelMEHealth |  | Asserted
	    -- ipmitool raw 0x0a 0x43 0x00 0x00 0x81 0x01 0x00 0xFF
           ff ff 81 01 02 4c cb 74 62 20 00 04 00 b4 6f 82 00 00
---
 src/ms_subsystem_check.cpp | 119 ++++++++++++++++++++++++++++---------
 1 file changed, 91 insertions(+), 28 deletions(-)

diff --git a/src/ms_subsystem_check.cpp b/src/ms_subsystem_check.cpp
index 913a620..cf4c09f 100644
--- a/src/ms_subsystem_check.cpp
+++ b/src/ms_subsystem_check.cpp
@@ -37,16 +37,21 @@
 #include <utility>
 #include <variant>
 #include <vector>
+#include <unistd.h>
 
-static const std::string DBUS_OBJPATH_SUBYSTEM_HEALTH_CHECK = "/xyz/openbmc_project/sensors/discrete_6fh/management_subsystem_health/Subsystem_health";
+static const std::string DBUS_OBJPATH_SUBYSTEM_HEALTH_CHECK = 
+                        "/xyz/openbmc_project/sensors/discrete_6fh/management_subsystem_health/Subsystem_health";
 
 
+static const std::string DBUS_OBJPATH_INTEL_ME_HEALTH_CHECK = 
+                        "/xyz/openbmc_project/sensors/discrete_6fh/me_health_event/IntelMEHealth";
+
 
 static const int MAX_SLEEP_TIME = 300;
 static const int FULL_DATA = 0xFF;
 
 static const int RESP_INDEX_POWER_STATUS = 1;
-static const int RESP_INDEX_RETURN_STATUS = 0;
+static const int RESP_INDEX_COMPLETE_CODE = 0;
 static const int RESP_INDEX_SENSOR_NUMBER = 10;
 static const int RESP_INDEX_RECORD_ID_LSB = 1;
 static const int RESP_INDEX_RECORD_ID_MSB = 2;
@@ -58,12 +63,13 @@ static const int CMD_INDEX_RECORD_ID_MSB = 3;
 static const int CMD_INDEX_DATA_LENGTH = 5;
 static const int CMD_INDEX_SENSOR_NUMBER = 0;
 
-int CHECKING_HOST_POWER_ON = 1;
+int CMD_OPTION_TEST_MODE = 0x00; // -t
 
-void dbg_payload(std::vector<uint8_t>& data, const char* prompt)
+#if 0
+static void dbg_payload(std::vector<uint8_t>& data, const char* prompt)
 {
 
-    fprintf(stderr, "%s =>", prompt);
+    fprintf(stderr, "%s", prompt);
     for (auto v : data)
     {
         fprintf(stderr, "%02X,", v);
@@ -71,9 +77,9 @@ void dbg_payload(std::vector<uint8_t>& data, const char* prompt)
     fprintf(stderr, "\n");
 
 }
+#endif
 
-
-void do_SEL(
+void do_SystemEventRecordSEL(
             std::shared_ptr<sdbusplus::asio::connection> conn,
             const std::string& eventObjPath, 
             const std::vector<uint8_t>& eventData, 
@@ -102,7 +108,56 @@ void do_SEL(
     }
 }
 
-void check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::connection> bus)
+
+void static check_IntelME_sensor_status(std::shared_ptr<sdbusplus::asio::connection> bus)
+{
+
+    fprintf(stderr, "%s \n", __func__);
+    uint8_t lun = 0;
+    uint8_t netfn = 0x06;
+    uint8_t cmd = 0x34; //Send Message
+    std::vector<uint8_t> cmdData = {0x46, 0x2c, 0x18, 0xbc, 0x20, 0x04, 0x01, 0xdb};
+    auto retConvey = std::make_shared<DbusRspData>();
+    std::vector<uint8_t> eventData = {0x82, 0x00, 0x00};
+
+    if(CMD_OPTION_TEST_MODE){
+        cmdData.at(6) = 0xFF;
+        cmdData.at(7) = 0xFF;
+    }
+
+    //Using IPMI SendMessage (0x06, 0x34)to test INTEL ME through IPMB driver
+    ipmi_method_call(lun, netfn, cmd, cmdData, retConvey);
+    
+    if(retConvey->retData[RESP_INDEX_COMPLETE_CODE] == 0x00){
+        // Check if data return
+        if (retConvey->retData.size() <= 1)
+        {
+            // only complete code return, treat as error
+            do_SystemEventRecordSEL(
+                    bus,
+                    DBUS_OBJPATH_INTEL_ME_HEALTH_CHECK,
+                    eventData,
+                    std::string("Check Intel ME health event"), 
+                    true,
+                    static_cast<uint8_t>(0x20));
+            fprintf(stderr, "do SEL for Intel ME health check\n");
+        }
+    }else{
+        do_SystemEventRecordSEL(
+                    bus,
+                    DBUS_OBJPATH_INTEL_ME_HEALTH_CHECK,
+                    eventData,
+                    std::string("Check Intel ME health event"), 
+                    true,
+                    static_cast<uint8_t>(0x20));
+        
+        fprintf(stderr, "do SEL for Intel ME health check\n");
+
+    }
+}
+
+
+void static check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::connection> bus)
 {
     fprintf(stderr, "%s \n", __func__);
     uint8_t lun = 0;
@@ -111,17 +166,17 @@ void check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::connection>
     std::vector<uint8_t> cmdData;
     auto retConvey = std::make_shared<DbusRspData>();
 
-    //If the motherboard is power on, then check the subsystem health
-    fprintf(stderr, "CHECKING_HOST_POWER_ON=%d\n", CHECKING_HOST_POWER_ON);
-    if(CHECKING_HOST_POWER_ON != 0)
+    //if not in TEST MODE check
+    //if the motherboard is power on, 
+    //if host power on, then check the subsystem health
+    if(CMD_OPTION_TEST_MODE == 0)
     {
         netfn = 0x00; // Chassis
         cmd = 0x01;   // get chassis status
         ipmi_method_call(lun, netfn, cmd, cmdData, retConvey);
         if ((retConvey->ec.value() == 0x00) &&
-            (retConvey->retData.at(RESP_INDEX_RETURN_STATUS) == 0x00))
+            (retConvey->retData.at(RESP_INDEX_COMPLETE_CODE) == 0x00))
         {
-            dbg_payload(retConvey->retData, "get chassis status");
             // if chassis status power off, do not check the subsystem health
             if ((retConvey->retData.at(RESP_INDEX_POWER_STATUS) & 0x01) == 0x00)
             {
@@ -134,7 +189,7 @@ void check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::connection>
             fprintf(stderr,
                     "Get Chassis status command error ec=%d ipmi err=%d \n",
                     retConvey->ec.value(),
-                    retConvey->retData.at(RESP_INDEX_RETURN_STATUS));
+                    retConvey->retData.at(RESP_INDEX_COMPLETE_CODE));
             return;
         }
     }
@@ -148,12 +203,10 @@ void check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::connection>
     cmdData.at(CMD_INDEX_DATA_LENGTH) = FULL_DATA; // all the data
 
     for(int i=0; i<255; i++){
-        //dbg_payload(cmdData, "cmdData");
         //Get SDR record of specified record id
         ipmi_method_call(lun, netfn, cmd, cmdData, retConvey);
-        //dbg_payload(retConvey->retData, "retData");
-
-        if(retConvey->retData.at(RESP_INDEX_RETURN_STATUS) == 0x00
+        
+        if(retConvey->retData.at(RESP_INDEX_COMPLETE_CODE) == 0x00
             && retConvey->retData.at(RESP_INDEX_RECORD_TYPE) == 0x01)
         {
             // using IPMI GET SENSOR DATA READING (netfn=0x04, cmd=0x2d with sensor number to get reading status)
@@ -164,17 +217,15 @@ void check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::connection>
             auto retConvey2 = std::make_shared<DbusRspData>();
             cmdData2.at(CMD_INDEX_SENSOR_NUMBER) = retConvey->retData.at(RESP_INDEX_SENSOR_NUMBER); //set SensorNumber;
 
-            //dbg_payload(cmdData2, "cmdData2");
             ipmi_method_call(lun2, netfn2, cmd2, cmdData2, retConvey2);
-            //dbg_payload(retConvey2->retData, "retData2");
-
-            if(retConvey2->retData.at(RESP_INDEX_RETURN_STATUS) == 0x00){
+            
+            if(retConvey2->retData.at(RESP_INDEX_COMPLETE_CODE) == 0x00){
                 if(retConvey2->retData.at(RESP_INDEX_READING_STATUS) & 0x20){
                     //unavailable, do SEL MS M-BMC-LOG-007
                     std::string sensorId(retConvey->retData.begin()+51, retConvey->retData.end());
                     fprintf(stderr, "%s do SEL MS M-BMC-LOG-007 \n", sensorId.c_str());
                     std::vector<uint8_t> eventData = {0xC0, retConvey->retData.at(RESP_INDEX_SENSOR_NUMBER), 0xFF};
-                    do_SEL(
+                    do_SystemEventRecordSEL(
                         bus,
                         DBUS_OBJPATH_SUBYSTEM_HEALTH_CHECK,
                         eventData,
@@ -205,13 +256,24 @@ void check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::connection>
     }
 }
 
-
 int main(int argc, char** argv)
 {
-    if(argc > 1){
-        std::stringstream ss;
-        ss << argv[1];
-        ss >> CHECKING_HOST_POWER_ON;
+    int opt;
+
+    while ((opt = getopt(argc, argv, "t")) != -1)
+    {
+        switch (opt)
+        {
+            case 't':
+            {
+                CMD_OPTION_TEST_MODE = 1;
+            }
+            break;
+
+            default:{
+                std::cout << argv[0] << " -t";
+            }
+        }
     }
 
     boost::asio::io_service io;
@@ -220,6 +282,7 @@ int main(int argc, char** argv)
     while(true)
     {
         check_subsystem_sensor_status(systemBus);
+        check_IntelME_sensor_status(systemBus);
         sleep(MAX_SLEEP_TIME);
     }
     io.run();
-- 
2.33.0

