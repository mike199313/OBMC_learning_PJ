From 80ba395972f83b6189375abcb22ecb38247e7c14 Mon Sep 17 00:00:00 2001
From: "sun.cwsun" <sun.cwsun@inventec.com>
Date: Tue, 24 May 2022 21:59:49 +0800
Subject: [PATCH 23/27] Bug 1025 - [SW][Transformers][OpenBMC] M-BMC-LOG-0005
 Generate System reconfiguration SEL <br> Bug 1092 - [Transformers] fix
 building error of dbus-sensors - The BMC should generate a System
 Reconfiguration SELif the configuration provided by BIOS is different from
 the BMC persistent records.<br> Bug 1096 - [Transformers][OpenBMC][IPMI] To
 check power supply status event from sel list got un-expected result<br>

---
 ...openbmc_project.ms_subsystem_check.service |   2 -
 src/ms_subsystem_check.cpp                    | 869 ++++++++++++++----
 2 files changed, 699 insertions(+), 172 deletions(-)

diff --git a/service_files/xyz.openbmc_project.ms_subsystem_check.service b/service_files/xyz.openbmc_project.ms_subsystem_check.service
index 222b334..98a4bf7 100644
--- a/service_files/xyz.openbmc_project.ms_subsystem_check.service
+++ b/service_files/xyz.openbmc_project.ms_subsystem_check.service
@@ -1,8 +1,6 @@
 [Unit]
 Description=MS Subsystem health check
 StopWhenUnneeded=false
-Requires=xyz.openbmc_project.eventsensor.service
-After=xyz.openbmc_project.eventsensor.service
 
 [Service]
 Restart=always
diff --git a/src/ms_subsystem_check.cpp b/src/ms_subsystem_check.cpp
index 409a423..a5b881b 100644
--- a/src/ms_subsystem_check.cpp
+++ b/src/ms_subsystem_check.cpp
@@ -14,7 +14,8 @@
 // limitations under the License.
 */
 
-#include <chrono>
+#include <unistd.h>
+
 #include <Utils.hpp>
 #include <boost/algorithm/string/predicate.hpp>
 #include <boost/algorithm/string/replace.hpp>
@@ -25,6 +26,7 @@
 #include <sdbusplus/bus/match.hpp>
 
 #include <array>
+#include <chrono>
 #include <cmath>
 #include <filesystem>
 #include <fstream>
@@ -36,7 +38,10 @@
 #include <utility>
 #include <variant>
 #include <vector>
-#include <unistd.h>
+
+#include <nlohmann/json.hpp>
+
+using Json = nlohmann::json;
 
 using Value =
     std::variant<bool, uint8_t, int16_t, uint16_t, int32_t, uint32_t, int64_t,
@@ -48,23 +53,23 @@ using GetSubTreeType = std::vector<
 
 using PropertyMap = std::map<std::string, Value>;
 
+using pathsOfServiceAndObject = std::pair<std::string, std::string>;
 
+static const std::string DBUS_OBJPATH_SUBYSTEM_HEALTH_CHECK =
+    "/xyz/openbmc_project/sensors/discrete_6fh/management_subsystem_health/"
+    "Subsystem_health";
 
-static const std::string DBUS_OBJPATH_SUBYSTEM_HEALTH_CHECK = 
-                        "/xyz/openbmc_project/sensors/discrete_6fh/management_subsystem_health/Subsystem_health";
+static const std::string DBUS_OBJPATH_INTEL_ME_HEALTH_CHECK =
+    "/xyz/openbmc_project/sensors/discrete_6fh/oem_d4h/IntelMEHealth";
 
+static const std::string DBUS_OBJPATH_PSU_STATE_CHECK =
+    "/xyz/openbmc_project/sensors/discrete_6fh/power_supply/PSUStateCheck";
 
-static const std::string DBUS_OBJPATH_INTEL_ME_HEALTH_CHECK = 
-                        "/xyz/openbmc_project/sensors/discrete_6fh/me_health_event/IntelMEHealth";
-
-
-static const std::string DBUS_OBJPATH_PSU_STATE_CHECK = 
-                        "/xyz/openbmc_project/sensors/discrete_6fh/power_supply/PSUStateCheck";
-
-
-static const std::string DBUS_OBJPATH_BMC_HEALTH_CHECK = 
-                        "/xyz/openbmc_project/sensors/oem_event_70h/oem_e0h/BMC_health";
+static const std::string DBUS_OBJPATH_BMC_HEALTH_CHECK =
+    "/xyz/openbmc_project/sensors/oem_event_70h/oem_e0h/BMC_health";
 
+static const std::string DBUS_OBJPATH_SYSTEM_RECONFIGURE =
+    "/xyz/openbmc_project/sensors/discrete_6fh/system_event/SystemReconfigure";
 
 static const int MAX_SLEEP_TIME = 5;
 static const int FULL_DATA = 0xFF;
@@ -89,8 +94,10 @@ constexpr std::chrono::microseconds DBUS_TIMEOUT(10000);
 
 static const bool SEL_ASSERTED = true;
 static const bool SEL_DEASSERTED = false;
-static const uint8_t BMC_HEALTH_MASK_EMPTY_INVALID_FRU = static_cast<uint8_t>(0xA4);
-static const uint8_t BMC_HEALTH_MASK_NO_MACADDRESS_PROGRAMMED = static_cast<uint8_t>(0xAC);
+static const uint8_t BMC_HEALTH_MASK_EMPTY_INVALID_FRU =
+    static_cast<uint8_t>(0xA4);
+static const uint8_t BMC_HEALTH_MASK_NO_MACADDRESS_PROGRAMMED =
+    static_cast<uint8_t>(0xAC);
 
 
 #if 0
@@ -107,13 +114,11 @@ static void dbg_payload(std::vector<uint8_t>& data, const char* prompt)
 }
 #endif
 
-void do_SystemEventRecordSEL(
-            std::shared_ptr<sdbusplus::asio::connection> conn,
-            const std::string& eventObjPath, 
-            const std::vector<uint8_t>& eventData, 
-            const std::string& logMessage, 
-            const bool assert, 
-            const uint8_t genID)
+void do_SystemEventRecordSEL(std::shared_ptr<sdbusplus::asio::connection> conn,
+                             const std::string& eventObjPath,
+                             const std::vector<uint8_t>& eventData,
+                             const std::string& logMessage, const bool assert,
+                             const uint8_t genID)
 {
     const static constexpr char* service = "xyz.openbmc_project.Logging.IPMI";
     const static constexpr char* interface = "xyz.openbmc_project.Logging.IPMI";
@@ -136,83 +141,85 @@ void do_SystemEventRecordSEL(
     }
 }
 
-
-void static check_IntelME_sensor_status(std::shared_ptr<sdbusplus::asio::connection> bus)
+void static check_IntelME_sensor_status(
+    std::shared_ptr<sdbusplus::asio::connection> bus)
 {
 
     fprintf(stderr, "%s \n", __func__);
     uint8_t lun = 0;
     uint8_t netfn = 0x06;
-    uint8_t cmd = 0x34; //Send Message
-    std::vector<uint8_t> cmdData = {0x46, 0x2c, 0x18, 0xbc, 0x20, 0x04, 0x01, 0xdb};
+    uint8_t cmd = 0x34; // Send Message
+    std::vector<uint8_t> cmdData = {0x46, 0x2c, 0x18, 0xbc,
+                                    0x20, 0x04, 0x01, 0xdb};
     auto retConvey = std::make_shared<DbusRspData>();
     std::vector<uint8_t> eventData = {0x82, 0x00, 0x00};
 
-    if(CMD_OPTION_TEST_MODE){
+    if (CMD_OPTION_TEST_MODE)
+    {
         cmdData.at(6) = 0xFF;
         cmdData.at(7) = 0xFF;
     }
 
-    //Using IPMI SendMessage (0x06, 0x34)to test INTEL ME through IPMB driver
+    // Using IPMI SendMessage (0x06, 0x34)to test INTEL ME through IPMB driver
     ipmi_method_call(lun, netfn, cmd, cmdData, retConvey);
-    
-    if(retConvey->retData[RESP_INDEX_COMPLETE_CODE] == 0x00){
+
+    if (retConvey->retData[RESP_INDEX_COMPLETE_CODE] == 0x00)
+    {
         // Check if data return
         if (retConvey->retData.size() <= 1)
         {
             // only complete code return, treat as error
-            do_SystemEventRecordSEL(
-                    bus,
-                    DBUS_OBJPATH_INTEL_ME_HEALTH_CHECK,
-                    eventData,
-                    std::string("Check Intel ME health event"), 
-                    true,
-                    static_cast<uint8_t>(0x20));
+            do_SystemEventRecordSEL(bus, DBUS_OBJPATH_INTEL_ME_HEALTH_CHECK,
+                                    eventData,
+                                    std::string("Check Intel ME health event"),
+                                    true, static_cast<uint8_t>(0x20));
             fprintf(stderr, "do SEL for Intel ME health check\n");
         }
-    }else{
-        do_SystemEventRecordSEL(
-                    bus,
-                    DBUS_OBJPATH_INTEL_ME_HEALTH_CHECK,
-                    eventData,
-                    std::string("Check Intel ME health event"), 
-                    true,
-                    static_cast<uint8_t>(0x20));
-        
-        fprintf(stderr, "do SEL for Intel ME health check\n");
+    }
+    else
+    {
+        do_SystemEventRecordSEL(bus, DBUS_OBJPATH_INTEL_ME_HEALTH_CHECK,
+                                eventData,
+                                std::string("Check Intel ME health event"),
+                                true, static_cast<uint8_t>(0x20));
 
+        fprintf(stderr, "do SEL for Intel ME health check\n");
     }
 }
 
-PropertyMap getAllDbusProperties(sdbusplus::bus::bus& bus,
-                                 const std::string& service,
-                                 const std::string& objPath,
-                                 const std::string& interface,
-                                 std::chrono::microseconds timeout = DBUS_TIMEOUT)
+PropertyMap
+    getAllDbusProperties(sdbusplus::bus::bus& bus, const std::string& service,
+                         const std::string& objPath,
+                         const std::string& interface,
+                         std::chrono::microseconds timeout = DBUS_TIMEOUT)
 {
     PropertyMap properties;
 
-    auto method = bus.new_method_call(service.c_str(), objPath.c_str(),
-                                      "org.freedesktop.DBus.Properties", "GetAll");
+    auto method =
+        bus.new_method_call(service.c_str(), objPath.c_str(),
+                            "org.freedesktop.DBus.Properties", "GetAll");
 
     method.append(interface);
 
     auto reply = bus.call(method, timeout.count());
 
     if (reply.is_method_error())
-    {  
+    {
         fprintf(stderr, "%s:%d error of service=%s, objPath=%s interface=%s\n",
-                __func__, __LINE__, service.c_str(), objPath.c_str(), interface.c_str());
+                __func__, __LINE__, service.c_str(), objPath.c_str(),
+                interface.c_str());
     }
 
     reply.read(properties);
     return properties;
 }
 
-static Value getDbusProperty(sdbusplus::bus::bus& bus, const std::string& service,
-                      const std::string& objPath, const std::string& interface,
-                      const std::string& property,
-                      std::chrono::microseconds timeout = DBUS_TIMEOUT)
+static Value getDbusProperty(sdbusplus::bus::bus& bus,
+                             const std::string& service,
+                             const std::string& objPath,
+                             const std::string& interface,
+                             const std::string& property,
+                             std::chrono::microseconds timeout = DBUS_TIMEOUT)
 {
 
     Value value;
@@ -226,45 +233,49 @@ static Value getDbusProperty(sdbusplus::bus::bus& bus, const std::string& servic
 
     if (reply.is_method_error())
     {
-        fprintf(stderr, "%s:%d error of service=%s, objPath=%s interface=%s property=%s\n",
-                __func__, __LINE__, service.c_str(), objPath.c_str(), interface.c_str(), property.c_str());
+        fprintf(
+            stderr,
+            "%s:%d error of service=%s, objPath=%s interface=%s property=%s\n",
+            __func__, __LINE__, service.c_str(), objPath.c_str(),
+            interface.c_str(), property.c_str());
     }
 
-
     reply.read(value);
 
     return value;
 }
 
-void static check_FRU_devices_status(std::shared_ptr<sdbusplus::asio::connection> bus)
-{   
-    using pathsOfServiceAndObject = std::pair<std::string, std::string>;
+void static check_FRU_devices_status(
+    std::shared_ptr<sdbusplus::asio::connection> bus)
+{
     std::vector<pathsOfServiceAndObject> serviceAndObjectList;
-    
+
     GetSubTreeType resp;
 
-    //If no FRU dbus object is found it is empty/invalid error
-    std::map<std::string, std::vector<std::string>> interfacesResponse;
+    // If no FRU dbus object is found it is empty/invalid error
     std::vector<std::string> interfaces = {"xyz.openbmc_project.FruDevice"};
-    auto method = bus->new_method_call(
-        "xyz.openbmc_project.ObjectMapper",
-        "/xyz/openbmc_project/object_mapper",
-        "xyz.openbmc_project.ObjectMapper", "GetSubTree");
+    auto method =
+        bus->new_method_call("xyz.openbmc_project.ObjectMapper",
+                             "/xyz/openbmc_project/object_mapper",
+                             "xyz.openbmc_project.ObjectMapper", "GetSubTree");
 
     method.append("/", 0, interfaces);
-    try{
+    try
+    {
         auto reply = bus->call(method);
         reply.read(resp);
-    }catch(const sdbusplus::exception_t& e){
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
         fprintf(stderr, "%s:%d exception:%s \n", __func__, __LINE__, e.what());
         return;
     }
 
-    for(auto p1 : resp)
+    for (auto p1 : resp)
     {
         auto objPath = p1.first;
         auto vect1 = p1.second;
-        for(auto p2 : vect1)
+        for (auto p2 : vect1)
         {
             auto service = p2.first;
             pathsOfServiceAndObject val = {service, objPath};
@@ -272,17 +283,22 @@ void static check_FRU_devices_status(std::shared_ptr<sdbusplus::asio::connection
         }
     }
 
-    for(auto p : serviceAndObjectList)
+    for (auto p : serviceAndObjectList)
     {
-        //Check if the bus/address of the FRU is working by trying opening the mapped file in /sys/bus/i2c/devices
-        auto busProperty = getDbusProperty(*bus, p.first, p.second, "xyz.openbmc_project.FruDevice", "BUS");
-        auto addressProperty = getDbusProperty(*bus, p.first, p.second, "xyz.openbmc_project.FruDevice", "ADDRESS");
-	    std::stringstream output;
-	    output << "/sys/bus/i2c/devices/" << std::get<uint32_t>(busProperty) << "-" << std::right
-		   << std::setfill('0') << std::setw(4) << std::hex << std::get<uint32_t>(addressProperty)
-		   << "/eeprom";
+        // Check if the bus/address of the FRU is working by trying opening the
+        // mapped file in /sys/bus/i2c/devices
+        auto busProperty = getDbusProperty(
+            *bus, p.first, p.second, "xyz.openbmc_project.FruDevice", "BUS");
+        auto addressProperty =
+            getDbusProperty(*bus, p.first, p.second,
+                            "xyz.openbmc_project.FruDevice", "ADDRESS");
+        std::stringstream output;
+        output << "/sys/bus/i2c/devices/" << std::get<uint32_t>(busProperty)
+               << "-" << std::right << std::setfill('0') << std::setw(4)
+               << std::hex << std::get<uint32_t>(addressProperty) << "/eeprom";
         std::cerr << "try opening " << output.str() << std::endl;
-        std::ifstream file(output.str(), std::ios::in | std::ios::binary | std::ios::ate);
+        std::ifstream file(output.str(),
+                           std::ios::in | std::ios::binary | std::ios::ate);
         if (file.is_open() == false)
         {
             std::cerr << "Unable to oepn file " << output.str() << std::endl;
@@ -301,23 +317,25 @@ void static check_FRU_devices_status(std::shared_ptr<sdbusplus::asio::connection
             file.close();
         }
 
-        //checking if the data in the properties is empty
-        
-        PropertyMap properties = getAllDbusProperties(*bus, p.first, p.second, "xyz.openbmc_project.FruDevice");
+        // checking if the data in the properties is empty
+
+        PropertyMap properties = getAllDbusProperties(
+            *bus, p.first, p.second, "xyz.openbmc_project.FruDevice");
         size_t zeroLengthCount = 0;
-        for(auto map : properties)
+        for (auto map : properties)
         {
             try
             {
                 // only get the std::string.
                 std::string value = std::get<std::string>(map.second);
-                if(value.length()==0) zeroLengthCount++;
+                if (value.length() == 0)
+                    zeroLengthCount++;
             }
             catch (std::exception& e)
             {}
         }
-        //ignore ADDRESS / BUS properties
-        if(zeroLengthCount >= (properties.size()-2) )
+        // ignore ADDRESS / BUS properties
+        if (zeroLengthCount >= (properties.size() - 2))
         {
             std::vector<uint8_t> eventData = {0xFF, 0xFF, 0xFF};
             eventData.at(0) = BMC_HEALTH_MASK_EMPTY_INVALID_FRU;
@@ -328,19 +346,15 @@ void static check_FRU_devices_status(std::shared_ptr<sdbusplus::asio::connection
                                     true, static_cast<uint8_t>(0x20));
         }
     }
-    
-
 }
 
-
-
-void static check_PSU_sensor_status(std::shared_ptr<sdbusplus::asio::connection> bus)
+void static check_PSU_sensor_status(
+    std::shared_ptr<sdbusplus::asio::connection> bus)
 {
-
     fprintf(stderr, "%s \n", __func__);
     uint8_t lun = 0;
     uint8_t netfn = 0x0a;
-    uint8_t cmd = 0x23; //Get SDR command
+    uint8_t cmd = 0x23; // Get SDR command
     std::vector<uint8_t> cmdData;
     auto retConvey = std::make_shared<DbusRspData>();
     std::vector<uint8_t> eventData = {0x00, 0x00, 0x00};
@@ -351,18 +365,17 @@ void static check_PSU_sensor_status(std::shared_ptr<sdbusplus::asio::connection>
     cmdData.at(CMD_INDEX_RECORD_ID_MSB) = 0x00;
     cmdData.at(CMD_INDEX_DATA_LENGTH) = FULL_DATA; // all the data
 
-    for(int i=0; i<255; i++)
+    for (int i = 0; i < 255; i++)
     {
         // Get SDR record of specified record id
         ipmi_method_call(lun, netfn, cmd, cmdData, retConvey);
-        if(retConvey->retData.at(RESP_INDEX_COMPLETE_CODE) == 0x00
-            && retConvey->retData.at(RESP_INDEX_RECORD_TYPE) == 0x01
-         )
+        if (retConvey->retData.at(RESP_INDEX_COMPLETE_CODE) == 0x00 &&
+            retConvey->retData.at(RESP_INDEX_RECORD_TYPE) == 0x01)
         {
-            std::string sensorId(retConvey->retData.begin()+51, retConvey->retData.end());
-            
-            
-            if((sensorId.find("PSU") != std::string::npos))
+            std::string sensorId(retConvey->retData.begin() + 51,
+                                 retConvey->retData.end());
+
+            if ((sensorId.find("PSU") != std::string::npos))
             {
                 // using IPMI GET SENSOR EVENT STATUS (netfn=0x04, cmd=0x2b with
                 // sensor number to get sensor event status
@@ -375,9 +388,11 @@ void static check_PSU_sensor_status(std::shared_ptr<sdbusplus::asio::connection>
                     RESP_INDEX_SENSOR_NUMBER); // set SensorNumber;
 
                 ipmi_method_call(lun2, netfn2, cmd2, cmdData2, retConvey2);
-
                 if (retConvey2->retData.at(RESP_INDEX_COMPLETE_CODE) == 0x00)
                 {
+                    fprintf(stderr, "PSU status check sensorId=%s \n", sensorId.c_str());
+                    fprintf(stderr, "status threshold value=%d \n",
+                            retConvey2->retData.at(RESP_INDEX_EVENT_STATUS_THRESHOLD_BASED_2));
                     if (retConvey2->retData.at(
                             RESP_INDEX_EVENT_STATUS_THRESHOLD_BASED_2) != 0x00)
                     {
@@ -419,29 +434,33 @@ void static check_PSU_sensor_status(std::shared_ptr<sdbusplus::asio::connection>
                     }
                 }
             }
-        }else if(retConvey->ec.value() != 0x00){
-            fprintf(stderr, "index %02X is failed ec=%d\n", i, retConvey->ec.value());
         }
-
-        
+        else if (retConvey->ec.value() != 0x00)
+        {
+            fprintf(stderr, "index %02X is failed ec=%d\n", i,
+                    retConvey->ec.value());
+        }
 
         // At the end, get all SDR records done.
-        if( (retConvey->retData[RESP_INDEX_NEXT_RECORD_ID_LSB]==0xFF) && 
-                (retConvey->retData[RESP_INDEX_NEXT_RECORD_ID_MSB]==0xFF)) {
+        if ((retConvey->retData[RESP_INDEX_NEXT_RECORD_ID_LSB] == 0xFF) &&
+            (retConvey->retData[RESP_INDEX_NEXT_RECORD_ID_MSB] == 0xFF))
+        {
             break;
-        }else{
-            //setup cmdData to get next SDR record
-            cmdData.at(CMD_INDEX_RECORD_ID_LSB) = retConvey->retData.at(RESP_INDEX_NEXT_RECORD_ID_LSB);
-            cmdData.at(CMD_INDEX_RECORD_ID_MSB) = retConvey->retData.at(RESP_INDEX_NEXT_RECORD_ID_MSB);
-            cmdData.at(CMD_INDEX_DATA_LENGTH) = FULL_DATA; //all the data
         }
-
+        else
+        {
+            // setup cmdData to get next SDR record
+            cmdData.at(CMD_INDEX_RECORD_ID_LSB) =
+                retConvey->retData.at(RESP_INDEX_NEXT_RECORD_ID_LSB);
+            cmdData.at(CMD_INDEX_RECORD_ID_MSB) =
+                retConvey->retData.at(RESP_INDEX_NEXT_RECORD_ID_MSB);
+            cmdData.at(CMD_INDEX_DATA_LENGTH) = FULL_DATA; // all the data
+        }
     }
 }
 
-
-
-void static check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::connection> bus)
+void static check_subsystem_sensor_status(
+    std::shared_ptr<sdbusplus::asio::connection> bus)
 {
     fprintf(stderr, "%s \n", __func__);
     uint8_t lun = 0;
@@ -450,10 +469,10 @@ void static check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::conne
     std::vector<uint8_t> cmdData;
     auto retConvey = std::make_shared<DbusRspData>();
 
-    //if not in TEST MODE check
-    //if the motherboard is power on, 
-    //if host power on, then check the subsystem health
-    if(CMD_OPTION_TEST_MODE == 0)
+    // if not in TEST MODE check
+    // if the motherboard is power on,
+    // if host power on, then check the subsystem health
+    if (CMD_OPTION_TEST_MODE == 0)
     {
         netfn = 0x00; // Chassis
         cmd = 0x01;   // get chassis status
@@ -478,63 +497,547 @@ void static check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::conne
         }
     }
 
-    netfn = 0x0a; //S/E (sensor and event)
-    cmd = 0x23; //GET SDR
+    netfn = 0x0a; // S/E (sensor and event)
+    cmd = 0x23;   // GET SDR
     cmdData.resize(6, 0);
 
     cmdData.at(CMD_INDEX_RECORD_ID_LSB) = 0x00;
     cmdData.at(CMD_INDEX_RECORD_ID_MSB) = 0x00;
     cmdData.at(CMD_INDEX_DATA_LENGTH) = FULL_DATA; // all the data
 
-    for(int i=0; i<255; i++){
-        //Get SDR record of specified record id
+    for (int i = 0; i < 255; i++)
+    {
+        // Get SDR record of specified record id
         ipmi_method_call(lun, netfn, cmd, cmdData, retConvey);
-        
-        if(retConvey->retData.at(RESP_INDEX_COMPLETE_CODE) == 0x00
-            && retConvey->retData.at(RESP_INDEX_RECORD_TYPE) == 0x01)
+
+        if (retConvey->retData.at(RESP_INDEX_COMPLETE_CODE) == 0x00 &&
+            retConvey->retData.at(RESP_INDEX_RECORD_TYPE) == 0x01)
         {
-            // using IPMI GET SENSOR DATA READING (netfn=0x04, cmd=0x2d with sensor number to get reading status)
+            // using IPMI GET SENSOR DATA READING (netfn=0x04, cmd=0x2d with
+            // sensor number to get reading status)
             uint8_t lun2 = 0;
             uint8_t netfn2 = 0x04;
             uint8_t cmd2 = 0x2d;
-            std::vector<uint8_t> cmdData2(1);    
+            std::vector<uint8_t> cmdData2(1);
             auto retConvey2 = std::make_shared<DbusRspData>();
-            cmdData2.at(CMD_INDEX_SENSOR_NUMBER) = retConvey->retData.at(RESP_INDEX_SENSOR_NUMBER); //set SensorNumber;
+            cmdData2.at(CMD_INDEX_SENSOR_NUMBER) = retConvey->retData.at(
+                RESP_INDEX_SENSOR_NUMBER); // set SensorNumber;
 
             ipmi_method_call(lun2, netfn2, cmd2, cmdData2, retConvey2);
-            
-            if(retConvey2->retData.at(RESP_INDEX_COMPLETE_CODE) == 0x00){
-                if(retConvey2->retData.at(RESP_INDEX_READING_STATUS) & 0x20){
-                    //unavailable, do SEL MS M-BMC-LOG-007
-                    std::string sensorId(retConvey->retData.begin()+51, retConvey->retData.end());
-                    fprintf(stderr, "%s do SEL MS M-BMC-LOG-007 \n", sensorId.c_str());
-                    std::vector<uint8_t> eventData = {0xC0, retConvey->retData.at(RESP_INDEX_SENSOR_NUMBER), 0xFF};
+
+            if (retConvey2->retData.at(RESP_INDEX_COMPLETE_CODE) == 0x00)
+            {
+                if (retConvey2->retData.at(RESP_INDEX_READING_STATUS) & 0x20)
+                {
+                    // unavailable, do SEL MS M-BMC-LOG-007
+                    std::string sensorId(retConvey->retData.begin() + 51,
+                                         retConvey->retData.end());
+                    fprintf(stderr, "%s do SEL MS M-BMC-LOG-007 \n",
+                            sensorId.c_str());
+                    std::vector<uint8_t> eventData = {
+                        0xC0, retConvey->retData.at(RESP_INDEX_SENSOR_NUMBER),
+                        0xFF};
                     do_SystemEventRecordSEL(
-                        bus,
-                        DBUS_OBJPATH_SUBYSTEM_HEALTH_CHECK,
-                        eventData,
-                        std::string("Check Management Subsystem health event"), 
-                        true,
-                        static_cast<uint8_t>(0x20)
-                    );
+                        bus, DBUS_OBJPATH_SUBYSTEM_HEALTH_CHECK, eventData,
+                        std::string("Check Management Subsystem health event"),
+                        true, static_cast<uint8_t>(0x20));
                 }
             }
-
-        }else if(retConvey->ec.value() != 0x00){
-            fprintf(stderr, "index %02X is failed ec=%d\n", i, retConvey->ec.value());
+        }
+        else if (retConvey->ec.value() != 0x00)
+        {
+            fprintf(stderr, "index %02X is failed ec=%d\n", i,
+                    retConvey->ec.value());
         }
 
         // At the end, get all SDR records done.
-        if( (retConvey->retData[RESP_INDEX_NEXT_RECORD_ID_LSB]==0xFF) && 
-                (retConvey->retData[RESP_INDEX_NEXT_RECORD_ID_MSB]==0xFF)) {
+        if ((retConvey->retData[RESP_INDEX_NEXT_RECORD_ID_LSB] == 0xFF) &&
+            (retConvey->retData[RESP_INDEX_NEXT_RECORD_ID_MSB] == 0xFF))
+        {
             break;
+        }
+        else
+        {
+            // setup cmdData to get next SDR record
+            cmdData.at(CMD_INDEX_RECORD_ID_LSB) =
+                retConvey->retData.at(RESP_INDEX_NEXT_RECORD_ID_LSB);
+            cmdData.at(CMD_INDEX_RECORD_ID_MSB) =
+                retConvey->retData.at(RESP_INDEX_NEXT_RECORD_ID_MSB);
+            cmdData.at(CMD_INDEX_DATA_LENGTH) = FULL_DATA; // all the data
+        }
+    }
+}
+
+static const std::string SLOTTYPE_PCIE = "pcie";
+static const std::string SLOTTYPE_CPU = "cpu";
+static const std::string SLOTTYPE_DIMM = "dimm";
+typedef struct DIMMSlot_t
+{
+    std::string slotType;
+    std::string objPath;
+    std::size_t memorySizeInKb;
+} DIMMSlot;
+
+typedef struct CPUSlot_t
+{
+    std::string slotType;
+    std::string objPath;
+    std::size_t coreCount;
+} CPUSlot;
+
+typedef struct PCIeSlot_t
+{
+    std::string slotType;
+    std::string objPath;
+    std::size_t lanes;
+} PCIESlot;
+
+static const std::string InventoryPCIEInterface =
+    "xyz.openbmc_project.Inventory.Item.PCIeSlot";
+static const std::string InventoryCPUInterface =
+    "xyz.openbmc_project.Inventory.Item.Cpu";
+static const std::string InventoryDIMMInterface =
+    "xyz.openbmc_project.Inventory.Item.Dimm";
+
+static std::optional<bool> getServiceAndObject(
+    std::shared_ptr<sdbusplus::asio::connection> bus,
+    std::vector<pathsOfServiceAndObject>& serviceAndObjectList,
+    std::string inventoryInterface)
+{
+    GetSubTreeType resp;
+    std::vector<std::string> interfaces = {inventoryInterface};
+    auto method =
+        bus->new_method_call("xyz.openbmc_project.ObjectMapper",
+                             "/xyz/openbmc_project/object_mapper",
+                             "xyz.openbmc_project.ObjectMapper", "GetSubTree");
+
+    method.append("/", 0, interfaces);
+    try
+    {
+        auto reply = bus->call(method);
+        reply.read(resp);
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        fprintf(stderr, "%s:%d exception:%s \n", __func__, __LINE__, e.what());
+        return std::nullopt;
+    }
+
+    for (auto p1 : resp)
+    {
+        auto objPath = p1.first;
+        auto vect1 = p1.second;
+        for (auto p2 : vect1)
+        {
+
+            auto service = p2.first;
+            pathsOfServiceAndObject val = {service, objPath};
+            serviceAndObjectList.push_back(val);
+        }
+    }
+    return std::make_optional<bool>(true);
+}
+
+const static constexpr char* SYSTEM_CONFIG_GODLEN_FILE =
+    "/usr/share/ipmi-providers/system_config_golden.json";
+
+bool ifNeedUpdateSystemConfigGoldenFile = false;
+
+static void
+    check_system_reconfigure(std::shared_ptr<sdbusplus::asio::connection> bus)
+{
+    fprintf(stderr, "%s\n", __func__);
+
+    std::vector<pathsOfServiceAndObject> serviceAndObjectList;
+
+    GetSubTreeType resp;
+
+    std::map<std::string, PCIESlot> pcieMap;
+    std::map<std::string, CPUSlot> cpuMap;
+    std::map<std::string, DIMMSlot> dimmMap;
+
+    // Get the subtree of the PCIE
+    getServiceAndObject(bus, serviceAndObjectList, InventoryPCIEInterface);
+    for (auto p : serviceAndObjectList)
+    {
+        auto lanes = getDbusProperty(
+            *bus, p.first, p.second, InventoryPCIEInterface, "Lanes");
+        PCIESlot slot = {   
+                            SLOTTYPE_PCIE, 
+                            p.second, 
+                            static_cast<size_t>(std::get<uint32_t>(lanes)) 
+                        };
+        pcieMap[p.second] = slot;
+    }
+    fprintf(stderr, "Smbios reports : PCIE has %d items \n", pcieMap.size());
+
+    serviceAndObjectList.clear();
+    // Get the subtree of the CPU
+    getServiceAndObject(bus, serviceAndObjectList, InventoryCPUInterface);
+    for (auto p : serviceAndObjectList)
+    {
+        auto coreCount = getDbusProperty(
+            *bus, p.first, p.second, InventoryCPUInterface, "CoreCount");
+        CPUSlot slot = {   
+                            SLOTTYPE_CPU, 
+                            p.second, 
+                            static_cast<size_t>(std::get<uint16_t>(coreCount))
+                        };
+        cpuMap[p.second] = slot;
+    }
+    fprintf(stderr, "Smbios reports : CPU %d items \n", cpuMap.size());
+
+    serviceAndObjectList.clear();
+    // Get the subtree of the DIMM
+    getServiceAndObject(bus, serviceAndObjectList, InventoryDIMMInterface);
+    for (auto p : serviceAndObjectList)
+    {
+        auto memorySize = getDbusProperty(
+            *bus, p.first, p.second, InventoryDIMMInterface, "MemorySizeInKB");
+        
+        DIMMSlot slot = {   
+                            SLOTTYPE_DIMM, 
+                            p.second, 
+                            static_cast<size_t>(std::get<uint32_t>(memorySize)) 
+                        };
+        dimmMap[p.second] = slot;
+    }
+    fprintf(stderr, "Smbios reports : DIMM has %d items \n", dimmMap.size());
+
+    //get the golden sample of system configuration by JSON
+
+    std::map<std::string, PCIESlot> gpcieMap;
+    std::map<std::string, CPUSlot> gcpuMap;
+    std::map<std::string, DIMMSlot> gdimmMap;
+
+    std::ifstream jsonfile(SYSTEM_CONFIG_GODLEN_FILE);
+    if (jsonfile.is_open())
+    {
+        auto root = nlohmann::json::parse(jsonfile, nullptr, false);
+        if (!root.is_discarded())
+        {
+            try
+            {
+                auto cpuss = root["cpu"];
+                for (auto& c : cpuss)
+                {
+                    std::stringstream ss;
+                    ss << "/xyz/openbmc_project/inventory/system/chassis/motherboard/";
+                    ss << std::string(c["name"]);
+                    CPUSlot slot = {
+                        SLOTTYPE_CPU,
+                        ss.str(),
+                        c["corecount"],
+                    };
+                    gcpuMap[ss.str()] = slot;
+                }
+
+                auto dimmss = root["dimm"];
+                for (auto& d: dimmss)
+                {
+                    std::stringstream ss;
+                    ss << "/xyz/openbmc_project/inventory/system/chassis/motherboard/";
+                    ss << std::string(d["name"]);
+                    DIMMSlot slot = {
+                        SLOTTYPE_DIMM,
+                        ss.str(),
+                        d["memorysizeinkb"],
+                    };
+                    
+                    gdimmMap[ss.str()] = slot;
+                }
+                
+                auto pciess = root["pcie"];
+                for (auto& p : pciess)
+                {
+                    std::stringstream ss;
+                    ss << "/xyz/openbmc_project/inventory/system/chassis/motherboard/";
+                    ss << std::string(p["name"]);
+                    PCIESlot slot = {
+                        SLOTTYPE_PCIE,
+                        ss.str(),
+                        p["lanes"],
+                    };
+
+                    gpcieMap[ss.str()] = slot;
+                }
+            }
+            catch (const std::exception& e)
+            {
+                fprintf(stderr, "parsing json info failed %s\n", e.what());
+            };
+        }else{
+            fprintf(stderr, " JSON is_discarded %s parsing error ?\n", root.is_discarded()? "true":"false");
+        }
+    }else{
+        fprintf(stderr, "%s can not be accessed \n", SYSTEM_CONFIG_GODLEN_FILE);
+        return;
+    }
+
+
+    //generate the SEL. 
+    //CPU diff smbiosmdr golden 
+    for(auto& map : cpuMap)
+    {
+        std::string key = map.first;
+        CPUSlot slot = map.second; 
+        std::vector<uint8_t> eventData = {0xFF, 0xFF, 0xFF};
+        //get cpu index, ex:cpu0
+        size_t pos = key.find("cpu");
+        int num;
+        uint8_t index = 0xFF;
+        if(pos != std::string::npos){
+            std::stringstream idx;
+            idx << key.substr(pos+3);
+            idx >> num;
+            index = static_cast<uint8_t>(num);
+
+        }else{
+            continue;
+        }
+
+        try
+        {   
+            CPUSlot gslot = gcpuMap.at(key);
+            if(slot.coreCount != gslot.coreCount){
+                ifNeedUpdateSystemConfigGoldenFile = true;
+                fprintf(stderr, "%s index=%d different\n",key.c_str(), index);
+                if(slot.coreCount==0 && gslot.coreCount!=0){
+                    //It is removed
+                    eventData.at(0) = 0xA0;
+                    eventData.at(1) = 0x00;
+                    eventData.at(2) = index;
+                    do_SystemEventRecordSEL(bus, DBUS_OBJPATH_SYSTEM_RECONFIGURE,
+                                            eventData,
+                                            std::string("System Reconfigure event"),
+                                            true, static_cast<uint8_t>(0x20));
+                }else if(slot.coreCount!=0 && gslot.coreCount==0){
+                    //It is added
+                    eventData.at(0) = 0xA0;
+                    eventData.at(1) = 0x01;
+                    eventData.at(2) = index;
+                    do_SystemEventRecordSEL(bus, DBUS_OBJPATH_SYSTEM_RECONFIGURE,
+                                            eventData,
+                                            std::string("System Reconfigure event"),
+                                            true, static_cast<uint8_t>(0x20));
+                }else{
+                    //It changed size, updated
+                    eventData.at(0) = 0xA0;
+                    eventData.at(1) = 0x00;
+                    eventData.at(2) = index;
+                    do_SystemEventRecordSEL(bus, DBUS_OBJPATH_SYSTEM_RECONFIGURE,
+                                            eventData,
+                                            std::string("System Reconfigure event"),
+                                            true, static_cast<uint8_t>(0x20));
+                    
+                    eventData.at(0) = 0xA0;
+                    eventData.at(1) = 0x01;
+                    eventData.at(2) = index;
+                    do_SystemEventRecordSEL(bus, DBUS_OBJPATH_SYSTEM_RECONFIGURE,
+                                            eventData,
+                                            std::string("System Reconfigure event"),
+                                            true, static_cast<uint8_t>(0x20));
+                }
+            }
+
+        }catch(std::exception& e){
+            fprintf(stderr, "Golden file lack of slot information %s exception:%s \n", key.c_str(), e.what());
+        }
+    }
+
+    //generate the SEL. 
+    //DIMM diff smbiosmdr golden 
+    for(auto& map : dimmMap)
+    {
+        std::string key = map.first;
+        DIMMSlot slot = map.second; 
+        std::vector<uint8_t> eventData = {0xFF, 0xFF, 0xFF};
+        size_t pos = key.find("dimm");
+        int num;
+        uint8_t index = 0xFF;
+        if(pos != std::string::npos){
+            std::stringstream idx;
+            idx << key.substr(pos+4);
+            idx >> num;
+            index = static_cast<uint8_t>(num);
+            index++; //start from 1          
         }else{
-            //setup cmdData to get next SDR record
-            cmdData.at(CMD_INDEX_RECORD_ID_LSB) = retConvey->retData.at(RESP_INDEX_NEXT_RECORD_ID_LSB);
-            cmdData.at(CMD_INDEX_RECORD_ID_MSB) = retConvey->retData.at(RESP_INDEX_NEXT_RECORD_ID_MSB);
-            cmdData.at(CMD_INDEX_DATA_LENGTH) = FULL_DATA; //all the data
+            continue;
         }
 
+        try
+        {   
+            DIMMSlot gslot = gdimmMap.at(key);
+            if(slot.memorySizeInKb != gslot.memorySizeInKb){
+                ifNeedUpdateSystemConfigGoldenFile = true;
+                fprintf(stderr, "%s index=%d different\n",key.c_str(), index);
+                if(slot.memorySizeInKb==0 && gslot.memorySizeInKb!=0){
+                    //It is removed
+                    eventData.at(0) = 0xA0;
+                    eventData.at(1) = 0x10;
+                    eventData.at(2) = index;
+                    do_SystemEventRecordSEL(bus, DBUS_OBJPATH_SYSTEM_RECONFIGURE,
+                                            eventData,
+                                            std::string("System Reconfigure event"),
+                                            true, static_cast<uint8_t>(0x20));
+                }else if(slot.memorySizeInKb!=0 && gslot.memorySizeInKb==0){
+                    //It is added
+                    eventData.at(0) = 0xA0;
+                    eventData.at(1) = 0x11;
+                    eventData.at(2) = index;
+                    do_SystemEventRecordSEL(bus, DBUS_OBJPATH_SYSTEM_RECONFIGURE,
+                                            eventData,
+                                            std::string("System Reconfigure event"),
+                                            true, static_cast<uint8_t>(0x20));
+                }else{
+                    //It is changed size, updated
+                    eventData.at(0) = 0xA0;
+                    eventData.at(1) = 0x10;
+                    eventData.at(2) = index;
+                    do_SystemEventRecordSEL(bus, DBUS_OBJPATH_SYSTEM_RECONFIGURE,
+                                            eventData,
+                                            std::string("System Reconfigure event"),
+                                            true, static_cast<uint8_t>(0x20));
+                    
+                    eventData.at(0) = 0xA0;
+                    eventData.at(1) = 0x11;
+                    eventData.at(2) = index;
+                    do_SystemEventRecordSEL(bus, DBUS_OBJPATH_SYSTEM_RECONFIGURE,
+                                            eventData,
+                                            std::string("System Reconfigure event"),
+                                            true, static_cast<uint8_t>(0x20));
+                }
+            }
+
+        }catch(std::exception& e){
+            fprintf(stderr, "Golden file lack of slot information %s \n", key.c_str());
+        }
+    }
+
+
+    //generate the SEL. 
+    //PCIE diff smbiosmdr golden 
+    for(auto& map : pcieMap)
+    {
+        std::string key = map.first;
+        PCIESlot slot = map.second; 
+        std::vector<uint8_t> eventData = {0xFF, 0xFF, 0xFF};
+        size_t pos = key.find("pcieslot");
+        int num;
+        uint8_t index = 0xFF;
+        if(pos != std::string::npos){
+            std::stringstream idx;
+            idx << key.substr(pos+8);
+            idx >> num;
+            index = static_cast<uint8_t>(num);
+            index++; //start from 1          
+        }else{
+            continue;
+        }
+
+        try
+        {   
+            PCIESlot gslot = gpcieMap.at(key);
+            if(slot.lanes != gslot.lanes){
+                ifNeedUpdateSystemConfigGoldenFile = true;
+                fprintf(stderr, "%s index=%d different\n",key.c_str(), index);
+                if(slot.lanes==0 && gslot.lanes!=0){
+                    //It is removed
+                    eventData.at(0) = 0xA0;
+                    eventData.at(1) = 0x20;
+                    eventData.at(2) = index;
+                    do_SystemEventRecordSEL(bus, DBUS_OBJPATH_SYSTEM_RECONFIGURE,
+                                            eventData,
+                                            std::string("System Reconfigure event"),
+                                            true, static_cast<uint8_t>(0x20));
+                }else if(slot.lanes!=0 && gslot.lanes==0){
+                    //It is added
+                    eventData.at(0) = 0xA0;
+                    eventData.at(1) = 0x21;
+                    eventData.at(2) = index;
+                    do_SystemEventRecordSEL(bus, DBUS_OBJPATH_SYSTEM_RECONFIGURE,
+                                            eventData,
+                                            std::string("System Reconfigure event"),
+                                            true, static_cast<uint8_t>(0x20));
+                }else{
+                    //It is changed size, updated
+                    eventData.at(0) = 0xA0;
+                    eventData.at(1) = 0x20;
+                    eventData.at(2) = index;
+                    do_SystemEventRecordSEL(bus, DBUS_OBJPATH_SYSTEM_RECONFIGURE,
+                                            eventData,
+                                            std::string("System Reconfigure event"),
+                                            true, static_cast<uint8_t>(0x20));
+                    
+                    eventData.at(0) = 0xA0;
+                    eventData.at(1) = 0x21;
+                    eventData.at(2) = index;
+                    do_SystemEventRecordSEL(bus, DBUS_OBJPATH_SYSTEM_RECONFIGURE,
+                                            eventData,
+                                            std::string("System Reconfigure event"),
+                                            true, static_cast<uint8_t>(0x20));
+                }
+            }
+
+        }catch(std::exception& e){
+            fprintf(stderr, "Golden file lack of slot information %s \n", key.c_str());
+        }
+    }
+
+    if(ifNeedUpdateSystemConfigGoldenFile){
+        try{
+            Json root;
+
+            Json cpuList = Json::array();
+            for(auto& map : cpuMap){
+                std::string key = map.first;
+                CPUSlot slot = map.second; 
+                auto name = key.substr(key.find("cpu"));
+                Json obj;
+                obj["name"] = name;
+                obj["corecount"] = slot.coreCount;
+                cpuList.push_back(obj);
+            }
+
+
+            Json dimmList = Json::array();
+            for(auto& map : dimmMap){
+                std::string key = map.first;
+                DIMMSlot slot = map.second; 
+                auto name = key.substr(key.find("dimm"));
+                Json obj;
+                obj["name"] = name;
+                obj["memorysizeinkb"] = slot.memorySizeInKb;
+                dimmList.push_back(obj);
+            }
+
+
+            Json pcieList = Json::array();
+            for(auto& map : pcieMap){
+                std::string key = map.first;
+                PCIESlot slot = map.second; 
+                auto name = key.substr(key.find("pcieslot"));
+                Json obj;
+                obj["name"] = name;
+                obj["lanes"] = slot.lanes;
+                pcieList.push_back(obj);
+            }
+
+            root["cpu"] = cpuList;
+            root["dimm"] = dimmList;
+            root["pcie"] = pcieList;
+
+            std::ofstream gfile;
+            gfile.open(SYSTEM_CONFIG_GODLEN_FILE, std::ofstream::trunc);
+            gfile << root.dump(4);
+            gfile.close();
+
+
+        }catch(std::exception& e){
+            fprintf(stderr, "%s update system config file error %s \n", __func__, e.what());
+        }
+
+
     }
 }
 
@@ -552,7 +1055,8 @@ int main(int argc, char** argv)
             }
             break;
 
-            default:{
+            default:
+            {
                 std::cout << argv[0] << " -t";
             }
         }
@@ -561,14 +1065,39 @@ int main(int argc, char** argv)
     boost::asio::io_service io;
     auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
 
-    //Checking FRU device after service start up only update
-    check_FRU_devices_status(systemBus);
-
-    while(true)
+    while (true)
     {
-        check_subsystem_sensor_status(systemBus);
-        check_IntelME_sensor_status(systemBus);
-        check_PSU_sensor_status(systemBus);
+
+        try{
+            check_FRU_devices_status(systemBus);
+        }catch(std::exception& e){
+            fprintf(stderr, "%s:%d exception%s \n", __FILE__, __LINE__, e.what());
+        }
+
+        try{
+            check_subsystem_sensor_status(systemBus);
+        }catch(std::exception& e){
+            fprintf(stderr, "%s:%d exception%s \n", __FILE__, __LINE__, e.what());
+        }
+
+        try{
+            check_IntelME_sensor_status(systemBus);
+        }catch(std::exception& e){
+            fprintf(stderr, "%s:%d exception%s \n", __FILE__, __LINE__, e.what());
+        }
+
+        try{
+            check_PSU_sensor_status(systemBus);
+        }catch(std::exception &e){
+            fprintf(stderr, "%s:%d exception%s \n", __FILE__, __LINE__, e.what());
+        }
+
+        try{
+            check_system_reconfigure(systemBus);
+        }catch(std::exception &e){
+            fprintf(stderr, "%s:%d exception%s \n", __FILE__, __LINE__, e.what());
+        }
+
         sleep(MAX_SLEEP_TIME);
     }
     io.run();
-- 
2.33.0

