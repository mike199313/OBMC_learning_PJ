From 811e386c568db221826a19eef1b6a6aae89661fd Mon Sep 17 00:00:00 2001
From: "sun.cwsun" <sun.cwsun@inventec.com>
Date: Tue, 3 May 2022 18:07:43 +0800
Subject: [PATCH 19/27] Bug 942-[SW][Transformers][IPMI] MS M-BMC-LOG-0007 The
 BMC should generate a Management Subsystem Health SEL record

if sensor access is degraded or the sensor is not detected.

    Symptom/Reason :
		- The BMC should generate a Management Subsystem Health SEL record if sensor access 0007 is degraded or the sensor is not detected.

    Root Cause:
        - None

    Solution/Change:
        [dbus-sensor]
            - Iplement the Subsystem health management event sensor
		[intel-ipmi-oem]
			- Add more sensor type definition
		[entity-manager]
			- Add event sensor for MS SEL spec

    Entry Test:

sysadmin@transformers:~# ipmitool sdr elist

PCH_Temp         | 2Ch | ns  |  3.28 | No Reading
System_Airflow   | 48h | ns  | 29.24 | No Reading
NMI_SW           | 56h | ok  |  3.0 |
INTRUDER         | 57h | ok  |  3.0 |
MEM_CONTROLLER_P | 5Bh | ok  |  3.0 |
THERMAL_U8       | 67h | ok  |  7.0 | 27 degrees C
THERMAL_U6       | 68h | ok  |  7.0 | 41 degrees C
Inlet_BRD_Temp   | 69h | ns  |  7.7 | No Reading
Exit_Air_Temp    | 6Ah | ns  |  7.8 | No Reading

sysadmin@transformers:~# systemctl stop xyz.op^C
sysadmin@transformers:~# cd /lib/systemd/system
sysadmin@transformers:/lib/systemd/system# systemctl stop xyz.openbmc_project.ms_subsystem_check.service
sysadmin@transformers:/lib/systemd/system# /usr/bin/ms_subsystem_check 0
check_subsystem_sensor_status
CHECKING_HOST_POWER_ON=0
PCH_Temp do SEL MS M-BMC-LOG-007
System_Airflow do SEL MS M-BMC-LOG-007
Inlet_BRD_Temp do SEL MS M-BMC-LOG-007
Exit_Air_Temp do SEL MS M-BMC-LOG-007

sysadmin@transformers:/lib/systemd/system# ipmitool sel elist
 4e4 | 05/03/22 | 10:00:48 UTC | Management Subsys Health Subsystem_health | Sensor access degraded or unavailable | Asserted
 4e5 | 05/03/22 | 10:00:48 UTC | Management Subsys Health Subsystem_health | Sensor access degraded or unavailable | Asserted
 4e6 | 05/03/22 | 10:00:48 UTC | Management Subsys Health Subsystem_health | Sensor access degraded or unavailable | Asserted
 4e7 | 05/03/22 | 10:00:48 UTC | Management Subsys Health Subsystem_health | Sensor access degraded or unavailable | Asserted

sysadmin@transformers:/lib/systemd/system#
sysadmin@transformers:/lib/systemd/system# ipmitool sel get 0x4e4
SEL Record ID          : 04e4
 Record Type           : 02
 Timestamp             : 10:00:48 UTC 10:00:48 UTC
 Generator ID          : 0020
 EvM Revision          : 04
 Sensor Type           : Management Subsys Health
 Sensor Number         : b3
 Event Type            : Sensor-specific Discrete
 Event Direction       : Assertion Event
 Event Data (RAW)      : c02cff
 Event Interpretation  : Missing
 Description           : Sensor access degraded or unavailable

Sensor ID              : Subsystem_health (0xb3)
 Entity ID             : 7.0
 Sensor Type (Discrete): Management Subsys Health

sysadmin@transformers:/lib/systemd/system# ipmitool sel get 0x4e5
SEL Record ID          : 04e5
 Record Type           : 02
 Timestamp             : 10:00:48 UTC 10:00:48 UTC
 Generator ID          : 0020
 EvM Revision          : 04
 Sensor Type           : Management Subsys Health
 Sensor Number         : b3
 Event Type            : Sensor-specific Discrete
 Event Direction       : Assertion Event
 Event Data (RAW)      : c048ff
 Event Interpretation  : Missing
 Description           : Sensor access degraded or unavailable

Sensor ID              : Subsystem_health (0xb3)
 Entity ID             : 7.0
 Sensor Type (Discrete): Management Subsys Health

sysadmin@transformers:/lib/systemd/system# ipmitool sel get 0x4e6
SEL Record ID          : 04e6
 Record Type           : 02
 Timestamp             : 10:00:48 UTC 10:00:48 UTC
 Generator ID          : 0020
 EvM Revision          : 04
 Sensor Type           : Management Subsys Health
 Sensor Number         : b3
 Event Type            : Sensor-specific Discrete
 Event Direction       : Assertion Event
 Event Data (RAW)      : c069ff
 Event Interpretation  : Missing
 Description           : Sensor access degraded or unavailable

Sensor ID              : Subsystem_health (0xb3)
 Entity ID             : 7.0
 Sensor Type (Discrete): Management Subsys Health

sysadmin@transformers:/lib/systemd/system# ipmitool sel get 0x4e7
SEL Record ID          : 04e7
 Record Type           : 02
 Timestamp             : 10:00:48 UTC 10:00:48 UTC
 Generator ID          : 0020
 EvM Revision          : 04
 Sensor Type           : Management Subsys Health
 Sensor Number         : b3
 Event Type            : Sensor-specific Discrete
 Event Direction       : Assertion Event
 Event Data (RAW)      : c06aff
 Event Interpretation  : Missing
 Description           : Sensor access degraded or unavailable

Sensor ID              : Subsystem_health (0xb3)
 Entity ID             : 7.0
 Sensor Type (Discrete): Management Subsys Health
---
 include/Utils.hpp                             |  37 ++-
 meson_options.txt                             |   1 +
 service_files/meson.build                     |   1 +
 ...openbmc_project.ms_subsystem_check.service |  13 +
 src/Utils.cpp                                 |  62 +++++
 src/meson.build                               |  16 ++
 src/ms_subsystem_check.cpp                    | 226 ++++++++++++++++++
 7 files changed, 354 insertions(+), 2 deletions(-)
 create mode 100644 service_files/xyz.openbmc_project.ms_subsystem_check.service
 create mode 100644 src/ms_subsystem_check.cpp

diff --git a/include/Utils.hpp b/include/Utils.hpp
index 60f6d4f..71ba392 100644
--- a/include/Utils.hpp
+++ b/include/Utils.hpp
@@ -2,6 +2,8 @@
 #include <VariantVisitors.hpp>
 #include <boost/algorithm/string/predicate.hpp>
 #include <boost/algorithm/string/replace.hpp>
+#include <boost/asio/deadline_timer.hpp>
+#include <boost/asio/io_service.hpp>
 #include <boost/asio/steady_timer.hpp>
 #include <boost/container/flat_map.hpp>
 #include <sdbusplus/asio/connection.hpp>
@@ -20,6 +22,20 @@
 #include <variant>
 #include <vector>
 
+struct DbusRspData
+{
+    std::vector<uint8_t> retData;
+    boost::system::error_code ec;
+};
+
+// forward the request onto the main ipmi queue
+using IpmiDbusRspType =
+    std::tuple<uint8_t, uint8_t, uint8_t, uint8_t, std::vector<uint8_t>>;
+
+using IpmiDbusValueType =
+    std::variant<bool, uint8_t, int16_t, uint16_t, int32_t, uint32_t, int64_t,
+                 uint64_t, double, std::string>;
+
 const constexpr char* jsonStore = "/var/configuration/flattened.json";
 const constexpr char* inventoryPath = "/xyz/openbmc_project/inventory";
 const constexpr char* entityManagerName = "xyz.openbmc_project.EntityManager";
@@ -83,8 +99,25 @@ void findLimits(std::pair<double, double>& limits,
 void setupPowerStatHookHandlr(std::function<void(bool)> hookHandlr);
 
 
-enum class PowerState
-{
+/**
+ * @brief ipmi_method_call will using channel 8 to call the ipmi call.
+ * The channel is always 8. and privilege is fixed at 4(Admin). 
+ * The method is used as synchronize. It has its own asio service and bus object.
+ * The API will wait for IPC completed for most 5000 milliseconds otherwise expired
+ * and return
+ * 
+ * @param lun always be 0
+ * @param netfn 
+ * @param cmd 
+ * @param cmdParameter content is determined by netfn/cmd
+ * @param convey It take the return data and asio error code result
+ */
+void ipmi_method_call(uint8_t& lun, uint8_t& netfn, uint8_t& cmd,
+                      std::vector<uint8_t>& cmdParameter,
+                      std::shared_ptr<DbusRspData> convey);
+
+
+enum class PowerState {
     on,
     biosPost,
     always
diff --git a/meson_options.txt b/meson_options.txt
index 3244b5d..237f912 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -10,6 +10,7 @@ option('accumulate', type: 'feature', value: 'enabled', description: 'Enable acc
 option('iiohwmon', type: 'feature', value: 'enabled', description: 'Enable iiohwmon sensor.',)
 option('tsod', type: 'feature', value: 'enabled', description: 'Enable TSOD sensor.',)
 option('wdt', type: 'feature', value: 'enabled', description: 'Enable Watchdog event sensor.',)
+option('ms_subsystem_check', type: 'feature', value: 'enabled', description: 'Enable MS Subsystem helath check sensor',)
 option('intrusion', type: 'feature', value: 'enabled', description: 'Enable intrusion sensor.',)
 option('ipmb', type: 'feature', value: 'enabled', description: 'Enable IPMB sensor.',)
 option('mcu', type: 'feature', value: 'enabled', description: 'Enable MCU sensor.',)
diff --git a/service_files/meson.build b/service_files/meson.build
index 0fccee4..f8e5160 100644
--- a/service_files/meson.build
+++ b/service_files/meson.build
@@ -12,6 +12,7 @@ unit_files = [
     ['iiohwmon', 'xyz.openbmc_project.iiohwmonsensor.service'],
     ['tsod', 'xyz.openbmc_project.tsodsensor.service'],
     ['wdt', 'xyz.openbmc_project.wdtsensor.service'],
+    ['ms_subsystem_check', 'xyz.openbmc_project.ms_subsystem_check.service'],
     ['intrusion', 'xyz.openbmc_project.intrusionsensor.service'],
     ['mcu', 'xyz.openbmc_project.mcutempsensor.service'],
     ['nvme', 'xyz.openbmc_project.nvmesensor.service'],
diff --git a/service_files/xyz.openbmc_project.ms_subsystem_check.service b/service_files/xyz.openbmc_project.ms_subsystem_check.service
new file mode 100644
index 0000000..222b334
--- /dev/null
+++ b/service_files/xyz.openbmc_project.ms_subsystem_check.service
@@ -0,0 +1,13 @@
+[Unit]
+Description=MS Subsystem health check
+StopWhenUnneeded=false
+Requires=xyz.openbmc_project.eventsensor.service
+After=xyz.openbmc_project.eventsensor.service
+
+[Service]
+Restart=always
+RestartSec=5
+ExecStart=/usr/bin/ms_subsystem_check
+
+[Install]
+WantedBy=multi-user.target
diff --git a/src/Utils.cpp b/src/Utils.cpp
index 8d15d23..83164fa 100644
--- a/src/Utils.cpp
+++ b/src/Utils.cpp
@@ -723,3 +723,65 @@ bool getManufacturingMode()
 {
     return manufacturingMode;
 }
+
+void ipmi_method_call(uint8_t& lun, uint8_t& netfn, uint8_t& cmd,
+                      std::vector<uint8_t>& cmdParameter,
+                      std::shared_ptr<DbusRspData> convey)
+{
+    try
+    {
+
+        boost::asio::io_service io;
+        auto bus = std::make_shared<sdbusplus::asio::connection>(io);
+
+        boost::asio::deadline_timer waitTimer(io);
+        waitTimer.expires_from_now(boost::posix_time::milliseconds(5000));
+        waitTimer.async_wait([&io, convey](const boost::system::error_code& ec) {
+            fprintf(stderr, "ipmi_method_call timer expired ec=%d\n", ec.value());
+            convey->retData.push_back(0xFE);
+            convey->ec = ec;
+            io.stop();
+            fprintf(stderr, "%s:%d\n", __func__, __LINE__);
+        });
+
+        // do it as IPC, at channel 8.
+        std::map<std::string, IpmiDbusValueType> options;
+
+        bus->async_method_call(
+            [&io, &waitTimer, convey](const boost::system::error_code& ec,
+                                    const IpmiDbusRspType& response) {
+                std::vector<uint8_t> payload;
+                if (!ec)
+                {
+                    const uint8_t& cc = std::get<3>(response);
+                    const std::vector<uint8_t>& responseData =
+                        std::get<4>(response);
+                    payload.reserve(1 + responseData.size());
+                    payload.push_back(cc);
+                    payload.insert(payload.end(), responseData.begin(),
+                                responseData.end());
+                }
+                else
+                {
+                    fprintf(stderr, "ipmi_method_call ec=%d\n", ec.value());
+                    // IPMI_CC_UNSPECIFIED_ERROR
+                    payload.push_back(0xFF);
+                }
+                convey->retData = std::move(payload);
+                convey->ec = ec;
+                waitTimer.cancel();
+                io.stop();
+            },
+            "xyz.openbmc_project.Ipmi.Host", "/xyz/openbmc_project/Ipmi",
+            "xyz.openbmc_project.Ipmi.Server", "execute", netfn, lun, cmd,
+            cmdParameter, options);
+
+        io.run();
+    }
+    catch (std::exception& e)
+    {
+        fprintf(stderr, "Exception:%s \n", e.what());
+        convey->retData.clear();
+        convey->retData.push_back(0xFF);
+    }
+}
diff --git a/src/meson.build b/src/meson.build
index c25889f..cbe0cdd 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -210,6 +210,22 @@ if get_option('wdt').enabled()
     )
 endif
 
+
+if get_option('ms_subsystem_check').enabled()
+    executable(
+        'ms_subsystem_check',
+        'ms_subsystem_check.cpp',
+        dependencies: [
+            default_deps,
+            thresholds_dep,
+            utils_dep,
+        ],
+        implicit_include_directories: false,
+        include_directories: '../include',
+        install: true,
+    )
+endif
+
 if get_option('intrusion').enabled()
     executable(
         'intrusionsensor',
diff --git a/src/ms_subsystem_check.cpp b/src/ms_subsystem_check.cpp
new file mode 100644
index 0000000..913a620
--- /dev/null
+++ b/src/ms_subsystem_check.cpp
@@ -0,0 +1,226 @@
+/*
+// Copyright (c) 2019 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include <PSUEvent.hpp>
+#include <PSUSensor.hpp>
+#include <Utils.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_map.hpp>
+#include <boost/container/flat_set.hpp>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <sdbusplus/bus/match.hpp>
+
+#include <array>
+#include <cmath>
+#include <filesystem>
+#include <fstream>
+#include <functional>
+#include <iostream>
+#include <regex>
+#include <string>
+#include <string_view>
+#include <utility>
+#include <variant>
+#include <vector>
+
+static const std::string DBUS_OBJPATH_SUBYSTEM_HEALTH_CHECK = "/xyz/openbmc_project/sensors/discrete_6fh/management_subsystem_health/Subsystem_health";
+
+
+
+static const int MAX_SLEEP_TIME = 300;
+static const int FULL_DATA = 0xFF;
+
+static const int RESP_INDEX_POWER_STATUS = 1;
+static const int RESP_INDEX_RETURN_STATUS = 0;
+static const int RESP_INDEX_SENSOR_NUMBER = 10;
+static const int RESP_INDEX_RECORD_ID_LSB = 1;
+static const int RESP_INDEX_RECORD_ID_MSB = 2;
+static const int RESP_INDEX_READING_STATUS = 2;
+static const int RESP_INDEX_RECORD_TYPE = 6;
+
+static const int CMD_INDEX_RECORD_ID_LSB = 2;
+static const int CMD_INDEX_RECORD_ID_MSB = 3;
+static const int CMD_INDEX_DATA_LENGTH = 5;
+static const int CMD_INDEX_SENSOR_NUMBER = 0;
+
+int CHECKING_HOST_POWER_ON = 1;
+
+void dbg_payload(std::vector<uint8_t>& data, const char* prompt)
+{
+
+    fprintf(stderr, "%s =>", prompt);
+    for (auto v : data)
+    {
+        fprintf(stderr, "%02X,", v);
+    }
+    fprintf(stderr, "\n");
+
+}
+
+
+void do_SEL(
+            std::shared_ptr<sdbusplus::asio::connection> conn,
+            const std::string& eventObjPath, 
+            const std::vector<uint8_t>& eventData, 
+            const std::string& logMessage, 
+            const bool assert, 
+            const uint8_t genID)
+{
+    const static constexpr char* service = "xyz.openbmc_project.Logging.IPMI";
+    const static constexpr char* interface = "xyz.openbmc_project.Logging.IPMI";
+    const static constexpr char* path = "/xyz/openbmc_project/Logging/IPMI";
+    const static constexpr char* addsel = "IpmiSelAdd";
+    try
+    {
+
+        // Write SEL method
+        sdbusplus::message::message writeSEL =
+            conn->new_method_call(service, path, interface, addsel);
+        // IPMI log
+        writeSEL.append(logMessage, eventObjPath, eventData, assert,
+                        static_cast<uint16_t>(genID));
+        conn->call(writeSEL);
+    }
+    catch (std::exception& e)
+    {
+        fprintf(stderr, "exception:%s \n", e.what());
+    }
+}
+
+void check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::connection> bus)
+{
+    fprintf(stderr, "%s \n", __func__);
+    uint8_t lun = 0;
+    uint8_t netfn = 0;
+    uint8_t cmd = 0;
+    std::vector<uint8_t> cmdData;
+    auto retConvey = std::make_shared<DbusRspData>();
+
+    //If the motherboard is power on, then check the subsystem health
+    fprintf(stderr, "CHECKING_HOST_POWER_ON=%d\n", CHECKING_HOST_POWER_ON);
+    if(CHECKING_HOST_POWER_ON != 0)
+    {
+        netfn = 0x00; // Chassis
+        cmd = 0x01;   // get chassis status
+        ipmi_method_call(lun, netfn, cmd, cmdData, retConvey);
+        if ((retConvey->ec.value() == 0x00) &&
+            (retConvey->retData.at(RESP_INDEX_RETURN_STATUS) == 0x00))
+        {
+            dbg_payload(retConvey->retData, "get chassis status");
+            // if chassis status power off, do not check the subsystem health
+            if ((retConvey->retData.at(RESP_INDEX_POWER_STATUS) & 0x01) == 0x00)
+            {
+                fprintf(stderr, "Power off, not checking subsystem \n");
+                return;
+            }
+        }
+        else
+        {
+            fprintf(stderr,
+                    "Get Chassis status command error ec=%d ipmi err=%d \n",
+                    retConvey->ec.value(),
+                    retConvey->retData.at(RESP_INDEX_RETURN_STATUS));
+            return;
+        }
+    }
+
+    netfn = 0x0a; //S/E (sensor and event)
+    cmd = 0x23; //GET SDR
+    cmdData.resize(6, 0);
+
+    cmdData.at(CMD_INDEX_RECORD_ID_LSB) = 0x00;
+    cmdData.at(CMD_INDEX_RECORD_ID_MSB) = 0x00;
+    cmdData.at(CMD_INDEX_DATA_LENGTH) = FULL_DATA; // all the data
+
+    for(int i=0; i<255; i++){
+        //dbg_payload(cmdData, "cmdData");
+        //Get SDR record of specified record id
+        ipmi_method_call(lun, netfn, cmd, cmdData, retConvey);
+        //dbg_payload(retConvey->retData, "retData");
+
+        if(retConvey->retData.at(RESP_INDEX_RETURN_STATUS) == 0x00
+            && retConvey->retData.at(RESP_INDEX_RECORD_TYPE) == 0x01)
+        {
+            // using IPMI GET SENSOR DATA READING (netfn=0x04, cmd=0x2d with sensor number to get reading status)
+            uint8_t lun2 = 0;
+            uint8_t netfn2 = 0x04;
+            uint8_t cmd2 = 0x2d;
+            std::vector<uint8_t> cmdData2(1);    
+            auto retConvey2 = std::make_shared<DbusRspData>();
+            cmdData2.at(CMD_INDEX_SENSOR_NUMBER) = retConvey->retData.at(RESP_INDEX_SENSOR_NUMBER); //set SensorNumber;
+
+            //dbg_payload(cmdData2, "cmdData2");
+            ipmi_method_call(lun2, netfn2, cmd2, cmdData2, retConvey2);
+            //dbg_payload(retConvey2->retData, "retData2");
+
+            if(retConvey2->retData.at(RESP_INDEX_RETURN_STATUS) == 0x00){
+                if(retConvey2->retData.at(RESP_INDEX_READING_STATUS) & 0x20){
+                    //unavailable, do SEL MS M-BMC-LOG-007
+                    std::string sensorId(retConvey->retData.begin()+51, retConvey->retData.end());
+                    fprintf(stderr, "%s do SEL MS M-BMC-LOG-007 \n", sensorId.c_str());
+                    std::vector<uint8_t> eventData = {0xC0, retConvey->retData.at(RESP_INDEX_SENSOR_NUMBER), 0xFF};
+                    do_SEL(
+                        bus,
+                        DBUS_OBJPATH_SUBYSTEM_HEALTH_CHECK,
+                        eventData,
+                        std::string("Check Management Subsystem health event"), 
+                        true,
+                        static_cast<uint8_t>(0x20)
+                    );
+                }
+            }
+
+        }else{
+            fprintf(stderr, "index %02X is failed ec=%d\n", i, retConvey->ec.value());
+        }
+
+        
+
+        // At the end, get all SDR records done.
+        if( (retConvey->retData[RESP_INDEX_RECORD_ID_LSB]==0xFF) && 
+                (retConvey->retData[RESP_INDEX_RECORD_ID_MSB]==0xFF)) {
+            break;
+        }else{
+            //setup cmdData to get next SDR record
+            cmdData.at(CMD_INDEX_RECORD_ID_LSB) = retConvey->retData.at(RESP_INDEX_RECORD_ID_LSB);
+            cmdData.at(CMD_INDEX_RECORD_ID_MSB) = retConvey->retData.at(RESP_INDEX_RECORD_ID_MSB);
+            cmdData.at(CMD_INDEX_DATA_LENGTH) = FULL_DATA; //all the data
+        }
+
+    }
+}
+
+
+int main(int argc, char** argv)
+{
+    if(argc > 1){
+        std::stringstream ss;
+        ss << argv[1];
+        ss >> CHECKING_HOST_POWER_ON;
+    }
+
+    boost::asio::io_service io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+
+    while(true)
+    {
+        check_subsystem_sensor_status(systemBus);
+        sleep(MAX_SLEEP_TIME);
+    }
+    io.run();
+}
-- 
2.33.0

