From fa1de2a0b111351e658ebceb475cac482928e138 Mon Sep 17 00:00:00 2001
From: "sun.cwsun" <sun.cwsun@inventec.com>
Date: Tue, 10 May 2022 14:25:25 +0800
Subject: [PATCH 21/27] Bug 969 - [SW][Transformers][IPMI] M_BMC_log0011 The
 BMC generate PSU state change or failed SEL

    Symptom/Reason :
		-  The BMC should monitor the power supply and use the following SEL record to log the event to report the power supply status.

	Root Cause:
        - None

    Solution/Change:
        [dbus-sensors]
            - Checking the SDR record of PSU, if event state is failed report SEL

		[entity-manager]
			- Add event sensor for PSU state checking

    Entry Test:
	- by simulating the temperature is higher then critical high value

	busctl set-property xyz.openbmc_project.PSUSensor /xyz/openbmc_project/sensors/temperature/PSU1_Temp1 xyz.openbmc_project.Sensor.Threshold.Critical CriticalHigh d 1

root@transformers:/var/configuration# ipmitool sel elist
 28b | 05/09/22 | 12:57:44 UTC | Power Supply PSUStateCheck | Predictive failure | Asserted

ipmitool sel get 0x28b
SEL Record ID          : 028b
 Record Type           : 02
 Timestamp             : 12:57:44 UTC 12:57:44 UTC
 Generator ID          : 0020
 EvM Revision          : 04
 Sensor Type           : Power Supply
 Sensor Number         : b5
 Event Type            : Sensor-specific Discrete
 Event Direction       : Assertion Event
 Event Data (RAW)      : 020502
 Event Interpretation  : Missing
 Description           : Predictive failure

	- by simulating the VIN is higher then critical high value
	busctl set-property xyz.openbmc_project.PSUSensor /xyz/openbmc_project/sensors/voltage/PSU1_VIN xyz.openbmc_project.Sensor.Threshold.Critical CriticalHigh d 10

ipmitool sel elist

28e | 05/09/22 | 12:59:28 UTC | Power Supply PSUStateCheck | Predictive failure | Asserted

 ipmitool sel get 0x28e
SEL Record ID          : 028e
 Record Type           : 02
 Timestamp             : 12:59:28 UTC 12:59:28 UTC
 Generator ID          : 0020
 EvM Revision          : 04
 Sensor Type           : Power Supply
 Sensor Number         : b5
 Event Type            : Sensor-specific Discrete
 Event Direction       : Assertion Event
 Event Data (RAW)      : 020302
 Event Interpretation  : Missing
 Description           : Predictive failure

Sensor ID              : PSUStateCheck (0xb5)
 Entity ID             : 7.0
 Sensor Type (Discrete): Power Supply
---
 src/ms_subsystem_check.cpp | 134 ++++++++++++++++++++++++++++++++++---
 1 file changed, 124 insertions(+), 10 deletions(-)

diff --git a/src/ms_subsystem_check.cpp b/src/ms_subsystem_check.cpp
index cf4c09f..88860a1 100644
--- a/src/ms_subsystem_check.cpp
+++ b/src/ms_subsystem_check.cpp
@@ -47,16 +47,21 @@ static const std::string DBUS_OBJPATH_INTEL_ME_HEALTH_CHECK =
                         "/xyz/openbmc_project/sensors/discrete_6fh/me_health_event/IntelMEHealth";
 
 
-static const int MAX_SLEEP_TIME = 300;
+static const std::string DBUS_OBJPATH_PSU_STATE_CHECK = 
+                        "/xyz/openbmc_project/sensors/discrete_6fh/power_supply/PSUStateCheck";
+
+
+static const int MAX_SLEEP_TIME = 5;
 static const int FULL_DATA = 0xFF;
 
 static const int RESP_INDEX_POWER_STATUS = 1;
 static const int RESP_INDEX_COMPLETE_CODE = 0;
 static const int RESP_INDEX_SENSOR_NUMBER = 10;
-static const int RESP_INDEX_RECORD_ID_LSB = 1;
-static const int RESP_INDEX_RECORD_ID_MSB = 2;
+static const int RESP_INDEX_NEXT_RECORD_ID_LSB = 1;
+static const int RESP_INDEX_NEXT_RECORD_ID_MSB = 2;
 static const int RESP_INDEX_READING_STATUS = 2;
 static const int RESP_INDEX_RECORD_TYPE = 6;
+static const int RESP_INDEX_EVENT_STATUS_THRESHOLD_BASED_2 = 3;
 
 static const int CMD_INDEX_RECORD_ID_LSB = 2;
 static const int CMD_INDEX_RECORD_ID_MSB = 3;
@@ -157,6 +162,116 @@ void static check_IntelME_sensor_status(std::shared_ptr<sdbusplus::asio::connect
 }
 
 
+
+
+
+void static check_PSU_sensor_status(std::shared_ptr<sdbusplus::asio::connection> bus)
+{
+
+    fprintf(stderr, "%s \n", __func__);
+    uint8_t lun = 0;
+    uint8_t netfn = 0x0a;
+    uint8_t cmd = 0x23; //Get SDR command
+    std::vector<uint8_t> cmdData;
+    auto retConvey = std::make_shared<DbusRspData>();
+    std::vector<uint8_t> eventData = {0x00, 0x00, 0x00};
+
+    cmdData.resize(6, 0);
+
+    cmdData.at(CMD_INDEX_RECORD_ID_LSB) = 0x00;
+    cmdData.at(CMD_INDEX_RECORD_ID_MSB) = 0x00;
+    cmdData.at(CMD_INDEX_DATA_LENGTH) = FULL_DATA; // all the data
+
+    for(int i=0; i<255; i++)
+    {
+        // Get SDR record of specified record id
+        ipmi_method_call(lun, netfn, cmd, cmdData, retConvey);
+        if(retConvey->retData.at(RESP_INDEX_COMPLETE_CODE) == 0x00
+            && retConvey->retData.at(RESP_INDEX_RECORD_TYPE) == 0x01
+         )
+        {
+            std::string sensorId(retConvey->retData.begin()+51, retConvey->retData.end());
+            
+            
+            if((sensorId.find("PSU") != std::string::npos))
+            {
+                // using IPMI GET SENSOR EVENT STATUS (netfn=0x04, cmd=0x2b with
+                // sensor number to get sensor event status
+                uint8_t lun2 = 0;
+                uint8_t netfn2 = 0x04;
+                uint8_t cmd2 = 0x2b;
+                std::vector<uint8_t> cmdData2(1);
+                auto retConvey2 = std::make_shared<DbusRspData>();
+                cmdData2.at(CMD_INDEX_SENSOR_NUMBER) = retConvey->retData.at(
+                    RESP_INDEX_SENSOR_NUMBER); // set SensorNumber;
+
+                ipmi_method_call(lun2, netfn2, cmd2, cmdData2, retConvey2);
+
+                if (retConvey2->retData.at(RESP_INDEX_COMPLETE_CODE) == 0x00)
+                {
+                    if (retConvey2->retData.at(
+                            RESP_INDEX_EVENT_STATUS_THRESHOLD_BASED_2) != 0x00)
+                    {
+                        std::vector<uint8_t> eventData = {
+                            0xC0,
+                            retConvey->retData.at(RESP_INDEX_SENSOR_NUMBER),
+                            0xFF};
+                        eventData.at(0) = 0x02; // as ms spec defined
+                        eventData.at(2) = retConvey2->retData.at(
+                            RESP_INDEX_EVENT_STATUS_THRESHOLD_BASED_2);
+                        uint8_t ev1 = 0x05; // OTHER defined in ms spec
+                        if (sensorId.find("VOUT") != std::string::npos)
+                        {
+                            ev1 = 0x00;
+                        }
+                        else if (sensorId.find("IOUT") != std::string::npos)
+                        {
+                            ev1 = 0x01;
+                        }
+                        else if (sensorId.find("Input_Power") !=
+                                 std::string::npos)
+                        {
+                            ev1 = 0x02;
+                        }
+                        else if (sensorId.find("Temp") != std::string::npos)
+                        {
+                            ev1 = 0x03;
+                        }
+                        else if (sensorId.find("VOUT") != std::string::npos)
+                        {
+                            ev1 = 0x07;
+                        }
+                        eventData.at(1) = ev1;
+
+                        do_SystemEventRecordSEL(
+                            bus, DBUS_OBJPATH_PSU_STATE_CHECK, eventData,
+                            std::string("Check PSU State"), true,
+                            static_cast<uint8_t>(0x20));
+                    }
+                }
+            }
+        }else if(retConvey->ec.value() != 0x00){
+            fprintf(stderr, "index %02X is failed ec=%d\n", i, retConvey->ec.value());
+        }
+
+        
+
+        // At the end, get all SDR records done.
+        if( (retConvey->retData[RESP_INDEX_NEXT_RECORD_ID_LSB]==0xFF) && 
+                (retConvey->retData[RESP_INDEX_NEXT_RECORD_ID_MSB]==0xFF)) {
+            break;
+        }else{
+            //setup cmdData to get next SDR record
+            cmdData.at(CMD_INDEX_RECORD_ID_LSB) = retConvey->retData.at(RESP_INDEX_NEXT_RECORD_ID_LSB);
+            cmdData.at(CMD_INDEX_RECORD_ID_MSB) = retConvey->retData.at(RESP_INDEX_NEXT_RECORD_ID_MSB);
+            cmdData.at(CMD_INDEX_DATA_LENGTH) = FULL_DATA; //all the data
+        }
+
+    }
+}
+
+
+
 void static check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::connection> bus)
 {
     fprintf(stderr, "%s \n", __func__);
@@ -236,20 +351,18 @@ void static check_subsystem_sensor_status(std::shared_ptr<sdbusplus::asio::conne
                 }
             }
 
-        }else{
+        }else if(retConvey->ec.value() != 0x00){
             fprintf(stderr, "index %02X is failed ec=%d\n", i, retConvey->ec.value());
         }
 
-        
-
         // At the end, get all SDR records done.
-        if( (retConvey->retData[RESP_INDEX_RECORD_ID_LSB]==0xFF) && 
-                (retConvey->retData[RESP_INDEX_RECORD_ID_MSB]==0xFF)) {
+        if( (retConvey->retData[RESP_INDEX_NEXT_RECORD_ID_LSB]==0xFF) && 
+                (retConvey->retData[RESP_INDEX_NEXT_RECORD_ID_MSB]==0xFF)) {
             break;
         }else{
             //setup cmdData to get next SDR record
-            cmdData.at(CMD_INDEX_RECORD_ID_LSB) = retConvey->retData.at(RESP_INDEX_RECORD_ID_LSB);
-            cmdData.at(CMD_INDEX_RECORD_ID_MSB) = retConvey->retData.at(RESP_INDEX_RECORD_ID_MSB);
+            cmdData.at(CMD_INDEX_RECORD_ID_LSB) = retConvey->retData.at(RESP_INDEX_NEXT_RECORD_ID_LSB);
+            cmdData.at(CMD_INDEX_RECORD_ID_MSB) = retConvey->retData.at(RESP_INDEX_NEXT_RECORD_ID_MSB);
             cmdData.at(CMD_INDEX_DATA_LENGTH) = FULL_DATA; //all the data
         }
 
@@ -283,6 +396,7 @@ int main(int argc, char** argv)
     {
         check_subsystem_sensor_status(systemBus);
         check_IntelME_sensor_status(systemBus);
+        check_PSU_sensor_status(systemBus);
         sleep(MAX_SLEEP_TIME);
     }
     io.run();
-- 
2.33.0

