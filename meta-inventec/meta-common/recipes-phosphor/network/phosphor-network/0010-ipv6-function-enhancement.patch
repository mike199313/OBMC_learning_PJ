From 04fc6e754ef6e4c7388427c8555984fc16d2e54e Mon Sep 17 00:00:00 2001
From: "sun.cwsun" <sun.cwsun@inventec.com>
Date: Thu, 15 Sep 2022 15:07:51 +0800
Subject: [PATCH] ipv6 function enhancement

[comment for 2.12 upgrade]
Some parts of code in setNICAdminState is deleted in commit 5dad2aaf
Remove related code in this patch
---
 src/ethernet_interface.cpp   | 217 +++++++++++++++++++++++++++--------
 src/ethernet_interface.hpp   |  14 +++
 src/network_config.cpp       |   2 +-
 src/network_manager.cpp      |   1 -
 src/network_manager.hpp      |  11 ++
 src/routing_table.cpp        |  41 +++++++
 src/routing_table.hpp        |  21 ++++
 src/system_configuration.cpp |   3 +
 src/types.hpp                |   3 +-
 src/util.cpp                 |  16 ++-
 10 files changed, 280 insertions(+), 49 deletions(-)

diff --git a/src/ethernet_interface.cpp b/src/ethernet_interface.cpp
index d304c23..5d18bcc 100644
--- a/src/ethernet_interface.cpp
+++ b/src/ethernet_interface.cpp
@@ -77,10 +77,10 @@ struct EthernetIntfSocket
 };
 
 std::map<EthernetInterface::DHCPConf, std::string> mapDHCPToSystemd = {
-    {EthernetInterface::DHCPConf::both, "true"},
+    {EthernetInterface::DHCPConf::both, "yes"},
     {EthernetInterface::DHCPConf::v4, "ipv4"},
     {EthernetInterface::DHCPConf::v6, "ipv6"},
-    {EthernetInterface::DHCPConf::none, "false"}};
+    {EthernetInterface::DHCPConf::none, "no"}};
 
 static stdplus::Fd& getIFSock()
 {
@@ -133,6 +133,12 @@ EthernetInterface::EthernetInterface(sdbusplus::bus::bus& bus,
 
     EthernetInterfaceIntf::defaultGateway(defaultGateway);
     EthernetInterfaceIntf::defaultGateway6(defaultGateway6);
+
+    if( manager.getRouteTable().getStaticRouter1PrefixLength() != 0 ){
+        EthernetInterfaceIntf::gateway6PrefixValue(manager.getRouteTable().getStaticRouter1PrefixValue());
+        EthernetInterfaceIntf::gateway6PrefixLength(manager.getRouteTable().getStaticRouter1PrefixLength());
+    }
+
     // Don't get the mac address from the system as the mac address
     // would be same as parent interface.
     if (intfName.find(".") == std::string::npos)
@@ -158,6 +164,21 @@ EthernetInterface::EthernetInterface(sdbusplus::bus::bus& bus,
     }
 }
 
+std::string EthernetInterface::gateway6PrefixValue(std::string prefixValue)
+{
+    EthernetInterfaceIntf::gateway6PrefixValue(prefixValue);
+    manager.writeToConfigurationFile();
+    return prefixValue;
+}
+
+uint8_t EthernetInterface::gateway6PrefixLength(uint8_t prefixLength)
+{
+    EthernetInterfaceIntf::gateway6PrefixLength(prefixLength);
+    manager.writeToConfigurationFile();
+    return prefixLength;
+}
+
+
 static IP::Protocol convertFamily(int family)
 {
     switch (family)
@@ -249,6 +270,17 @@ void EthernetInterface::createIPAddressObjects()
             std::make_shared<phosphor::network::IPAddress>(
                 bus, ipAddressObjectPath.c_str(), *this, addressType,
                 addr.ipaddress, origin, addr.prefix, gateway));
+
+        if( (interfaceName()== DEFAULT_NIC)
+            && (manager.getRouteTable().getStaticRouter1PrefixLength() == 0)
+            && (defaultGateway6().size()!=0)
+            && (addr.prefixValue.size()!=0) ){
+                if(defaultGateway6().find(addr.prefixValue.c_str(), 0, addr.prefixValue.size()-1) != std::string::npos){
+                    gateway6PrefixValue(addr.prefixValue);
+                    gateway6PrefixLength(static_cast<uint8_t>(addr.prefix));
+                }
+        }
+
     }
 }
 
@@ -608,6 +640,7 @@ uint8_t EthernetInterface::ipv6HopLimit(uint8_t value)
 
     EthernetInterfaceIntf::ipv6HopLimit(value);
     manager.writeToConfigurationFile();
+    manager.reloadConfigs();
     return value;
 }
 
@@ -618,11 +651,11 @@ EthernetInterface::IPFamilyConf EthernetInterface::ipFamily(IPFamilyConf value)
         return value;
     }
 
-    bool nic_restart = (EthernetInterfaceIntf::ipFamily() == IPFamilyConf::v4);
     EthernetInterfaceIntf::ipFamily(value);
     DHCPConf dhcp_orig = EthernetInterfaceIntf::dhcpEnabled();
     DHCPConf dhcp_next = DHCPConf::both;
     std::string strMode = "both";
+    bool acceptRA = true;
 
     if (value == IPFamilyConf::v4)
     {
@@ -635,6 +668,7 @@ EthernetInterface::IPFamilyConf EthernetInterface::ipFamily(IPFamilyConf value)
         dhcp_next = DHCPConf::v6;
     }
 
+    EthernetInterfaceIntf::ipv6AcceptRA(acceptRA);
     updateConfigValue<std::string>(LAN_CONFIG_IP_FAMILY, strMode);
 
     if (dhcp_orig == DHCPConf::none || dhcp_orig == dhcp_next)
@@ -646,10 +680,7 @@ EthernetInterface::IPFamilyConf EthernetInterface::ipFamily(IPFamilyConf value)
         dhcpEnabled(dhcp_next);
     }
 
-    if (nic_restart)
-    {
-        manager.startNicResetTimer();
-    }
+    manager.startNicResetTimer();
 
     return value;
 }
@@ -744,6 +775,12 @@ bool EthernetInterface::queryNicEnabled() const
 
     // Build a matcher before making the property call to ensure we
     // can eventually get the value.
+    // match string=type='signal',sender='org.freedesktop.network1',
+    //      path='/org/freedesktop/network1/link/_32',
+    //      interface='org.freedesktop.DBus.Properties',
+    //      member='PropertiesChanged',
+    //      arg0='org.freedesktop.network1.Link'
+    // By 'networkctl' to check the NIC state
     sdbusplus::bus::match::match match(
         bus,
         fmt::format("type='signal',sender='{}',path='{}',interface='{}',member="
@@ -809,6 +846,9 @@ bool EthernetInterface::queryNicEnabled() const
 
 static void setNICAdminState(const char* intf, bool up)
 {
+    // error get fd, the bad move constructor / move assignment of
+    // EthnerIntfSocket
+    EthernetIntfSocket eifSocket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
     ifreq ifr = {};
     std::strncpy(ifr.ifr_name, intf, IF_NAMESIZE - 1);
     getIFSock().ioctl(SIOCGIFFLAGS, &ifr);
@@ -816,6 +856,8 @@ static void setNICAdminState(const char* intf, bool up)
     ifr.ifr_flags &= ~IFF_UP;
     ifr.ifr_flags |= up ? IFF_UP : 0;
     getIFSock().ioctl(SIOCSIFFLAGS, &ifr);
+
+    fprintf(stderr, "NIC %s:%d done \n", up ? "up" : "down", up);
 }
 
 bool EthernetInterface::nicEnabled(bool value)
@@ -827,14 +869,23 @@ bool EthernetInterface::nicEnabled(bool value)
 
     EthernetInterfaceIntf::nicEnabled(value);
     writeConfigurationFile();
-    if (!value)
+
+    EthernetIntfSocket eifSocket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
+    if (eifSocket.sock < 0)
     {
-        // We only need to bring down the interface, networkd will always bring
-        // up managed interfaces
-        manager.addReloadPreHook([ifname = interfaceName()]() {
-            setNICAdminState(ifname.c_str(), false);
-        });
+        return EthernetInterfaceIntf::nicEnabled();
     }
+    auto ifname = interfaceName();
+
+    manager.addReloadPreHook(
+        [value, ifname = std::move(ifname), eifSocket = std::move(eifSocket)]() {
+            setNICAdminState(ifname.c_str(), value);
+        });
+    manager.addReloadPreHook(
+        []() { std::this_thread::sleep_for(std::chrono::milliseconds(100)); });
+
+    EthernetInterfaceIntf::nicEnabled(value);
+
     manager.reloadConfigs();
 
     return value;
@@ -1091,6 +1142,9 @@ void EthernetInterface::writeConfigurationFile()
     using namespace std::string_literals;
     namespace fs = std::filesystem;
 
+    bool isDHCPv4Enable = dhcpIsEnabled(IP::Protocol::IPv4);
+    bool isDHCPv6Enable = dhcpIsEnabled(IP::Protocol::IPv6);
+
     if (interfaceName() == USB_INTF_NAME)
     {
         // usb0 interface is not cinfigurable
@@ -1136,7 +1190,15 @@ void EthernetInterface::writeConfigurationFile()
     }
 #endif
 
-    if (!EthernetInterfaceIntf::nicEnabled())
+    //The Origin OpenBmc is only support dual stack. 
+    //it means the ipv4 and ipv6 are existing and function at the same time.
+    //But OpenBMC in Inventec needs the ipv4 and ipv6 can be enable / disable by ipFamily().
+    //The Unmanaged property will be "yes" when the ipfamily() changing the protocol and down/up the interface.
+    //It will make the eth0 as unmanaged when NIC down and the NIC will not work anymore until
+    //Someone manually remove the Unmanaged="yes" from the NIC configuration.
+    //It is annonying.
+    if (!EthernetInterfaceIntf::nicEnabled() 
+        && (manager.preHookSize()==0) )
     {
         stream << "Unmanaged=yes\n";
     }
@@ -1159,18 +1221,27 @@ void EthernetInterface::writeConfigurationFile()
 #else
     stream << "LinkLocalAddressing=no\n";
 #endif
-    if (EthernetInterfaceIntf::ipFamily() == EthernetInterfaceIntf::IPFamilyConf::v4)
-    {
-        stream << "IPv6AcceptRA=false\n";
-    }
-    else if (EthernetInterfaceIntf::ipFamily() == EthernetInterfaceIntf::IPFamilyConf::v6)
+
+    if ((isDHCPv6Enable == true) &&
+        ((EthernetInterfaceIntf::ipFamily() ==
+          EthernetInterfaceIntf::IPFamilyConf::v6) ||
+         (EthernetInterfaceIntf::ipFamily() ==
+          EthernetInterfaceIntf::IPFamilyConf::both)))
+
     {
-        stream << "IPv6AcceptRA=true\n";
+        stream << std::boolalpha
+               << "IPv6AcceptRA="
+               << "true"
+               << "\n";
+        EthernetInterfaceIntf::ipv6AcceptRA(true);
     }
     else
     {
         stream << std::boolalpha
-            << "IPv6AcceptRA=" << EthernetInterfaceIntf::ipv6AcceptRA() << "\n";
+               << "IPv6AcceptRA="
+               << "false"
+               << "\n";
+        EthernetInterfaceIntf::ipv6AcceptRA(false);
     }
 
     // Add the VLAN entry
@@ -1191,32 +1262,67 @@ void EthernetInterface::writeConfigurationFile()
         stream << "DNS=" << dns << "\n";
     }
 
-    // Add the DHCP entry
-    stream << "DHCP="s +
-                  mapDHCPToSystemd[EthernetInterfaceIntf::dhcpEnabled()] + "\n";
-
-    stream << "[IPv6AcceptRA]\n";
-    stream << "DHCPv6Client=";
-    stream << (dhcpIsEnabled(IP::Protocol::IPv6) ? "true" : "false");
-    stream << "\n";
+    // cwsun: The IPMIv2.0 spec doest not have any command to set the dhcpv6
+    // enable or disable so isDHCPv6Enable and isDHCPv4Enable all have the same
+    // bool value. the ipmi command setLan() in phosphor-ipmi-host set it.
+    if (isDHCPv4Enable && (EthernetInterfaceIntf::ipFamily() ==
+                           EthernetInterfaceIntf::IPFamilyConf::v4))
+    {
+        stream << "DHCP="s
+               << "ipv4"
+               << "\n";
+    }
+    else if (isDHCPv6Enable && (EthernetInterfaceIntf::ipFamily() ==
+                                EthernetInterfaceIntf::IPFamilyConf::v6))
+    {
+        stream << "DHCP="s
+               << "ipv6"
+               << "\n";
+    }
+    else if (isDHCPv6Enable && isDHCPv4Enable &&
+             (EthernetInterfaceIntf::ipFamily() ==
+              EthernetInterfaceIntf::IPFamilyConf::both))
+    {
+        stream << "DHCP="s
+               << "yes"
+               << "\n";
+    }
+    else
+    {
+        stream << "DHCP="s
+               << "no"
+               << "\n";
+    }
 
     // Add the IPv6HopLimit entry
     if (EthernetInterfaceIntf::ipv6HopLimit() > 0)
     {
         stream << "IPv6HopLimit=" << std::to_string(EthernetInterfaceIntf::ipv6HopLimit()) << "\n";
     }
+    
+    stream << "[IPv6AcceptRA]\n";
+    stream << "DHCPv6Client=";
+    std::string value = (dhcpIsEnabled(IP::Protocol::IPv6) &&
+                         (EthernetInterfaceIntf::ipFamily() ==
+                              EthernetInterfaceIntf::IPFamilyConf::v6 ||
+                          EthernetInterfaceIntf::ipFamily() ==
+                              EthernetInterfaceIntf::IPFamilyConf::both))
+                            ? "true"
+                            : "false";
+    stream << value << "\n";
+
 
     // Static IP addresses
     for (const auto& addr : addrs)
     {
         if (EthernetInterfaceIntf::ipFamily() == EthernetInterfaceIntf::IPFamilyConf::v6
-            && addr.second->type() == IP::Protocol::IPv4)
+                && addr.second->type() == IP::Protocol::IPv4)
         {
             // Abandon IPv4 static address because IPFamily is set to IPv6 mode
             continue;
         }
-        else if (EthernetInterfaceIntf::ipFamily() == EthernetInterfaceIntf::IPFamilyConf::v4
-            && addr.second->type() == IP::Protocol::IPv6)
+        else if (EthernetInterfaceIntf::ipFamily() == EthernetInterfaceIntf::IPFamilyConf::v4 
+                     && addr.second->type() == IP::Protocol::IPv6)
         {
             // Abandon IPv6 static address because IPFamily is set to IPv4 mode
             continue;
@@ -1231,8 +1337,26 @@ void EthernetInterface::writeConfigurationFile()
 
             // build the address entries. Do not use [Network] shortcuts to
             // insert address entries.
-            stream << "[Address]\n";
-            stream << "Address=" << address << "\n";
+            //The phosphor-network support ipFamily 
+            //Write the static ip address depends on current ipFamily setting.
+            if( addr.second->type() == IP::Protocol::IPv6
+                && (
+                    EthernetInterfaceIntf::ipFamily() == EthernetInterfaceIntf::IPFamilyConf::v6
+                    || EthernetInterfaceIntf::ipFamily() == EthernetInterfaceIntf::IPFamilyConf::both
+                ))
+            {
+                stream << "[Address]\n";
+                stream << "Address=" << address << "\n";
+
+            }else if( addr.second->type() == IP::Protocol::IPv4
+                && (
+                    EthernetInterfaceIntf::ipFamily() == EthernetInterfaceIntf::IPFamilyConf::v4
+                    || EthernetInterfaceIntf::ipFamily() == EthernetInterfaceIntf::IPFamilyConf::both
+                ))
+            {
+                stream << "[Address]\n";
+                stream << "Address=" << address << "\n";
+            }
         }
     }
 
@@ -1250,7 +1374,7 @@ void EthernetInterface::writeConfigurationFile()
     if (!dhcpIsEnabled(IP::Protocol::IPv6))
     {
         auto gateway6 = EthernetInterfaceIntf::defaultGateway6();
-        if (!gateway6.empty()
+        if (!gateway6.empty() 
             && EthernetInterfaceIntf::ipFamily() != EthernetInterfaceIntf::IPFamilyConf::v4)
         {
             stream << "[Route]\n";
@@ -1258,13 +1382,16 @@ void EthernetInterface::writeConfigurationFile()
         }
     }
 
-    // Write the neighbor sections
-    for (const auto& neighbor : staticNeighbors)
-    {
-        stream << "[Neighbor]"
-               << "\n";
-        stream << "Address=" << neighbor.second->ipAddress() << "\n";
-        stream << "MACAddress=" << neighbor.second->macAddress() << "\n";
+
+    if(EthernetInterfaceIntf::ipFamily() == EthernetInterfaceIntf::IPFamilyConf::v6
+        || EthernetInterfaceIntf::ipFamily() == EthernetInterfaceIntf::IPFamilyConf::both){
+        for (const auto& neighbor : staticNeighbors)
+        {
+            stream << "[Neighbor]"
+                << "\n";
+            stream << "Address=" << neighbor.second->ipAddress() << "\n";
+            stream << "MACAddress=" << neighbor.second->macAddress() << "\n";
+        }
     }
 
     // Write the dhcp section irrespective of whether DHCP is enabled or not
@@ -1356,13 +1483,13 @@ std::string EthernetInterface::macAddress(std::string value)
         /* Inventec hook for mac setting */
         try{
             auto method = bus.new_method_call(SYSTEMD_BUSNAME, SYSTEMD_PATH,
-                                          SYSTEMD_INTERFACE, "StartUnit");
+                                              SYSTEMD_INTERFACE, "StartUnit");
             method.append("mac_util_config@" + value + "_"+ interface + ".service", "replace");
             bus.call_noreply(method);
         }catch (const sdbusplus::exception::SdBusError& ex){
             log<level::ERR>("Failed to hook for mac setting",
-                        entry("UNIT=%s", "mac_util_config@.service"),
-                        entry("ERR=%s", ex.what()));
+                            entry("UNIT=%s", "mac_util_config@.service"),
+                            entry("ERR=%s", ex.what()));
             elog<InternalFailure>();
         }
     }
diff --git a/src/ethernet_interface.hpp b/src/ethernet_interface.hpp
index 70003e6..41fc14e 100644
--- a/src/ethernet_interface.hpp
+++ b/src/ethernet_interface.hpp
@@ -269,6 +269,20 @@ class EthernetInterface : public Ifaces
     /** @brief Absolute path of the resolv conf file */
     static constexpr auto resolvConfFile = "/etc/resolv.conf";
 
+    /** @brief set the static router1 prefix value
+     *  @param[in] prefixValue - the static router1 prefix value
+     */
+    std::string gateway6PrefixValue(std::string prefixValue) override;
+
+    using EthernetInterfaceIntf::gateway6PrefixValue;
+
+    /** @brief set the static router1 prefix length
+     *  @param[in] prefixValue - the static router1 prefix length
+     */
+    uint8_t gateway6PrefixLength(uint8_t prefixLength) override;
+
+    using EthernetInterfaceIntf::gateway6PrefixLength;
+    
   protected:
     /** @brief get the info of the ethernet interface.
      *  @return tuple having the link speed,autonegotiation,duplexmode .
diff --git a/src/network_config.cpp b/src/network_config.cpp
index 195bef1..f27091b 100644
--- a/src/network_config.cpp
+++ b/src/network_config.cpp
@@ -41,7 +41,7 @@ void writeDHCPDefault(const std::string& filename, const std::string& interface)
     // file is not present, or after the default file has been
     // manually removed.
     filestream << "[Match]\nName=" << interface <<
-                "\n[Network]\nDHCP=true\n"
+                "\n[Network]\nDHCP=yes\n"
 #ifdef LINK_LOCAL_AUTOCONFIGURATION
                 "LinkLocalAddressing=yes\n"
 #else
diff --git a/src/network_manager.cpp b/src/network_manager.cpp
index cf0dbd8..e65cf17 100644
--- a/src/network_manager.cpp
+++ b/src/network_manager.cpp
@@ -336,7 +336,6 @@ void Manager::restartNIC(const std::string& interface)
         if (intf.second->interfaceName() == interface)
         {
             intf.second->nicEnabled(false);
-            std::this_thread::sleep_for(std::chrono::milliseconds(1000));
             intf.second->nicEnabled(true);
             break;
         }
diff --git a/src/network_manager.hpp b/src/network_manager.hpp
index 4fd9426..5bdf46e 100644
--- a/src/network_manager.hpp
+++ b/src/network_manager.hpp
@@ -189,6 +189,17 @@ class Manager : public details::VLANCreateIface
         reloadPreHooks.push_back(std::move(hook));
     }
 
+    /**
+     * @brief return the preHook list size. return non-zero means config is cheanged and 
+     * some actions need to be accomplish to make new config working.
+     * 
+     * @return size_t how man hooks in the list
+     */
+    inline size_t preHookSize(void)
+    {
+        return reloadPreHooks.size();
+    }
+
   protected:
     /** @brief Persistent sdbusplus DBus bus connection. */
     sdbusplus::bus::bus& bus;
diff --git a/src/routing_table.cpp b/src/routing_table.cpp
index 0206743..13a3b43 100644
--- a/src/routing_table.cpp
+++ b/src/routing_table.cpp
@@ -42,6 +42,13 @@ void Table::refresh()
     }
 }
 
+uint8_t get_bit(uint8_t val, uint8_t index)
+{
+    return ( val & (1<<index)) >> index;
+}
+
+
+std::string defgw6ifNameStr;
 void Table::parseRoutes(const nlmsghdr& hdr, std::string_view msg)
 {
     std::optional<InAddrAny> dstAddr;
@@ -97,6 +104,10 @@ void Table::parseRoutes(const nlmsghdr& hdr, std::string_view msg)
         else if (rtm.rtm_family == AF_INET6)
         {
             defaultGateway6[ifNameStr] = gatewayStr;
+            if(defgw6ifNameStr.size()==0)
+            {
+                defgw6ifNameStr = ifNameStr;
+            }
         }
     }
     Entry route(dstStr, gatewayStr, ifName);
@@ -109,6 +120,36 @@ void Table::parseRoutes(const nlmsghdr& hdr, std::string_view msg)
     {
         routeList.emplace(std::make_pair(dstStr, std::move(route)));
     }
+
+    // check if it is ipv6 dst addr
+    if (rtm.rtm_family == AF_INET6)
+    {
+        if (dstStr.length() < 5)
+        {
+            return;
+        }
+        if (dstStr.compare("::1") == 0)
+        {
+            return;
+        }
+
+
+        if (isLinkLocalIP(dstStr) == false)
+        {
+            auto addrs = getInterfaceAddrs()[defgw6ifNameStr.c_str()];
+            for (auto& addr : addrs)
+            {
+                if ((isLinkLocalIP(addr.ipaddress)) ||
+                    addr.addrType != AF_INET6)
+                {
+                    continue;
+                }
+                staticRouter1PrefixValue = dstStr;
+                staticRouter1PrefixLength = addr.prefix;
+            }
+        }
+    }
+
 }
 
 } // namespace route
diff --git a/src/routing_table.hpp b/src/routing_table.hpp
index efe054d..4cdd3d8 100644
--- a/src/routing_table.hpp
+++ b/src/routing_table.hpp
@@ -64,6 +64,25 @@ class Table
         return defaultGateway6;
     };
 
+    /**
+     * @brief gets the static router1 prefix value.
+     *
+     * @returns the static router1 prefix value.
+     */
+    std::string getStaticRouter1PrefixValue() const
+    {
+        return staticRouter1PrefixValue;
+    }
+    /**
+     * @brief gets the static router1 prefix length.
+     *
+     * @returns the static router1 prefix length.
+     */
+    uint8_t getStaticRouter1PrefixLength() const
+    {
+        return staticRouter1PrefixLength;
+    }
+
   private:
     /**
      * @brief Parse the route and add it to the route list.
@@ -75,6 +94,8 @@ class Table
     std::map<std::string, std::string> defaultGateway;  // default gateway list
     std::map<std::string, std::string> defaultGateway6; // default gateway list
     Map routeList;                                      // List of routes
+    std::string staticRouter1PrefixValue;   // static router 1 prefix value
+    std::uint8_t staticRouter1PrefixLength; // static router 1 prefix length
 };
 
 } // namespace route
diff --git a/src/system_configuration.cpp b/src/system_configuration.cpp
index b430bfc..6b138bf 100644
--- a/src/system_configuration.cpp
+++ b/src/system_configuration.cpp
@@ -2,6 +2,9 @@
 
 #include "system_configuration.hpp"
 
+#include "config_parser.hpp"
+#include "network_manager.hpp"
+
 #include <phosphor-logging/elog-errors.hpp>
 #include <phosphor-logging/log.hpp>
 #include <xyz/openbmc_project/Common/error.hpp>
diff --git a/src/types.hpp b/src/types.hpp
index 65cf7d2..2a6604d 100644
--- a/src/types.hpp
+++ b/src/types.hpp
@@ -34,7 +34,7 @@ constexpr auto reloadTimeout = 3s;
 // configuration takes 3-4 sec after systemd-networkd restart.
 constexpr auto refreshTimeout = reloadTimeout + 7s;
 
-constexpr auto restartNicTimeout = refreshTimeout + 2s;
+constexpr auto restartNicTimeout = 0s;
 
 constexpr auto restartNetipmidTimeout = refreshTimeout + 4s;
 
@@ -57,6 +57,7 @@ struct AddrInfo
     uint8_t addrType;
     std::string ipaddress;
     uint16_t prefix;
+    std::string prefixValue;
 };
 
 using Addr_t = ifaddrs*;
diff --git a/src/util.cpp b/src/util.cpp
index 8e8f4d8..2ad77d7 100644
--- a/src/util.cpp
+++ b/src/util.cpp
@@ -348,6 +348,7 @@ IntfAddrMap getInterfaceAddrs()
             AddrInfo info{};
             char ip[INET6_ADDRSTRLEN] = {0};
             char subnetMask[INET6_ADDRSTRLEN] = {0};
+            char prefixValue[INET6_ADDRSTRLEN] = {0};
 
             if (ifa->ifa_addr->sa_family == AF_INET)
             {
@@ -371,11 +372,24 @@ IntfAddrMap getInterfaceAddrs()
                     ifa->ifa_addr->sa_family,
                     &(((struct sockaddr_in6*)(ifa->ifa_netmask))->sin6_addr),
                     subnetMask, sizeof(subnetMask));
+
+                unsigned char buf[sizeof(struct in6_addr)];;
+
+                for(unsigned int i=0; i<sizeof(struct in6_addr); i++){
+                    buf[i] = ((struct sockaddr_in6*)(ifa->ifa_addr))->sin6_addr.s6_addr[i] &
+                                    ((struct sockaddr_in6*)(ifa->ifa_netmask))->sin6_addr.s6_addr[i];
+                }
+                inet_ntop(
+                    ifa->ifa_addr->sa_family,
+                    &buf,
+                    prefixValue, sizeof(prefixValue));
             }
 
             info.addrType = ifa->ifa_addr->sa_family;
             info.ipaddress = ip;
             info.prefix = toCidr(info.addrType, std::string(subnetMask));
+            info.prefixValue = std::string(prefixValue);
+
             intfMap[intfName].push_back(info);
         }
     }
@@ -505,7 +519,7 @@ EthernetInterfaceIntf::DHCPConf getDHCPValue(const std::string& confDir,
         return dhcp;
     }
     // There will be only single value for DHCP key.
-    if (values[0] == "true")
+    if (values[0] == "true" || values[0] == "yes")
     {
         dhcp = EthernetInterfaceIntf::DHCPConf::both;
     }
-- 
2.33.0

