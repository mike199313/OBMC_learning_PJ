From 616923efc2692355eb48e3b9f3c0e0d33f6ec2b8 Mon Sep 17 00:00:00 2001
From: "pj.chen" <chen.pj@inventec.com>
Date: Thu, 3 Mar 2022 08:35:11 +0000
Subject: [PATCH 02/31] Sensor - Implement GetSensorReadingFactors command

Symptom/Reason:
    Implement Get Sensor Reading Factors command.

Root Cause:
    N/A

Solution/Change:
    sensorhandler -
        Add ipmiGetSensorReadingFactors() and declare struct get_sdr::GetSensorReadingFactorsResponse

Entry Test:

sysadmin@goldentalon:~# ipmitool raw 0x04 0x23 0x03 0x00
 ff 01 00 00 00 00 00

sysadmin@goldentalon:~# ipmitool raw 0x0a 0x23 0x00 0x00 0x03 0x00 0x00 0xff
 0e 00 03 00 51 01 40 20 00 03 07 07 00 00 01 01
 00 00 00 00 00 00 00 01 00 00 01 00 00 00 00 00
 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
 00 08 53 43 4d 5f 54 45 4d 50 00 00 00 00 00 00
 00 00

From Table 43-1, Full Sensor Record - SDR Type 01h

Start from Byte 26: 01 00 00 00 00 00, is the same
---
 sensorhandler.cpp | 83 +++++++++++++++++++++++++++++++++++++++++++++++
 sensorhandler.hpp | 21 ++++++++++++
 2 files changed, 104 insertions(+)

diff --git a/sensorhandler.cpp b/sensorhandler.cpp
index a332548..ecd932c 100644
--- a/sensorhandler.cpp
+++ b/sensorhandler.cpp
@@ -947,6 +947,80 @@ ipmi::RspType<> ipmiSensorSetSensorThresholds( uint8_t sensorNum,
     return ipmi::responseSuccess();
 }
 
+/*
+Inventec patch: [sensorhandler] - Implement GetSensorReadingFactors command
+*/
+/** @brief implements the Get Sensor Reading Factors command
+ *  @param sensorNum - sensor number
+ *
+ *  @returns IPMI completion code plus response data
+ *   - next_reading
+ *   - m_lsb
+ *   - m_msb_and_tolerance
+ *   - b_lsb
+ *   - b_msb_and_accuracy_lsb
+ *   - accuracy_and_accuracy_exp
+ *   - r_b_exponents
+ */
+ipmi::RspType<uint8_t, // next_reading
+              uint8_t, // m_lsb
+              uint8_t, // m_msb_and_tolerance
+              uint8_t, // b_lsb
+              uint8_t, // b_msb_and_accuracy_lsb
+              uint8_t, // accuracy_and_accuracy_exp
+              uint8_t  // r_b_exponents
+              >
+    ipmiGetSensorReadingFactors(uint8_t sensorNum, uint8_t readingByte)
+{
+    const auto iter = ipmi::sensor::sensors.find(sensorNum);
+    if (iter == ipmi::sensor::sensors.end())
+    {
+        return ipmi::responseSensorInvalid();
+    }
+    const auto info = iter->second;
+
+
+    if (!isAnalogSensor(info.propertyInterfaces.begin()->first))
+    {
+        return ipmi::responseSensorInvalid();
+    }
+
+    get_sdr::GetSensorReadingFactorsResponse resp{};
+    memset(&resp, 0, sizeof(get_sdr::GetSensorThresholdsResponse));
+
+    /*
+    Currently we didn't support mutiple factors, igore the readingByte.
+    Set the next_reading to 0xFF, or else we should have a factor table.
+    The next_reading should be the next entry in the table.
+    */
+    resp.next_reading = 0xFF;
+
+    resp.m_lsb = info.coefficientM & 0xff;
+    resp.m_msb_and_tolerance &= ~(3 << 6);
+    resp.m_msb_and_tolerance |= ((info.coefficientM & (3 << 8)) >> 2);
+
+    /* Skip Tolerance part, refer to populate_record_from_dbus()*/
+
+    resp.b_lsb = info.coefficientB & 0xff;
+    resp.b_msb_and_accuracy_lsb &= ~(3 << 6);
+    resp.b_msb_and_accuracy_lsb |= ((info.coefficientB & (3 << 8)) >> 2);
+
+    /* Skip Accuracy and Accuracy_exp part, refer to populate_record_from_dbus()*/
+
+    resp.r_b_exponents &= 0xf0;
+    resp.r_b_exponents |= info.exponentB & 0x0f;
+
+    resp.r_b_exponents &= 0x0f;
+    resp.r_b_exponents |= (info.exponentR & 0x0f) << 4;
+
+
+    return ipmi::responseSuccess(resp.next_reading, resp.m_lsb,
+                                 resp.m_msb_and_tolerance, resp.b_lsb,
+                                 resp.b_msb_and_accuracy_lsb,
+                                 resp.accuracy_and_accuracy_exp,
+                                 resp.r_b_exponents);
+}
+
 
 /** @brief implements the get SDR Info command
  *  @param count - Operation
@@ -1494,10 +1568,19 @@ void register_netfn_sen_functions()
                           ipmi::sensor_event::cmdSetSensorThreshold,
                           ipmi::Privilege::Operator, ipmiSensorSetSensorThresholds);
 
+    /*
+    Inventec patch: [sensorhandler] - Implement GetSensorReadingFactors command
+    */
+    // <Get Sensor Reading Factors>
+    ipmi::registerHandler(ipmi::prioOpenBmcBase, ipmi::netFnSensor,
+                          ipmi::sensor_event::cmdGetSensorReadingFactors,
+                          ipmi::Privilege::User, ipmiGetSensorReadingFactors);
+
     // <Get Device SDR>
     ipmi_register_callback(NETFUN_SENSOR, IPMI_CMD_GET_DEVICE_SDR, nullptr,
                            ipmi_sen_get_sdr, PRIVILEGE_USER);
 
+
 #endif
 
     // Common Handers used by both implementation.
diff --git a/sensorhandler.hpp b/sensorhandler.hpp
index ea9fa3c..8ad9103 100644
--- a/sensorhandler.hpp
+++ b/sensorhandler.hpp
@@ -294,6 +294,27 @@ struct GetSensorThresholdsResponse
     uint8_t upperNonRecoverable; //!< upper non-recoverable threshold
 } __attribute__((packed));
 
+
+/*
+Inventec patch: [sensorhandler] - Implement GetSensorReadingFactors command
+*/
+/** @struct GetSensorReadingFactorsResponse
+ *
+ *  Response structure for Get Sensor Reading Factors command
+ */
+struct GetSensorReadingFactorsResponse
+{
+    uint8_t next_reading;
+    uint8_t m_lsb;
+    uint8_t m_msb_and_tolerance;
+    uint8_t b_lsb;
+    uint8_t b_msb_and_accuracy_lsb;
+    uint8_t accuracy_and_accuracy_exp;
+    uint8_t r_b_exponents;
+} __attribute__((packed));
+
+
+
 // Body - full record
 #define FULL_RECORD_ID_STR_MAX_LENGTH 16
 
-- 
2.33.0

