From c945b6ddef0fecac7c985d39f1a2e123ca224c51 Mon Sep 17 00:00:00 2001
From: "pj.chen" <chen.pj@inventec.com>
Date: Thu, 3 Mar 2022 05:43:33 +0000
Subject: [PATCH 01/31] Sensor - Implement SetSensorThreshold command

- Add Ipmi command SetSensorThreshold support
---
 sensorhandler.cpp | 229 ++++++++++++++++++++++------------------------
 1 file changed, 108 insertions(+), 121 deletions(-)

diff --git a/sensorhandler.cpp b/sensorhandler.cpp
index fcfd428..a332548 100644
--- a/sensorhandler.cpp
+++ b/sensorhandler.cpp
@@ -802,37 +802,51 @@ ipmi::RspType<uint8_t, // validMask
                                  resp.upperNonRecoverable);
 }
 
-/** @brief implements the Set Sensor threshold command
- *  @param sensorNumber        - sensor number
- *  @param lowerNonCriticalThreshMask
- *  @param lowerCriticalThreshMask
- *  @param lowerNonRecovThreshMask
- *  @param upperNonCriticalThreshMask
- *  @param upperCriticalThreshMask
- *  @param upperNonRecovThreshMask
- *  @param reserved
- *  @param lowerNonCritical    - lower non-critical threshold
- *  @param lowerCritical       - Lower critical threshold
- *  @param lowerNonRecoverable - Lower non recovarable threshold
- *  @param upperNonCritical    - Upper non-critical threshold
- *  @param upperCritical       - Upper critical
- *  @param upperNonRecoverable - Upper Non-recoverable
- *
- *  @returns IPMI completion code
- */
-ipmi::RspType<> ipmiSenSetSensorThresholds(
-    ipmi::Context::ptr& ctx, uint8_t sensorNum, bool lowerNonCriticalThreshMask,
-    bool lowerCriticalThreshMask, bool lowerNonRecovThreshMask,
-    bool upperNonCriticalThreshMask, bool upperCriticalThreshMask,
-    bool upperNonRecovThreshMask, uint2_t reserved, uint8_t lowerNonCritical,
-    uint8_t lowerCritical, uint8_t lowerNonRecoverable,
-    uint8_t upperNonCritical, uint8_t upperCritical,
-    uint8_t upperNonRecoverable)
+/*
+Inventec patch: [sensorhandler] - Implement SetSensorThreshold command
+*/
+/**
+@brief This command is used to set sensorReading.
+
+@param
+    -  sensorNumber
+    -  lowerNonCriticalThreshMask
+    -  lowerCriticalThreshMask
+    -  lowerNonRecovThreshMask
+    -  upperNonCriticalThreshMask
+    -  upperCriticalThreshMask
+    -  upperNonRecovThreshMask
+    -  reserved
+    -  lowerNonCritical
+    -  lowerCritical
+    -  lowerNonRecoverable
+    -  upperNonCritical
+    -  upperCritical
+    -  upperNonRecoverable
+@return completion code on success.
+**/
+
+ipmi::RspType<> ipmiSensorSetSensorThresholds( uint8_t sensorNum,
+                                            bool lowerNonCriticalThreshMask,
+                                            bool lowerCriticalThreshMask,
+                                            bool lowerNonRecovThreshMask,
+                                            bool upperNonCriticalThreshMask,
+                                            bool upperCriticalThreshMask,
+                                            bool upperNonRecovThreshMask,
+                                            uint2_t reserved,
+                                            uint8_t lowerNonCritical,
+                                            uint8_t lowerCritical,
+                                            uint8_t lowerNonRecoverable,
+                                            uint8_t upperNonCritical,
+                                            uint8_t upperCritical,
+                                            uint8_t upperNonRecoverable)
 {
-    if (reserved)
-    {
-        return ipmi::responseInvalidFieldRequest();
-    }
+    constexpr auto warningThreshIntf =
+        "xyz.openbmc_project.Sensor.Threshold.Warning";
+    constexpr auto criticalThreshIntf =
+        "xyz.openbmc_project.Sensor.Threshold.Critical";
+    constexpr auto valueInterface =
+        "xyz.openbmc_project.Sensor.Value";
 
     // lower nc and upper nc not suppported on any sensor
     if (lowerNonRecovThreshMask || upperNonRecovThreshMask)
@@ -840,23 +854,13 @@ ipmi::RspType<> ipmiSenSetSensorThresholds(
         return ipmi::responseInvalidFieldRequest();
     }
 
-    // if none of the threshold mask are set, nothing to do
-    if (!(lowerNonCriticalThreshMask | lowerCriticalThreshMask |
-          lowerNonRecovThreshMask | upperNonCriticalThreshMask |
-          upperCriticalThreshMask | upperNonRecovThreshMask))
-    {
-        return ipmi::responseSuccess();
-    }
-
-    constexpr auto valueInterface = "xyz.openbmc_project.Sensor.Value";
-
     const auto iter = ipmi::sensor::sensors.find(sensorNum);
     if (iter == ipmi::sensor::sensors.end())
     {
         return ipmi::responseSensorInvalid();
     }
 
-    const auto& info = iter->second;
+    const auto info = iter->second;
 
     // Proceed only if the sensor value interface is implemented.
     if (info.propertyInterfaces.find(valueInterface) ==
@@ -866,104 +870,84 @@ ipmi::RspType<> ipmiSenSetSensorThresholds(
         return ipmi::responseSuccess();
     }
 
-    constexpr auto warningThreshIntf =
-        "xyz.openbmc_project.Sensor.Threshold.Warning";
-    constexpr auto criticalThreshIntf =
-        "xyz.openbmc_project.Sensor.Threshold.Critical";
+    sdbusplus::bus::bus bus{ipmid_get_sd_bus_connection()};
+    auto service = ipmi::getService(bus, info.sensorInterface, info.sensorPath);
 
-    std::string service;
-    boost::system::error_code ec;
-    ec = ipmi::getService(ctx, info.sensorInterface, info.sensorPath, service);
-    if (ec)
+    if(lowerNonCriticalThreshMask)
     {
-        return ipmi::responseResponseError();
+        double warnLow =
+            (lowerNonCritical * info.coefficientM + info.scaledOffset)
+            * std::pow(10, info.exponentR - info.scale);
+
+        try
+        {
+            ipmi::setDbusProperty(bus, service,info.sensorPath,
+                    warningThreshIntf, "WarningLow", warnLow);
+        }
+        catch (const sdbusplus::exception::SdBusError& e)
+        {
+            std::fprintf(stderr,"set WarningLow fail\n");
+            return ipmi::responseInvalidFieldRequest();
+        }
     }
-    // store a vector of property name, value to set, and interface
-    std::vector<std::tuple<std::string, uint8_t, std::string>> thresholdsToSet;
 
-    // define the indexes of the tuple
-    constexpr uint8_t propertyName = 0;
-    constexpr uint8_t thresholdValue = 1;
-    constexpr uint8_t interface = 2;
-    // verifiy all needed fields are present
-    if (lowerCriticalThreshMask || upperCriticalThreshMask)
+    if(lowerCriticalThreshMask)
     {
+        double critLow =
+            (lowerCritical * info.coefficientM + info.scaledOffset)
+            * std::pow(10, info.exponentR - info.scale);
 
-        ipmi::PropertyMap findThreshold;
-        ec = ipmi::getAllDbusProperties(ctx, service, info.sensorPath,
-                                        criticalThreshIntf, findThreshold);
-
-        if (!ec)
+        try
         {
-            if (lowerCriticalThreshMask)
-            {
-                auto findLower = findThreshold.find("CriticalLow");
-                if (findLower == findThreshold.end())
-                {
-                    return ipmi::responseInvalidFieldRequest();
-                }
-                thresholdsToSet.emplace_back("CriticalLow", lowerCritical,
-                                             criticalThreshIntf);
-            }
-            if (upperCriticalThreshMask)
-            {
-                auto findUpper = findThreshold.find("CriticalHigh");
-                if (findUpper == findThreshold.end())
-                {
-                    return ipmi::responseInvalidFieldRequest();
-                }
-                thresholdsToSet.emplace_back("CriticalHigh", upperCritical,
-                                             criticalThreshIntf);
-            }
+            ipmi::setDbusProperty(bus, service,info.sensorPath,
+                    criticalThreshIntf, "CriticalLow", critLow);
+        }
+        catch (const sdbusplus::exception::SdBusError& e)
+        {
+            std::fprintf(stderr,"set CriticalLow fail\n");
+            return ipmi::responseInvalidFieldRequest();
         }
     }
-    if (lowerNonCriticalThreshMask || upperNonCriticalThreshMask)
+
+    if(upperNonCriticalThreshMask)
     {
-        ipmi::PropertyMap findThreshold;
-        ec = ipmi::getAllDbusProperties(ctx, service, info.sensorPath,
-                                        warningThreshIntf, findThreshold);
+        double warnHigh =
+            (upperNonCritical * info.coefficientM + info.scaledOffset)
+            * std::pow(10, info.exponentR - info.scale);
 
-        if (!ec)
+        try
         {
-            if (lowerNonCriticalThreshMask)
-            {
-                auto findLower = findThreshold.find("WarningLow");
-                if (findLower == findThreshold.end())
-                {
-                    return ipmi::responseInvalidFieldRequest();
-                }
-                thresholdsToSet.emplace_back("WarningLow", lowerNonCritical,
-                                             warningThreshIntf);
-            }
-            if (upperNonCriticalThreshMask)
-            {
-                auto findUpper = findThreshold.find("WarningHigh");
-                if (findUpper == findThreshold.end())
-                {
-                    return ipmi::responseInvalidFieldRequest();
-                }
-                thresholdsToSet.emplace_back("WarningHigh", upperNonCritical,
-                                             warningThreshIntf);
-            }
+            ipmi::setDbusProperty(bus, service,info.sensorPath,
+                    warningThreshIntf, "WarningHigh", warnHigh);
+        }
+        catch (const sdbusplus::exception::SdBusError& e)
+        {
+            std::fprintf(stderr,"set WarningHigh fail\n");
+            return ipmi::responseInvalidFieldRequest();
         }
     }
-    for (const auto& property : thresholdsToSet)
+
+    if(upperCriticalThreshMask)
     {
-        // from section 36.3 in the IPMI Spec, assume all linear
-        double valueToSet =
-            ((info.coefficientM * std::get<thresholdValue>(property)) +
-             (info.scaledOffset * std::pow(10.0, info.scale))) *
-            std::pow(10.0, info.exponentR);
-        ipmi::setDbusProperty(
-            ctx, service, info.sensorPath, std::get<interface>(property),
-            std::get<propertyName>(property), ipmi::Value(valueToSet));
-    }
+        double critHigh =
+            (upperCritical * info.coefficientM + info.scaledOffset)
+            * std::pow(10, info.exponentR - info.scale);
 
-    // Invalidate the cache
-    sensorThresholdMap.erase(sensorNum);
+        try
+        {
+            ipmi::setDbusProperty(bus, service,info.sensorPath,
+                    criticalThreshIntf, "CriticalHigh", critHigh);
+        }
+        catch (const sdbusplus::exception::SdBusError& e)
+        {
+            std::fprintf(stderr,"set CriticalHigh fail\n");
+            return ipmi::responseInvalidFieldRequest();
+        }
+    }
     return ipmi::responseSuccess();
 }
 
+
 /** @brief implements the get SDR Info command
  *  @param count - Operation
  *
@@ -1502,10 +1486,13 @@ void register_netfn_sen_functions()
                           ipmi::sensor_event::cmdGetSensorThreshold,
                           ipmi::Privilege::User, ipmiSensorGetSensorThresholds);
 
+    /*
+    Inventec patch: [sensorhandler] - Implement SetSensorThreshold command
+    */
     // <Set Sensor Thresholds>
     ipmi::registerHandler(ipmi::prioOpenBmcBase, ipmi::netFnSensor,
                           ipmi::sensor_event::cmdSetSensorThreshold,
-                          ipmi::Privilege::User, ipmiSenSetSensorThresholds);
+                          ipmi::Privilege::Operator, ipmiSensorSetSensorThresholds);
 
     // <Get Device SDR>
     ipmi_register_callback(NETFUN_SENSOR, IPMI_CMD_GET_DEVICE_SDR, nullptr,
-- 
2.33.0

